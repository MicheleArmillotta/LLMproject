[
  {
    "function_name": "exit_ext3_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "3154-3159",
    "snippet": "static void __exit exit_ext3_fs(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n\tdestroy_inodecache();\n\texit_ext3_xattr();\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_ext3_xattr",
          "args": [],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ext3_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.h",
          "lines": "118-121",
          "snippet": "static inline void\nexit_ext3_xattr(void)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline void\nexit_ext3_xattr(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "548-556",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext3_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ext3_fs_type"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_ext3_fs(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n\tdestroy_inodecache();\n\texit_ext3_xattr();\n}"
  },
  {
    "function_name": "init_ext3_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "3135-3152",
    "snippet": "static int __init init_ext3_fs(void)\n{\n\tint err = init_ext3_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext3_xattr();\n\treturn err;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_ext3_xattr",
          "args": [],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ext3_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.h",
          "lines": "118-121",
          "snippet": "static inline void\nexit_ext3_xattr(void)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline void\nexit_ext3_xattr(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "548-556",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext3_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ext3_fs_type"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "536-546",
          "snippet": "static int __init init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext3_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ext3_xattr",
          "args": [],
          "line": 3137
        },
        "resolved": true,
        "details": {
          "function_name": "init_ext3_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.h",
          "lines": "112-116",
          "snippet": "static inline int\ninit_ext3_xattr(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline int\ninit_ext3_xattr(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_ext3_fs(void)\n{\n\tint err = init_ext3_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext3_xattr();\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "3120-3124",
    "snippet": "static struct dentry *ext3_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext3_fill_super);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ext3_fill_super"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\n\nstatic struct dentry *ext3_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext3_fill_super);\n}"
  },
  {
    "function_name": "ext3_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "3054-3116",
    "snippet": "static ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint journal_quota = EXT3_SB(sb)->s_qf_names[type] != NULL;\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (!handle) {\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started.\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text3_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tbh = ext3_bread(handle, inode, blk, 1, &err);\n\tif (!bh)\n\t\tgoto out;\n\tif (journal_quota) {\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\tif (journal_quota)\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\telse {\n\t\t/* Always do at least ordered writes for quotas */\n\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\nout:\n\tif (err)\n\t\treturn err;\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text3_mark_inode_dirty(handle, inode);\n\treturn len;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "off + len"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3102
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_data",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_dirty_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1318-1325",
          "snippet": "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_data(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(__func__, __func__,\n\t\t\t\t\t\tbh, handle, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data+offset",
            "data",
            "len"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_bread",
          "args": [
            "handle",
            "inode",
            "blk",
            "1",
            "&err"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1128-1147",
          "snippet": "struct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\"",
            "(unsigned long long)off",
            "(unsigned long long)len"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint journal_quota = EXT3_SB(sb)->s_qf_names[type] != NULL;\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (!handle) {\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started.\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text3_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tbh = ext3_bread(handle, inode, blk, 1, &err);\n\tif (!bh)\n\t\tgoto out;\n\tif (journal_quota) {\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\tif (journal_quota)\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\telse {\n\t\t/* Always do at least ordered writes for quotas */\n\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\nout:\n\tif (err)\n\t\treturn err;\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text3_mark_inode_dirty(handle, inode);\n\treturn len;\n}"
  },
  {
    "function_name": "ext3_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "3016-3050",
    "snippet": "static ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data+offset",
            "tocopy"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "tocopy"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_bread",
          "args": [
            "NULL",
            "inode",
            "blk",
            "0",
            "&err"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1128-1147",
          "snippet": "struct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "ext3_quota_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2973-3010",
    "snippet": "static int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT3_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (ext3_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_on",
          "args": [
            "sb",
            "type",
            "format_id",
            "path"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "path->dentry->d_inode"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work.\""
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "QUOTA"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT3_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (ext3_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}"
  },
  {
    "function_name": "ext3_quota_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2964-2968",
    "snippet": "static int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_on_mount",
          "args": [
            "sb",
            "EXT3_SB(sb)->s_qf_names[type]",
            "EXT3_SB(sb)->s_jquota_fmt",
            "type"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}"
  },
  {
    "function_name": "ext3_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2944-2958",
    "snippet": "static int ext3_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext3_journal_start(sb->s_root->d_inode, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_commit_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1956-1965",
          "snippet": "int dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "sb->s_root->d_inode",
            "2"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext3_journal_start(sb->s_root->d_inode, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_mark_dquot_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2932-2942",
    "snippet": "static int ext3_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (EXT3_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    EXT3_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext3_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_mark_dquot_dirty",
          "args": [
            "dquot"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_mark_dquot_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "341-357",
          "snippet": "int dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2879-2895",
          "snippet": "static int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (EXT3_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    EXT3_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext3_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}"
  },
  {
    "function_name": "ext3_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2913-2930",
    "snippet": "static int ext3_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_release",
          "args": [
            "dquot"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "468-493",
          "snippet": "int dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dquot_to_inode(dquot)",
            "EXT3_QUOTA_DEL_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_QUOTA_DEL_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2874-2877",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_acquire_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2897-2911",
    "snippet": "static int ext3_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_acquire",
          "args": [
            "dquot"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "403-435",
          "snippet": "int dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "dquot_to_inode(dquot)",
            "EXT3_QUOTA_INIT_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_QUOTA_INIT_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2874-2877",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2879-2895",
    "snippet": "static int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_commit",
          "args": [
            "dquot"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "441-462",
          "snippet": "int dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "EXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_QUOTA_TRANS_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2874-2877",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "dquot_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2874-2877",
    "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
  },
  {
    "function_name": "ext3_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2793-2860",
    "snippet": "static int ext3_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tif (test_opt(sb, MINIX_DF)) {\n\t\tsbi->s_overhead_last = 0;\n\t} else if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long ngroups = sbi->s_groups_count, i;\n\t\text3_fsblk_t overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures).  This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\toverhead += ext3_bg_has_super(sb, i) +\n\t\t\t\text3_bg_num_gdb(sb, i);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += ngroups * (2 + sbi->s_itb_per_group);\n\n\t\t/* Add the internal journal blocks as well */\n\t\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\t\toverhead += sbi->s_journal->j_maxlen;\n\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT3_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = percpu_counter_sum_positive(&sbi->s_freeblocks_counter);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT3_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_statfs (struct dentry * dentry, struct kstatfs * buf);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpup",
          "args": [
            "(void *)es->s_uuid + sizeof(u64)"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb",
          "args": [
            "sb",
            "i"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1891-1903",
          "snippet": "unsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "i"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "MINIX_DF"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tif (test_opt(sb, MINIX_DF)) {\n\t\tsbi->s_overhead_last = 0;\n\t} else if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long ngroups = sbi->s_groups_count, i;\n\t\text3_fsblk_t overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures).  This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\toverhead += ext3_bg_has_super(sb, i) +\n\t\t\t\text3_bg_num_gdb(sb, i);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += ngroups * (2 + sbi->s_itb_per_group);\n\n\t\t/* Add the internal journal blocks as well */\n\t\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\t\toverhead += sbi->s_journal->j_maxlen;\n\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT3_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = percpu_counter_sum_positive(&sbi->s_freeblocks_counter);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT3_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2644-2791",
    "snippet": "static int ext3_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t n_blocks_count = 0;\n\tunsigned long old_sb_flags;\n\tstruct ext3_mount_options old_opts;\n\tint enable_quota = 0;\n\tint err;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\tsync_filesystem(sb);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb, NULL, NULL, &n_blocks_count, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (test_opt(sb, ABORT))\n\t\text3_abort(sb, __func__, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\text3_init_journal_params(sb, sbi->s_journal);\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY) ||\n\t\tn_blocks_count > le32_to_cpu(es->s_blocks_count)) {\n\t\tif (test_opt(sb, ABORT)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT3_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT3_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\text3_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t__le32 ret;\n\t\t\tif ((ret = EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t~EXT3_FEATURE_RO_COMPAT_SUPP))) {\n\t\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"warning: couldn't remount RDWR \"\n\t\t\t\t\t\"because of unsupported optional \"\n\t\t\t\t\t\"features (%x)\", le32_to_cpu(ret));\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount & mount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text3_msg(sb, KERN_WARNING, \"warning: couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount & mount instead.\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\text3_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif ((err = ext3_group_extend(sb, es, n_blocks_count)))\n\t\t\t\tgoto restore_opts;\n\t\t\tif (!ext3_setup_super (sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (enable_quota)\n\t\tdquot_resume(sb, -1);\n\treturn 0;\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\treturn err;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "sb",
            "-1"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_opts.s_qf_names[i]"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_setup_super",
          "args": [
            "sb",
            "es",
            "0"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1373-1440",
          "snippet": "static int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_group_extend",
          "args": [
            "sb",
            "es",
            "n_blocks_count"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "991-1117",
          "snippet": "int ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nint ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_state"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_clear_journal_err",
          "args": [
            "sb",
            "es"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_journal_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2527-2557",
          "snippet": "static void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount & mount instead.\""
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ret"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_recovery_complete",
          "args": [
            "sb",
            "es"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_recovery_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2503-2520",
          "snippet": "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_VALID_FS"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "sb",
            "-1"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ABORT"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_init_journal_params",
          "args": [
            "sb",
            "sbi->s_journal"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2164-2184",
          "snippet": "static void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_abort",
          "args": [
            "sb",
            "__func__",
            "\"Abort forced by user\""
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "275-310",
          "snippet": "void ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ABORT"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb",
            "NULL",
            "NULL",
            "&n_blocks_count",
            "1"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "981-1371",
          "snippet": "static int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_opts.s_qf_names[j]"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sbi->s_qf_names[i]",
            "GFP_KERNEL"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t n_blocks_count = 0;\n\tunsigned long old_sb_flags;\n\tstruct ext3_mount_options old_opts;\n\tint enable_quota = 0;\n\tint err;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\tsync_filesystem(sb);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb, NULL, NULL, &n_blocks_count, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (test_opt(sb, ABORT))\n\t\text3_abort(sb, __func__, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\text3_init_journal_params(sb, sbi->s_journal);\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY) ||\n\t\tn_blocks_count > le32_to_cpu(es->s_blocks_count)) {\n\t\tif (test_opt(sb, ABORT)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT3_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT3_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\text3_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t__le32 ret;\n\t\t\tif ((ret = EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t~EXT3_FEATURE_RO_COMPAT_SUPP))) {\n\t\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"warning: couldn't remount RDWR \"\n\t\t\t\t\t\"because of unsupported optional \"\n\t\t\t\t\t\"features (%x)\", le32_to_cpu(ret));\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount & mount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text3_msg(sb, KERN_WARNING, \"warning: couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount & mount instead.\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\text3_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif ((err = ext3_group_extend(sb, es, n_blocks_count)))\n\t\t\t\tgoto restore_opts;\n\t\t\tif (!ext3_setup_super (sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (enable_quota)\n\t\tdquot_resume(sb, -1);\n\treturn 0;\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2633-2642",
    "snippet": "static int ext3_unfreeze(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Reser the needs_recovery flag before the fs is unlocked. */\n\t\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "EXT3_SB(sb)->s_es",
            "1"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_unfreeze(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Reser the needs_recovery flag before the fs is unlocked. */\n\t\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2597-2627",
    "snippet": "static int ext3_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjournal = EXT3_SB(sb)->s_journal;\n\n\t\t/* Now we set up the journal barrier. */\n\t\tjournal_lock_updates(journal);\n\n\t\t/*\n\t\t * We don't want to clear needs_recovery flag when we failed\n\t\t * to flush the journal.\n\t\t */\n\t\terror = journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\terror = ext3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tjournal_unlock_updates(journal);\n\treturn error;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "EXT3_SB(sb)->s_es",
            "1"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "journal"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjournal = EXT3_SB(sb)->s_journal;\n\n\t\t/* Now we set up the journal barrier. */\n\t\tjournal_lock_updates(journal);\n\n\t\t/*\n\t\t * We don't want to clear needs_recovery flag when we failed\n\t\t * to flush the journal.\n\t\t */\n\t\terror = journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\terror = ext3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tjournal_unlock_updates(journal);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2576-2591",
    "snippet": "static int ext3_sync_fs(struct super_block *sb, int wait)\n{\n\ttid_t target;\n\n\ttrace_ext3_sync_fs(sb, wait);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\tif (journal_start_commit(EXT3_SB(sb)->s_journal, &target)) {\n\t\tif (wait)\n\t\t\tlog_wait_commit(EXT3_SB(sb)->s_journal, target);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_sync_fs(struct super_block *sb, int wait);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "EXT3_SB(sb)->s_journal",
            "target"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_start_commit",
          "args": [
            "EXT3_SB(sb)->s_journal",
            "&target"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "journal_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "538-563",
          "snippet": "int journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_writeback_dquots",
          "args": [
            "sb",
            "-1"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_writeback_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "605-652",
          "snippet": "int dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_sync_fs",
          "args": [
            "sb",
            "wait"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait)\n{\n\ttid_t target;\n\n\ttrace_ext3_sync_fs(sb, wait);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\tif (journal_start_commit(EXT3_SB(sb)->s_journal, &target)) {\n\t\tif (wait)\n\t\t\tlog_wait_commit(EXT3_SB(sb)->s_journal, target);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2563-2574",
    "snippet": "int ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_force_commit",
          "args": [
            "journal"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1291-1294",
          "snippet": "static inline int ext3_journal_force_commit(journal_t *journal)\n{\n\treturn journal_force_commit(journal);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline int ext3_journal_force_commit(journal_t *journal)\n{\n\treturn journal_force_commit(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nint ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_clear_journal_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2527-2557",
    "snippet": "static void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_clear_err",
          "args": [
            "journal"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1795-1806",
          "snippet": "int journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_ERROR_FS"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"Marking fs in need of \"\n\t\t\t     \"filesystem check.\""
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_decode_error",
          "args": [
            "sb",
            "j_errno",
            "nbuf"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "210-241",
          "snippet": "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_errno",
          "args": [
            "journal"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "journal_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1775-1786",
          "snippet": "int journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}"
  },
  {
    "function_name": "ext3_mark_recovery_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2503-2520",
    "snippet": "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "journal"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}"
  },
  {
    "function_name": "ext3_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2445-2495",
    "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "sbh"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"I/O error while writing \"\n\t\t\t       \"superblock\""
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "sbh"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbh"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbh",
            "\"marking dirty\""
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext3_count_free_inodes(sb)"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "646-690",
          "snippet": "unsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext3_count_free_blocks(sb)"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1777-1828",
          "snippet": "ext3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_create_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2403-2443",
    "snippet": "static int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "journal_inum"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SET_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "329-352",
          "snippet": "void ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy",
          "args": [
            "journal"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error creating journal\""
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_create",
          "args": [
            "journal"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "journal_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "990-1053",
          "snippet": "int journal_create(journal_t *journal)\n{\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint i, err;\n\n\tif (journal->j_maxlen < JFS_MIN_JOURNAL_BLOCKS) {\n\t\tprintk (KERN_ERR \"Journal length (%d blocks) too short.\\n\",\n\t\t\tjournal->j_maxlen);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal->j_inode == NULL) {\n\t\t/*\n\t\t * We don't know what block to start at!\n\t\t */\n\t\tprintk(KERN_EMERG\n\t\t       \"%s: creation of journal on external device!\\n\",\n\t\t       __func__);\n\t\tBUG();\n\t}\n\n\t/* Zero out the entire journal on disk.  We cannot afford to\n\t   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */\n\tjbd_debug(1, \"JBD: Zeroing out journal blocks...\\n\");\n\tfor (i = 0; i < journal->j_maxlen; i++) {\n\t\terr = journal_bmap(journal, i, &blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\t\tlock_buffer(bh);\n\t\tmemset (bh->b_data, 0, journal->j_blocksize);\n\t\tBUFFER_TRACE(bh, \"marking dirty\");\n\t\tmark_buffer_dirty(bh);\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\t__brelse(bh);\n\t}\n\n\tsync_blockdev(journal->j_dev);\n\tjbd_debug(1, \"JBD: journal cleared.\\n\");\n\n\t/* OK, fill in the initial static fields in the new superblock */\n\tsb = journal->j_superblock;\n\n\tsb->s_header.h_magic\t = cpu_to_be32(JFS_MAGIC_NUMBER);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\n\tsb->s_blocksize\t= cpu_to_be32(journal->j_blocksize);\n\tsb->s_maxlen\t= cpu_to_be32(journal->j_maxlen);\n\tsb->s_first\t= cpu_to_be32(1);\n\n\tjournal->j_transaction_sequence = 1;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_format_version = 2;\n\n\treturn journal_reset(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_create(journal_t *journal)\n{\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint i, err;\n\n\tif (journal->j_maxlen < JFS_MIN_JOURNAL_BLOCKS) {\n\t\tprintk (KERN_ERR \"Journal length (%d blocks) too short.\\n\",\n\t\t\tjournal->j_maxlen);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal->j_inode == NULL) {\n\t\t/*\n\t\t * We don't know what block to start at!\n\t\t */\n\t\tprintk(KERN_EMERG\n\t\t       \"%s: creation of journal on external device!\\n\",\n\t\t       __func__);\n\t\tBUG();\n\t}\n\n\t/* Zero out the entire journal on disk.  We cannot afford to\n\t   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */\n\tjbd_debug(1, \"JBD: Zeroing out journal blocks...\\n\");\n\tfor (i = 0; i < journal->j_maxlen; i++) {\n\t\terr = journal_bmap(journal, i, &blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\t\tlock_buffer(bh);\n\t\tmemset (bh->b_data, 0, journal->j_blocksize);\n\t\tBUFFER_TRACE(bh, \"marking dirty\");\n\t\tmark_buffer_dirty(bh);\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\t__brelse(bh);\n\t}\n\n\tsync_blockdev(journal->j_dev);\n\tjbd_debug(1, \"JBD: journal cleared.\\n\");\n\n\t/* OK, fill in the initial static fields in the new superblock */\n\tsb = journal->j_superblock;\n\n\tsb->s_header.h_magic\t = cpu_to_be32(JFS_MAGIC_NUMBER);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\n\tsb->s_blocksize\t= cpu_to_be32(journal->j_blocksize);\n\tsb->s_maxlen\t= cpu_to_be32(journal->j_maxlen);\n\tsb->s_first\t= cpu_to_be32(1);\n\n\tjournal->j_transaction_sequence = 1;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_format_version = 2;\n\n\treturn journal_reset(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_journal",
          "args": [
            "sb",
            "journal_inum"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2186-2225",
          "snippet": "static journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_load_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2312-2401",
    "snippet": "static int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "journal_devnum"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_journal_dev"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_clear_journal_err",
          "args": [
            "sb",
            "es"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_journal_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2527-2557",
          "snippet": "static void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy",
          "args": [
            "journal"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error loading journal\""
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_load",
          "args": [
            "journal"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "journal_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1284-1326",
          "snippet": "int journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk (KERN_WARNING\n\t\t\t\t\"JBD: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (journal_recover(journal))\n\t\tgoto recovery_error;\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_flags |= JFS_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk (KERN_WARNING \"JBD: recovery failed\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk (KERN_WARNING\n\t\t\t\t\"JBD: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (journal_recover(journal))\n\t\tgoto recovery_error;\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_flags |= JFS_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk (KERN_WARNING \"JBD: recovery failed\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_wipe",
          "args": [
            "journal",
            "!really_read_only"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1084-1102",
          "snippet": "int ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_update_format",
          "args": [
            "journal"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "journal_update_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1492-1512",
          "snippet": "int journal_update_format (journal_t *journal)\n{\n\tjournal_superblock_t *sb;\n\tint err;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tswitch (be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V2:\n\t\treturn 0;\n\tcase JFS_SUPERBLOCK_V1:\n\t\treturn journal_convert_superblock_v1(journal, sb);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_update_format (journal_t *journal)\n{\n\tjournal_superblock_t *sb;\n\tint err;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tswitch (be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V2:\n\t\treturn 0;\n\tcase JFS_SUPERBLOCK_V1:\n\t\treturn journal_convert_superblock_v1(journal, sb);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "UPDATE_JOURNAL"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"EXT3-fs: barriers not enabled\\n\""
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_dev_journal",
          "args": [
            "sb",
            "journal_dev"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_dev_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2227-2310",
          "snippet": "static journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_journal",
          "args": [
            "sb",
            "journal_inum"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2186-2225",
          "snippet": "static journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(es->s_journal_dev)"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "journal_devnum"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_get_dev_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2227-2310",
    "snippet": "static journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_blkdev_put",
          "args": [
            "bdev"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "377-380",
          "snippet": "static void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy",
          "args": [
            "journal"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_init_journal_params",
          "args": [
            "sb",
            "journal"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2164-2184",
          "snippet": "static void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\"",
            "be32_to_cpu(journal->j_superblock->s_nr_users)"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_nr_users"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_nr_users"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_dev",
          "args": [
            "bdev",
            "sb->s_bdev",
            "start",
            "len",
            "blocksize"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "798-839",
          "snippet": "journal_t * journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tint start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\njournal_t * journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tint start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "EXT3_SB(sb)->s_es->s_journal_uuid",
            "es->s_uuid",
            "16"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_magic"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "bdev",
            "sb_block",
            "blocksize"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "bdev",
            "blocksize"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_blkdev_get",
          "args": [
            "j_dev",
            "sb"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "357-372",
          "snippet": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_get_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2186-2225",
    "snippet": "static journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_init_journal_params",
          "args": [
            "sb",
            "journal"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2164-2184",
          "snippet": "static void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "journal_inode"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: could not load journal inode\""
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_inode",
          "args": [
            "journal_inode"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "849-904",
          "snippet": "journal_t * journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tint err;\n\tint n;\n\tunsigned int blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\njournal_t * journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tint err;\n\tint n;\n\tunsigned int blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "journal_inode->i_mode"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Journal inode found at %p: %Ld bytes\\n\"",
            "journal_inode",
            "journal_inode->i_size"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "journal_inode"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal_inode"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "sb",
            "journal_inum"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}"
  },
  {
    "function_name": "ext3_init_journal_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "2164-2184",
    "snippet": "static void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_ERR_ABORT"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "BARRIER"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "ext3_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1688-2157",
    "snippet": "static int ext3_fill_super (struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext3_super_block *es = NULL;\n\tstruct ext3_sb_info *sbi;\n\text3_fsblk_t block;\n\text3_fsblk_t sb_block = get_sb_block(&data, sb);\n\text3_fsblk_t logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned int journal_inum = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tint blocksize;\n\tint hblock;\n\tint db_count;\n\tint i;\n\tint needs_recovery;\n\tint ret = -EINVAL;\n\t__le32 features;\n\tint err;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tblocksize = sb_min_blocksize(sb, EXT3_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext3 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT3_MIN_BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext3 macro-instructions depend on its value\n\t */\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT3_SUPER_MAGIC)\n\t\tgoto cantfind_ext3;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT3_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT3_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT3_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (def_mount_opts & EXT3_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (def_mount_opts & EXT3_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\n\t/* enable barriers by default */\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options ((char *) data, sb, &journal_inum, &journal_devnum,\n\t\t\t    NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV &&\n\t    (EXT3_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT3_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount RDWR because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT3_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT3_MAX_BLOCK_SIZE) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\thblock = bdev_logical_block_size(sb->s_bdev);\n\tif (sb->s_blocksize != blocksize) {\n\t\t/*\n\t\t * Make sure the blocksize for the filesystem is larger\n\t\t * than the hardware sectorsize for the machine.\n\t\t */\n\t\tif (blocksize < hblock) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: fsblocksize %d too small for \"\n\t\t\t\t\"hardware sectorsize %d\", blocksize, hblock);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse (bh);\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif (!bh) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t       \"error: can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext3_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext3_max_size(sb->s_blocksize_bits);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT3_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT3_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT3_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_frag_size = EXT3_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (blocksize != sbi->s_frag_size) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t       \"error: fragsize %lu != blocksize %u (unsupported)\",\n\t\t       sbi->s_frag_size, blocksize);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_frags_per_block = 1;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT3_INODE_SIZE(sb) == 0 || EXT3_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_inodes_per_block = blocksize / EXT3_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / sizeof(struct ext3_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT3_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT3_DESC_PER_BLOCK(sb));\n\tfor (i=0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"#blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\tle32_to_cpu(es->s_blocks_count));\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: filesystem is too large to mount safely\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT3_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n\t\t\t       le32_to_cpu(es->s_first_data_block) - 1)\n\t\t\t\t       / EXT3_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = DIV_ROUND_UP(sbi->s_groups_count, EXT3_DESC_PER_BLOCK(sb));\n\tsbi->s_group_desc = kmalloc(db_count * sizeof (struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext3_check_descriptors (sb)) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/* Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler. */\n\tsbi->s_rsv_window_head.rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text3_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext3_sops;\n\tsb->s_export_op = &ext3_export_ops;\n\tsb->s_xattr = ext3_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext3_qctl_operations;\n\tsb->dq_op = &ext3_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT3_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT3_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext3_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount2;\n\t} else if (journal_inum) {\n\t\tif (ext3_create_journal(sb, es, journal_inum))\n\t\t\tgoto failed_mount2;\n\t} else {\n\t\tif (!silent)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: no journal found. \"\n\t\t\t\t\"mounting ext3 over ext2?\");\n\t\tgoto failed_mount2;\n\t}\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text3_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text3_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text3_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tret = err;\n\t\tgoto failed_mount3;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n                   capabilities: ORDERED_DATA if the journal can\n                   cope, else JOURNAL_DATA */\n\t\tif (journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, DEFAULT_DATA_MODE);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\tif (!journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journal does not support \"\n\t\t\t\t\"requested data journaling mode\");\n\t\t\tgoto failed_mount3;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * The journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext3_iget(sb, EXT3_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text3_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\n\tif (ext3_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;\n\text3_orphan_cleanup(sb, es);\n\tEXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text3_mark_recovery_complete(sb, es);\n\t\text3_msg(sb, KERN_INFO, \"recovery complete\");\n\t}\n\text3_msg(sb, KERN_INFO, \"mounted filesystem with %s data mode\",\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ? \"journal\":\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA ? \"ordered\":\n\t\t\"writeback\");\n\n\treturn 0;\n\ncantfind_ext3:\n\tif (!silent)\n\t\text3_msg(sb, KERN_INFO,\n\t\t\t\"error: can't find ext3 filesystem on dev %s.\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tjournal_destroy(sbi->s_journal);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text3_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\treturn ret;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);",
      "static const struct super_operations ext3_sops = {\n\t.alloc_inode\t= ext3_alloc_inode,\n\t.destroy_inode\t= ext3_destroy_inode,\n\t.write_inode\t= ext3_write_inode,\n\t.dirty_inode\t= ext3_dirty_inode,\n\t.drop_inode\t= ext3_drop_inode,\n\t.evict_inode\t= ext3_evict_inode,\n\t.put_super\t= ext3_put_super,\n\t.sync_fs\t= ext3_sync_fs,\n\t.freeze_fs\t= ext3_freeze,\n\t.unfreeze_fs\t= ext3_unfreeze,\n\t.statfs\t\t= ext3_statfs,\n\t.remount_fs\t= ext3_remount,\n\t.show_options\t= ext3_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext3_quota_read,\n\t.quota_write\t= ext3_quota_write,\n\t.get_dquots\t= ext3_get_dquots,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};",
      "static const struct export_operations ext3_export_ops = {\n\t.fh_to_dentry = ext3_fh_to_dentry,\n\t.fh_to_parent = ext3_fh_to_parent,\n\t.get_parent = ext3_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_blkdev_remove",
          "args": [
            "sbi"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blkdev_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "382-390",
          "snippet": "static void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_destroy",
          "args": [
            "sbi->s_journal"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"error: can't find ext3 filesystem on dev %s.\"",
            "sb->s_id"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_recovery_complete",
          "args": [
            "sb",
            "es"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_recovery_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2503-2520",
          "snippet": "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_orphan_cleanup",
          "args": [
            "sb",
            "es"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1517-1619",
          "snippet": "static void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_setup_super",
          "args": [
            "sb",
            "es",
            "sb->s_flags & MS_RDONLY"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1373-1440",
          "snippet": "static int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "root->i_mode"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "sb",
            "EXT3_ROOT_INO"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_check_available_features",
          "args": [
            "sbi->s_journal",
            "0",
            "0",
            "JFS_FEATURE_INCOMPAT_REVOKE"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "journal_check_available_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1428-1447",
          "snippet": "int journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "JOURNAL_DATA"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_dirs_counter",
            "ext3_count_dirs(sb)",
            "GFP_KERNEL"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_dirs",
          "args": [
            "sb"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "693-705",
          "snippet": "unsigned long ext3_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeinodes_counter",
            "ext3_count_free_inodes(sb)",
            "GFP_KERNEL"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "646-690",
          "snippet": "unsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeblocks_counter",
            "ext3_count_free_blocks(sb)",
            "GFP_KERNEL"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1777-1828",
          "snippet": "ext3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_create_journal",
          "args": [
            "sb",
            "es",
            "journal_inum"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_create_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2403-2443",
          "snippet": "static int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_load_journal",
          "args": [
            "sb",
            "es",
            "journal_devnum"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_load_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2312-2401",
          "snippet": "static int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NOLOAD"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->s_orphan"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sb->s_uuid",
            "es->s_uuid",
            "sizeof(es->s_uuid)"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rsv_window_add",
          "args": [
            "sb",
            "&sbi->s_rsv_window_head"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rsv_window_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "337-366",
          "snippet": "void ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_rsv_window_lock"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&sbi->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_check_descriptors",
          "args": [
            "sb"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_descriptors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1443-1497",
          "snippet": "static int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor_loc",
          "args": [
            "sb",
            "logic_sb_block",
            "i"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "descriptor_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1668-1685",
          "snippet": "static ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bgl_lock_init",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "db_count * sizeof (struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sbi->s_groups_count",
            "EXT3_DESC_PER_BLOCK(sb)"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_check_addressable",
          "args": [
            "sb->s_blocksize_bits",
            "le32_to_cpu(es->s_blocks_count)"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "generic_check_addressable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "998-1015",
          "snippet": "int generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_FLAGS_SIGNED_HASH"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_FLAGS_UNSIGNED_HASH"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT3_DESC_PER_BLOCK(sb)"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT3_ADDR_PER_BLOCK(sb)"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_state"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "sbi->s_inode_size"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_max_size",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "1626-1666",
          "snippet": "static loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_remount (struct super_block * sb, int * flags, char * data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\n\nstatic loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_SUPER_MAGIC"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "logic_sb_block"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "sb",
            "&journal_inum",
            "&journal_devnum",
            "NULL",
            "0"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "981-1371",
          "snippet": "static int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resgid)"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resuid)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "logic_sb_block"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "EXT3_MIN_BLOCK_SIZE"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct blockgroup_lock)",
            "GFP_KERNEL"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sb_block",
          "args": [
            "&data",
            "sb"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "get_sb_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "901-920",
          "snippet": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\nstatic const struct super_operations ext3_sops = {\n\t.alloc_inode\t= ext3_alloc_inode,\n\t.destroy_inode\t= ext3_destroy_inode,\n\t.write_inode\t= ext3_write_inode,\n\t.dirty_inode\t= ext3_dirty_inode,\n\t.drop_inode\t= ext3_drop_inode,\n\t.evict_inode\t= ext3_evict_inode,\n\t.put_super\t= ext3_put_super,\n\t.sync_fs\t= ext3_sync_fs,\n\t.freeze_fs\t= ext3_freeze,\n\t.unfreeze_fs\t= ext3_unfreeze,\n\t.statfs\t\t= ext3_statfs,\n\t.remount_fs\t= ext3_remount,\n\t.show_options\t= ext3_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext3_quota_read,\n\t.quota_write\t= ext3_quota_write,\n\t.get_dquots\t= ext3_get_dquots,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};\nstatic const struct export_operations ext3_export_ops = {\n\t.fh_to_dentry = ext3_fh_to_dentry,\n\t.fh_to_parent = ext3_fh_to_parent,\n\t.get_parent = ext3_get_parent,\n};\n\nstatic int ext3_fill_super (struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext3_super_block *es = NULL;\n\tstruct ext3_sb_info *sbi;\n\text3_fsblk_t block;\n\text3_fsblk_t sb_block = get_sb_block(&data, sb);\n\text3_fsblk_t logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned int journal_inum = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tint blocksize;\n\tint hblock;\n\tint db_count;\n\tint i;\n\tint needs_recovery;\n\tint ret = -EINVAL;\n\t__le32 features;\n\tint err;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tblocksize = sb_min_blocksize(sb, EXT3_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext3 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT3_MIN_BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext3 macro-instructions depend on its value\n\t */\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT3_SUPER_MAGIC)\n\t\tgoto cantfind_ext3;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT3_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT3_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT3_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (def_mount_opts & EXT3_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (def_mount_opts & EXT3_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\n\t/* enable barriers by default */\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options ((char *) data, sb, &journal_inum, &journal_devnum,\n\t\t\t    NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV &&\n\t    (EXT3_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT3_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount RDWR because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT3_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT3_MAX_BLOCK_SIZE) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\thblock = bdev_logical_block_size(sb->s_bdev);\n\tif (sb->s_blocksize != blocksize) {\n\t\t/*\n\t\t * Make sure the blocksize for the filesystem is larger\n\t\t * than the hardware sectorsize for the machine.\n\t\t */\n\t\tif (blocksize < hblock) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: fsblocksize %d too small for \"\n\t\t\t\t\"hardware sectorsize %d\", blocksize, hblock);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse (bh);\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif (!bh) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t       \"error: can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext3_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext3_max_size(sb->s_blocksize_bits);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT3_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT3_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT3_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_frag_size = EXT3_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (blocksize != sbi->s_frag_size) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t       \"error: fragsize %lu != blocksize %u (unsupported)\",\n\t\t       sbi->s_frag_size, blocksize);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_frags_per_block = 1;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT3_INODE_SIZE(sb) == 0 || EXT3_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_inodes_per_block = blocksize / EXT3_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / sizeof(struct ext3_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT3_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT3_DESC_PER_BLOCK(sb));\n\tfor (i=0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"#blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\tle32_to_cpu(es->s_blocks_count));\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: filesystem is too large to mount safely\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT3_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n\t\t\t       le32_to_cpu(es->s_first_data_block) - 1)\n\t\t\t\t       / EXT3_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = DIV_ROUND_UP(sbi->s_groups_count, EXT3_DESC_PER_BLOCK(sb));\n\tsbi->s_group_desc = kmalloc(db_count * sizeof (struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext3_check_descriptors (sb)) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/* Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler. */\n\tsbi->s_rsv_window_head.rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text3_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext3_sops;\n\tsb->s_export_op = &ext3_export_ops;\n\tsb->s_xattr = ext3_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext3_qctl_operations;\n\tsb->dq_op = &ext3_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT3_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT3_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext3_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount2;\n\t} else if (journal_inum) {\n\t\tif (ext3_create_journal(sb, es, journal_inum))\n\t\t\tgoto failed_mount2;\n\t} else {\n\t\tif (!silent)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: no journal found. \"\n\t\t\t\t\"mounting ext3 over ext2?\");\n\t\tgoto failed_mount2;\n\t}\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text3_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text3_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text3_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tret = err;\n\t\tgoto failed_mount3;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n                   capabilities: ORDERED_DATA if the journal can\n                   cope, else JOURNAL_DATA */\n\t\tif (journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, DEFAULT_DATA_MODE);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\tif (!journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journal does not support \"\n\t\t\t\t\"requested data journaling mode\");\n\t\t\tgoto failed_mount3;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * The journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext3_iget(sb, EXT3_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text3_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\n\tif (ext3_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;\n\text3_orphan_cleanup(sb, es);\n\tEXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text3_mark_recovery_complete(sb, es);\n\t\text3_msg(sb, KERN_INFO, \"recovery complete\");\n\t}\n\text3_msg(sb, KERN_INFO, \"mounted filesystem with %s data mode\",\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ? \"journal\":\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA ? \"ordered\":\n\t\t\"writeback\");\n\n\treturn 0;\n\ncantfind_ext3:\n\tif (!silent)\n\t\text3_msg(sb, KERN_INFO,\n\t\t\t\"error: can't find ext3 filesystem on dev %s.\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tjournal_destroy(sbi->s_journal);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text3_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\treturn ret;\n}"
  },
  {
    "function_name": "descriptor_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1668-1685",
    "snippet": "static ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "bg"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "bg"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_meta_bg"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}"
  },
  {
    "function_name": "ext3_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1626-1666",
    "snippet": "static loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\n\nstatic loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ext3_orphan_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1517-1619",
    "snippet": "static void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_off",
          "args": [
            "sb",
            "i"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2130-2134",
          "snippet": "int dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"%d truncate%s cleaned up\"",
            "PLURAL(nr_truncates)"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PLURAL",
          "args": [
            "nr_truncates"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLURAL",
          "args": [
            "nr_orphans"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"deleting unreferenced inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_truncate",
          "args": [
            "inode"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2493-2645",
          "snippet": "void ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nvoid ext3_truncate(struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong last_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ext3_truncate_enter(inode);\n\n\tif (!ext3_can_truncate(inode))\n\t\tgoto out_notrans;\n\n\tif (inode->i_size == 0 && ext3_should_writeback_data(inode))\n\t\text3_set_inode_state(inode, EXT3_STATE_FLUSH_ON_CLOSE);\n\n\thandle = start_transaction(inode);\n\tif (IS_ERR(handle))\n\t\tgoto out_notrans;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);\n\tn = ext3_block_to_path(inode, last_block, offsets, NULL);\n\tif (n == 0)\n\t\tgoto out_stop;\t/* error */\n\n\t/*\n\t * OK.  This truncate is going to happen.  We add the inode to the\n\t * orphan list, so that if this truncate spans multiple transactions,\n\t * and we crash, we will resume the truncate when the filesystem\n\t * recovers.  It also marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext3_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext3 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\t/*\n\t * From here we block out all ext3_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\t\t/* direct blocks */\n\t\text3_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT3_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext3_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text3_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\text3_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text3_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT3_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT3_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_IND_BLOCK:\n\t\tnr = i_data[EXT3_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT3_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_DIND_BLOCK:\n\t\tnr = i_data[EXT3_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT3_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT3_TIND_BLOCK:\n\t\t;\n\t}\n\n\text3_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\text3_mark_inode_dirty(handle, inode);\n\n\t/*\n\t * In a multi-transaction truncate, we only make the final transaction\n\t * synchronous\n\t */\n\tif (IS_SYNC(inode))\n\t\thandle->h_sync = 1;\nout_stop:\n\t/*\n\t * If this was a simple ftruncate(), and the file will remain alive\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext3_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(handle, inode);\n\n\text3_journal_stop(handle);\n\ttrace_ext3_truncate_exit(inode);\n\treturn;\nout_notrans:\n\t/*\n\t * Delete the inode from orphan list so that it doesn't stay there\n\t * forever and trigger assertion on umount.\n\t */\n\tif (inode->i_nlink)\n\t\text3_orphan_del(NULL, inode);\n\ttrace_ext3_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"truncating inode %lu to %Ld bytes\\n\"",
            "inode->i_ino",
            "inode->i_size"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&EXT3_I(inode)->i_orphan",
            "&EXT3_SB(sb)->s_orphan"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_orphan_get",
          "args": [
            "sb",
            "le32_to_cpu(es->s_last_orphan)"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_orphan_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "570-644",
          "snippet": "struct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);\n\tunsigned long block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext3_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext3_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text3_warning(sb, __func__,\n\t\t     \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_NOTICE \"ext3_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext3_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_NOTICE \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_NOTICE \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_NOTICE \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_NOTICE \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_NOTICE \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);\n\tunsigned long block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext3_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext3_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text3_warning(sb, __func__,\n\t\t     \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_NOTICE \"ext3_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext3_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_NOTICE \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_NOTICE \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_NOTICE \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_NOTICE \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_NOTICE \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_last_orphan"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_quota_on_mount",
          "args": [
            "sb",
            "i"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2964-2968",
          "snippet": "static int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Skipping orphan recovery on fs with errors.\\n\""
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\""
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"no orphan inodes to clean up\\n\""
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}"
  },
  {
    "function_name": "ext3_check_descriptors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1443-1497",
    "snippet": "static int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext3_count_free_inodes(sb)"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "646-690",
          "snippet": "unsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext3_count_free_blocks(sb)"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1777-1828",
          "snippet": "ext3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"ext3_check_descriptors\"",
            "\"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\"",
            "i",
            "(unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table)"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdp->bg_inode_table"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "i"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"Checking group descriptors\""
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}"
  },
  {
    "function_name": "ext3_setup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "1373-1440",
    "snippet": "static int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_init_fs",
          "args": [
            "sb"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"using internal journal\""
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "EXT3_SB(sb)->s_journal->j_dev",
            "b"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "329-352",
          "snippet": "void ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&es->s_mnt_count",
            "1"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_DFL_MAX_MNT_COUNT"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_max_mnt_count"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT3_VALID_FS"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_checkinterval"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "981-1371",
    "snippet": "static int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);",
      "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\""
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "GRPQUOTA"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "USRQUOTA"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "BARRIER"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "BARRIER"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "BARRIER"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "GRPQUOTA"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "USRQUOTA"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "QUOTA"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_qf_name",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "clear_qf_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "963-978",
          "snippet": "static int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_qf_name",
          "args": [
            "sb",
            "GRPQUOTA",
            "&args[0]"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "set_qf_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "923-961",
          "snippet": "static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "DATA_ERR_ABORT"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "DATA_FLAGS"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_mode_string",
          "args": [
            "data_opt"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "data_mode_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "594-605",
          "snippet": "static char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "journal_inode->i_rdev"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "journal_inode->i_mode"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "journal_path",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "RESERVATION"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "POSIX_ACL"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "XATTR_USER"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "CHECK"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_PANIC"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_RO"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_PANIC"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_CONT"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_RO"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_CONT"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "GRPID"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "MINIX_DF"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *journal_path;\n\tstruct inode *journal_inode;\n\tstruct path path;\n\tint error;\n\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_path:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_path = match_strdup(&args[0]);\n\t\t\tif (!journal_path) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\t\"journal device string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\t\tif (error) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\t\"journal device path: error %d\", error);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tjournal_inode = path.dentry->d_inode;\n\t\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\t\"is not a block device\", journal_path);\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(journal_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "clear_qf_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "963-978",
    "snippet": "static int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[qtype]"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "set_qf_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "923-961",
    "snippet": "static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "QUOTA"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qname"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"quotafile must be on filesystem root\""
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "qname",
            "'/'"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTYPE2NAME",
          "args": [
            "qtype"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qname"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sbi->s_qf_names[qtype]",
            "qname"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}"
  },
  {
    "function_name": "get_sb_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "901-920",
    "snippet": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: invalid sb specification: %s\"",
            "(char *) *data"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "options",
            "&options",
            "0"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "options",
            "\"sb=\"",
            "3"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}"
  },
  {
    "function_name": "ext3_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "773-776",
    "snippet": "static struct dquot **ext3_get_dquots(struct inode *inode)\n{\n\treturn EXT3_I(inode)->i_dquot;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct dquot **ext3_get_dquots(struct inode *inode)\n{\n\treturn EXT3_I(inode)->i_dquot;\n}"
  },
  {
    "function_name": "bdev_try_to_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "743-755",
    "snippet": "static int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_sync_fs(struct super_block *sb, int wait);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_try_to_free_buffers",
          "args": [
            "journal",
            "page",
            "wait & ~__GFP_WAIT"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "journal_try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1726-1761",
          "snippet": "int journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageChecked(page)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "ext3_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "730-735",
    "snippet": "static struct dentry *ext3_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext3_nfs_get_inode"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic struct dentry *ext3_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext3_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "723-728",
    "snippet": "static struct dentry *ext3_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext3_nfs_get_inode"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic struct dentry *ext3_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext3_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "694-721",
    "snippet": "static struct inode *ext3_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT3_FIRST_INO(sb) && ino != EXT3_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext3_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic struct inode *ext3_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT3_FIRST_INO(sb) && ino != EXT3_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext3_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ext3_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "612-691",
    "snippet": "static int ext3_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT3_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT3_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT3_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT3_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT3_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT3_ERRORS_PANIC ||\n\t\t    def_errors == EXT3_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT3_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT3_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\tif (sbi->s_commit_interval) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\n\t/*\n\t * Always display barrier state so it's clear what the status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tseq_printf(seq, \",data=%s\", data_mode_string(test_opt(sb, DATA_FLAGS)));\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NOLOAD))\n\t\tseq_puts(seq, \",norecovery\");\n\n\text3_show_quota_options(seq, sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_show_quota_options",
          "args": [
            "seq",
            "sb"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_show_quota_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "558-592",
          "snippet": "static inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",norecovery\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NOLOAD"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_ERR_ABORT"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",data=%s\"",
            "data_mode_string(test_opt(sb, DATA_FLAGS))"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_mode_string",
          "args": [
            "test_opt(sb, DATA_FLAGS)"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "data_mode_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "594-605",
          "snippet": "static char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "BARRIER"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "RESERVATION"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "XATTR_USER"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "XATTR_USER"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NO_UID32"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_errors"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resgid"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "make_kgid(&init_user_ns, EXT3_DEF_RESGID)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "EXT3_DEF_RESGID"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resuid"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "make_kuid(&init_user_ns, EXT3_DEF_RESUID)"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "EXT3_DEF_RESUID"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "MINIX_DF"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_default_mount_opts"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT3_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT3_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT3_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT3_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT3_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT3_ERRORS_PANIC ||\n\t\t    def_errors == EXT3_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT3_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT3_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\tif (sbi->s_commit_interval) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\n\t/*\n\t * Always display barrier state so it's clear what the status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tseq_printf(seq, \",data=%s\", data_mode_string(test_opt(sb, DATA_FLAGS)));\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NOLOAD))\n\t\tseq_puts(seq, \",norecovery\");\n\n\text3_show_quota_options(seq, sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "data_mode_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "594-605",
    "snippet": "static char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}"
  },
  {
    "function_name": "ext3_show_quota_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "558-592",
    "snippet": "static inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",grpquota\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",grpjquota=%s\"",
            "sbi->s_qf_names[GRPQUOTA]"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "548-556",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext3_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext3_inode_cachep"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "536-546",
    "snippet": "static int __init init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext3_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ext3_inode_cache\"",
            "sizeof(struct ext3_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "524-534",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct ext3_inode_info *ei = (struct ext3_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->xattr_sem"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct ext3_inode_info *ei = (struct ext3_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ext3_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "511-522",
    "snippet": "static void ext3_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT3_I(inode)->i_orphan))) {\n\t\tprintk(\"EXT3 Inode %p: orphan list check failed!\\n\",\n\t\t\tEXT3_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT3_I(inode), sizeof(struct ext3_inode_info),\n\t\t\t\tfalse);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext3_i_callback);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ext3_i_callback"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_INFO",
            "\"\"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "EXT3_I(inode)",
            "sizeof(struct ext3_inode_info)",
            "false"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"EXT3 Inode %p: orphan list check failed!\\n\"",
            "EXT3_I(inode)"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&(EXT3_I(inode)->i_orphan)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT3_I(inode)->i_orphan))) {\n\t\tprintk(\"EXT3 Inode %p: orphan list check failed!\\n\",\n\t\t\tEXT3_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT3_I(inode), sizeof(struct ext3_inode_info),\n\t\t\t\tfalse);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext3_i_callback);\n}"
  },
  {
    "function_name": "ext3_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "505-509",
    "snippet": "static void ext3_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext3_inode_cachep, EXT3_I(inode));\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext3_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext3_inode_cachep",
            "EXT3_I(inode)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic void ext3_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext3_inode_cachep, EXT3_I(inode));\n}"
  },
  {
    "function_name": "ext3_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "497-503",
    "snippet": "static int ext3_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext3_drop_inode(inode, drop);\n\treturn drop;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_drop_inode",
          "args": [
            "inode",
            "drop"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext3_drop_inode(inode, drop);\n\treturn drop;\n}"
  },
  {
    "function_name": "ext3_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "479-495",
    "snippet": "static struct inode *ext3_alloc_inode(struct super_block *sb)\n{\n\tstruct ext3_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext3_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n\tatomic_set(&ei->i_datasync_tid, 0);\n\tatomic_set(&ei->i_sync_tid, 0);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);",
      "static struct kmem_cache *ext3_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ei->i_dquot",
            "0",
            "sizeof(ei->i_dquot)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_sync_tid",
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_datasync_tid",
            "0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext3_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\nstatic struct kmem_cache *ext3_inode_cachep;\n\nstatic struct inode *ext3_alloc_inode(struct super_block *sb)\n{\n\tstruct ext3_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext3_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n\tatomic_set(&ei->i_datasync_tid, 0);\n\tatomic_set(&ei->i_sync_tid, 0);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "ext3_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "415-472",
    "snippet": "static void ext3_put_super (struct super_block * sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint i, err;\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text3_xattr_put_super(sb);\n\terr = journal_destroy(sbi->s_journal);\n\tsbi->s_journal = NULL;\n\tif (err < 0)\n\t\text3_abort(sb, __func__, \"Couldn't clean up the journal\");\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"marking dirty\");\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text3_blkdev_remove(sbi);\n\t}\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tmutex_destroy(&sbi->s_orphan_lock);\n\tmutex_destroy(&sbi->s_resize_lock);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_blkdev_remove",
          "args": [
            "sbi"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blkdev_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "382-390",
          "snippet": "static void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "sbi->journal_bdev"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "77-91",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "sbi->journal_bdev"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "list_empty(&sbi->s_orphan)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sbi->s_orphan"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_orphan_list",
          "args": [
            "sb",
            "sbi"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "dump_orphan_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "397-413",
          "snippet": "static void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"marking dirty\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_abort",
          "args": [
            "sb",
            "__func__",
            "\"Couldn't clean up the journal\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "275-310",
          "snippet": "void ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy",
          "args": [
            "sbi->s_journal"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_put_super",
          "args": [
            "sb"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.h",
          "lines": "107-110",
          "snippet": "static inline void\next3_xattr_put_super(struct super_block *sb)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline void\next3_xattr_put_super(struct super_block *sb)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "sb",
            "-1",
            "DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_put_super (struct super_block * sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint i, err;\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text3_xattr_put_super(sb);\n\terr = journal_destroy(sbi->s_journal);\n\tsbi->s_journal = NULL;\n\tif (err < 0)\n\t\text3_abort(sb, __func__, \"Couldn't clean up the journal\");\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"marking dirty\");\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT3_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text3_blkdev_remove(sbi);\n\t}\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tmutex_destroy(&sbi->s_orphan_lock);\n\tmutex_destroy(&sbi->s_resize_lock);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "dump_orphan_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "397-413",
    "snippet": "static void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "inode",
            "inode->i_mode",
            "inode->i_nlink",
            "NEXT_ORPHAN(inode)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan_list_entry",
          "args": [
            "l"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "orphan_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "392-395",
          "snippet": "static inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "l",
            "&sbi->s_orphan"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_last_orphan"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}"
  },
  {
    "function_name": "orphan_list_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "392-395",
    "snippet": "static inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "structext3_inode_info",
            "i_orphan"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}"
  },
  {
    "function_name": "ext3_blkdev_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "382-390",
    "snippet": "static void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_blkdev_put",
          "args": [
            "bdev"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "377-380",
          "snippet": "static void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
  },
  {
    "function_name": "ext3_blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "377-380",
    "snippet": "static void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic void ext3_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
  },
  {
    "function_name": "ext3_blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "357-372",
    "snippet": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: failed to open journal device %s: %ld\"",
            "__bdevname(dev, b)",
            "PTR_ERR(bdev)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bdevname",
          "args": [
            "dev",
            "b"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "dev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL",
            "sb"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_update_dynamic_rev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "329-352",
    "snippet": "void ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_DYNAMIC_REV"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_GOOD_OLD_INODE_SIZE"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_GOOD_OLD_FIRST_INO"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\"",
            "EXT3_DYNAMIC_REV"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_rev_level"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
  },
  {
    "function_name": "ext3_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "312-327",
    "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "ext3_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "275-310",
    "snippet": "void ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_abort",
          "args": [
            "EXT3_SB(sb)->s_journal",
            "-EIO"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1759-1762",
          "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "EXT3_SB(sb)->s_mount_opt",
            "ABORT"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"error: remounting filesystem read-only\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"EXT3-fs: panic from previous error\\n\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}"
  },
  {
    "function_name": "__ext3_std_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "246-263",
    "snippet": "void __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_handle_error",
          "args": [
            "sb"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "158-189",
          "snippet": "static void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"error in %s: %s\"",
            "function",
            "errstr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_decode_error",
          "args": [
            "sb",
            "errno",
            "nbuf"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "210-241",
          "snippet": "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}"
  },
  {
    "function_name": "ext3_decode_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "210-241",
    "snippet": "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nbuf",
            "16",
            "\"error %d\"",
            "-errno"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
  },
  {
    "function_name": "ext3_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "191-208",
    "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_handle_error",
          "args": [
            "sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "158-189",
          "snippet": "static void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
  },
  {
    "function_name": "ext3_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "158-189",
    "snippet": "static void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
      "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
      "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"EXT3-fs (%s): panic forced after error\\n\"",
            "sb->s_id"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_commit_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2445-2495",
          "snippet": "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"error: remounting filesystem read-only\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "127-141",
          "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_abort",
          "args": [
            "journal",
            "-EIO"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1759-1762",
          "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "EXT3_SB(sb)->s_mount_opt",
            "ABORT"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_ERROR_FS"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_state will be visible\n\t\t * before ->s_flags update.\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
  },
  {
    "function_name": "ext3_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "127-141",
    "snippet": "void ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sEXT3-fs (%s): %pV\\n\"",
            "prefix",
            "sb->s_id",
            "&vaf"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "ext3_journal_abort_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "106-125",
    "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_abort_handle",
          "args": [
            "handle"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\"",
            "caller",
            "errstr",
            "err_fn"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"abort\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_decode_error",
          "args": [
            "NULL",
            "err",
            "nbuf"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "210-241",
          "snippet": "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
  },
  {
    "function_name": "__ext3_journal_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "89-104",
    "snippet": "int __ext3_journal_stop(const char *where, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext3_std_error(sb, where, err);\n\treturn err;\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext3_std_error",
          "args": [
            "sb",
            "where",
            "err"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__ext3_std_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "246-263",
          "snippet": "void __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_stop",
          "args": [
            "handle"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "journal_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1362-1483",
          "snippet": "int journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nint __ext3_journal_stop(const char *where, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext3_std_error(sb, where, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_journal_start_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
    "lines": "69-87",
    "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
    "includes": [
      "#include \"namei.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/statfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_unfreeze(struct super_block *sb);",
      "static int ext3_freeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_start",
          "args": [
            "journal",
            "nblocks"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_abort",
          "args": [
            "sb",
            "__func__",
            "\"Detected aborted journal\""
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "275-310",
          "snippet": "void ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t/*\n\t * Make sure updated value of ->s_mount_state will be visible\n\t * before ->s_flags update.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= MS_RDONLY;\n\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
  }
]