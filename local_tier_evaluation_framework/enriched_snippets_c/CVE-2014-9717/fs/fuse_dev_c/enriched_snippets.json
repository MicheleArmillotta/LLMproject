[
  {
    "function_name": "fuse_dev_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2275-2279",
    "snippet": "void fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_req_cachep;",
      "static struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fuse_req_cachep"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&fuse_miscdevice"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\nstatic struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};\n\nvoid fuse_dev_cleanup(void)\n{\n\tmisc_deregister(&fuse_miscdevice);\n\tkmem_cache_destroy(fuse_req_cachep);\n}"
  },
  {
    "function_name": "fuse_dev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2254-2273",
    "snippet": "int __init fuse_dev_init(void)\n{\n\tint err = -ENOMEM;\n\tfuse_req_cachep = kmem_cache_create(\"fuse_request\",\n\t\t\t\t\t    sizeof(struct fuse_req),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!fuse_req_cachep)\n\t\tgoto out;\n\n\terr = misc_register(&fuse_miscdevice);\n\tif (err)\n\t\tgoto out_cache_clean;\n\n\treturn 0;\n\n out_cache_clean:\n\tkmem_cache_destroy(fuse_req_cachep);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_req_cachep;",
      "static struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fuse_req_cachep"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&fuse_miscdevice"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"fuse_request\"",
            "sizeof(struct fuse_req)",
            "0",
            "0",
            "NULL"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\nstatic struct miscdevice fuse_miscdevice = {\n\t.minor = FUSE_MINOR,\n\t.name  = \"fuse\",\n\t.fops = &fuse_dev_operations,\n};\n\nint __init fuse_dev_init(void)\n{\n\tint err = -ENOMEM;\n\tfuse_req_cachep = kmem_cache_create(\"fuse_request\",\n\t\t\t\t\t    sizeof(struct fuse_req),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!fuse_req_cachep)\n\t\tgoto out;\n\n\terr = misc_register(&fuse_miscdevice);\n\tif (err)\n\t\tgoto out_cache_clean;\n\n\treturn 0;\n\n out_cache_clean:\n\tkmem_cache_destroy(fuse_req_cachep);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_dev_fasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2222-2230",
    "snippet": "static int fuse_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\t/* No locking - fasync_helper does its own locking */\n\treturn fasync_helper(fd, file, on, &fc->fasync);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fasync_helper",
          "args": [
            "fd",
            "file",
            "on",
            "&fc->fasync"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "686-691",
          "snippet": "int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "file"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\t/* No locking - fasync_helper does its own locking */\n\treturn fasync_helper(fd, file, on, &fc->fasync);\n}"
  },
  {
    "function_name": "fuse_dev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2203-2219",
    "snippet": "int fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (fc) {\n\t\tspin_lock(&fc->lock);\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_conn_put(fc);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_polls",
          "args": [
            "fc"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "end_polls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2151-2164",
          "snippet": "static void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_queued_requests",
          "args": [
            "fc"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "end_queued_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2139-2149",
          "snippet": "static void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_set_initialized",
          "args": [
            "fc"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "134-139",
          "snippet": "void fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "file"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nint fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (fc) {\n\t\tspin_lock(&fc->lock);\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_conn_put(fc);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_abort_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2185-2200",
    "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fc->fasync",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&fc->waitq"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_polls",
          "args": [
            "fc"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "end_polls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2151-2164",
          "snippet": "static void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_queued_requests",
          "args": [
            "fc"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "end_queued_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2139-2149",
          "snippet": "static void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_io_requests",
          "args": [
            "fc"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "end_io_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2113-2137",
          "snippet": "static void end_io_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(&fc->io)) {\n\t\tstruct fuse_req *req =\n\t\t\tlist_entry(fc->io.next, struct fuse_req, list);\n\t\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\n\t\treq->aborted = 1;\n\t\treq->out.h.error = -ECONNABORTED;\n\t\treq->state = FUSE_REQ_FINISHED;\n\t\tlist_del_init(&req->list);\n\t\twake_up(&req->waitq);\n\t\tif (end) {\n\t\t\treq->end = NULL;\n\t\t\t__fuse_get_request(req);\n\t\t\tspin_unlock(&fc->lock);\n\t\t\twait_event(req->waitq, !req->locked);\n\t\t\tend(fc, req);\n\t\t\tfuse_put_request(fc, req);\n\t\t\tspin_lock(&fc->lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_io_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(&fc->io)) {\n\t\tstruct fuse_req *req =\n\t\t\tlist_entry(fc->io.next, struct fuse_req, list);\n\t\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\n\t\treq->aborted = 1;\n\t\treq->out.h.error = -ECONNABORTED;\n\t\treq->state = FUSE_REQ_FINISHED;\n\t\tlist_del_init(&req->list);\n\t\twake_up(&req->waitq);\n\t\tif (end) {\n\t\t\treq->end = NULL;\n\t\t\t__fuse_get_request(req);\n\t\t\tspin_unlock(&fc->lock);\n\t\t\twait_event(req->waitq, !req->locked);\n\t\t\tend(fc, req);\n\t\t\tfuse_put_request(fc, req);\n\t\t\tspin_lock(&fc->lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_set_initialized",
          "args": [
            "fc"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "134-139",
          "snippet": "void fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "end_polls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2151-2164",
    "snippet": "static void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_all",
          "args": [
            "&ff->poll_wait"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structfuse_file",
            "polled_node"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&fc->polled_files"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_polls(struct fuse_conn *fc)\n{\n\tstruct rb_node *p;\n\n\tp = rb_first(&fc->polled_files);\n\n\twhile (p) {\n\t\tstruct fuse_file *ff;\n\t\tff = rb_entry(p, struct fuse_file, polled_node);\n\t\twake_up_interruptible_all(&ff->poll_wait);\n\n\t\tp = rb_next(p);\n\t}\n}"
  },
  {
    "function_name": "end_queued_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2139-2149",
    "snippet": "static void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dequeue_forget(fc, 1, NULL)"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_forget",
          "args": [
            "fc",
            "1",
            "NULL"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1147-1167",
          "snippet": "static struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "forget_pending",
          "args": [
            "fc"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "forget_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1077-1080",
          "snippet": "static int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_requests",
          "args": [
            "fc",
            "&fc->processing"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "end_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2089-2100",
          "snippet": "static void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_bg_queue",
          "args": [
            "fc"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "flush_bg_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "355-367",
          "snippet": "static void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_queued_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tfc->max_background = UINT_MAX;\n\tflush_bg_queue(fc);\n\tend_requests(fc, &fc->pending);\n\tend_requests(fc, &fc->processing);\n\twhile (forget_pending(fc))\n\t\tkfree(dequeue_forget(fc, 1, NULL));\n}"
  },
  {
    "function_name": "end_io_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2113-2137",
    "snippet": "static void end_io_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(&fc->io)) {\n\t\tstruct fuse_req *req =\n\t\t\tlist_entry(fc->io.next, struct fuse_req, list);\n\t\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\n\t\treq->aborted = 1;\n\t\treq->out.h.error = -ECONNABORTED;\n\t\treq->state = FUSE_REQ_FINISHED;\n\t\tlist_del_init(&req->list);\n\t\twake_up(&req->waitq);\n\t\tif (end) {\n\t\t\treq->end = NULL;\n\t\t\t__fuse_get_request(req);\n\t\t\tspin_unlock(&fc->lock);\n\t\t\twait_event(req->waitq, !req->locked);\n\t\t\tend(fc, req);\n\t\t\tfuse_put_request(fc, req);\n\t\t\tspin_lock(&fc->lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end",
          "args": [
            "fc",
            "req"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "end_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2089-2100",
          "snippet": "static void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "req->waitq",
            "!req->locked"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_get_request",
          "args": [
            "req"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "115-118",
          "snippet": "void __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&req->waitq"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->list"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fc->io.next",
            "structfuse_req",
            "list"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fc->io"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_io_requests(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(&fc->io)) {\n\t\tstruct fuse_req *req =\n\t\t\tlist_entry(fc->io.next, struct fuse_req, list);\n\t\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\n\t\treq->aborted = 1;\n\t\treq->out.h.error = -ECONNABORTED;\n\t\treq->state = FUSE_REQ_FINISHED;\n\t\tlist_del_init(&req->list);\n\t\twake_up(&req->waitq);\n\t\tif (end) {\n\t\t\treq->end = NULL;\n\t\t\t__fuse_get_request(req);\n\t\t\tspin_unlock(&fc->lock);\n\t\t\twait_event(req->waitq, !req->locked);\n\t\t\tend(fc, req);\n\t\t\tfuse_put_request(fc, req);\n\t\t\tspin_lock(&fc->lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "end_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2089-2100",
    "snippet": "static void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "request_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "379-411",
          "snippet": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structfuse_req",
            "list"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
  },
  {
    "function_name": "fuse_dev_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "2065-2082",
    "snippet": "static unsigned fuse_dev_poll(struct file *file, poll_table *wait)\n{\n\tunsigned mask = POLLOUT | POLLWRNORM;\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn POLLERR;\n\n\tpoll_wait(file, &fc->waitq, wait);\n\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\tmask = POLLERR;\n\telse if (request_pending(fc))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tspin_unlock(&fc->lock);\n\n\treturn mask;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_pending",
          "args": [
            "fc"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "request_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1082-1086",
          "snippet": "static int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&fc->waitq",
            "wait"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "file"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic unsigned fuse_dev_poll(struct file *file, poll_table *wait)\n{\n\tunsigned mask = POLLOUT | POLLWRNORM;\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn POLLERR;\n\n\tpoll_wait(file, &fc->waitq, wait);\n\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\tmask = POLLERR;\n\telse if (request_pending(fc))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tspin_unlock(&fc->lock);\n\n\treturn mask;\n}"
  },
  {
    "function_name": "fuse_dev_splice_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1987-2063",
    "snippet": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc;\n\tsize_t rem;\n\tssize_t ret;\n\n\tfc = fuse_get_conn(out);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tibuf->ops->get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\n\tfuse_copy_init(&cs, fc, 0, NULL, nbuf);\n\tcs.pipebufs = bufs;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fc, &cs, len);\n\n\tfor (idx = 0; idx < nbuf; idx++) {\n\t\tstruct pipe_buffer *buf = &bufs[idx];\n\t\tbuf->ops->release(pipe, buf);\n\t}\nout:\n\tkfree(bufs);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bufs"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_dev_do_write",
          "args": [
            "fc",
            "&cs",
            "len"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1881-1972",
          "snippet": "static ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_init",
          "args": [
            "&cs",
            "fc",
            "0",
            "NULL",
            "nbuf"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "727-736",
          "snippet": "static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ibuf->ops->get",
          "args": [
            "pipe",
            "ibuf"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pipe->nrbufs"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nbuf >= pipe->buffers"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pipe->buffers * sizeof(struct pipe_buffer)",
            "GFP_KERNEL"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "out"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc;\n\tsize_t rem;\n\tssize_t ret;\n\n\tfc = fuse_get_conn(out);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tibuf->ops->get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\n\tfuse_copy_init(&cs, fc, 0, NULL, nbuf);\n\tcs.pipebufs = bufs;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fc, &cs, len);\n\n\tfor (idx = 0; idx < nbuf; idx++) {\n\t\tstruct pipe_buffer *buf = &bufs[idx];\n\t\tbuf->ops->release(pipe, buf);\n\t}\nout:\n\tkfree(bufs);\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_dev_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1974-1985",
    "snippet": "static ssize_t fuse_dev_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t      unsigned long nr_segs, loff_t pos)\n{\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc = fuse_get_conn(iocb->ki_filp);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tfuse_copy_init(&cs, fc, 0, iov, nr_segs);\n\n\treturn fuse_dev_do_write(fc, &cs, iov_length(iov, nr_segs));\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dev_do_write",
          "args": [
            "fc",
            "&cs",
            "iov_length(iov, nr_segs)"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1881-1972",
          "snippet": "static ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "iov",
            "nr_segs"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_init",
          "args": [
            "&cs",
            "fc",
            "0",
            "iov",
            "nr_segs"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "727-736",
          "snippet": "static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t      unsigned long nr_segs, loff_t pos)\n{\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc = fuse_get_conn(iocb->ki_filp);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tfuse_copy_init(&cs, fc, 0, iov, nr_segs);\n\n\treturn fuse_dev_do_write(fc, &cs, iov_length(iov, nr_segs));\n}"
  },
  {
    "function_name": "fuse_dev_do_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1881-1972",
    "snippet": "static ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "request_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "379-411",
          "snippet": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_out_args",
          "args": [
            "cs",
            "&req->out",
            "nbytes"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "copy_out_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1851-1872",
          "snippet": "static int copy_out_args(struct fuse_copy_state *cs, struct fuse_out *out,\n\t\t\t unsigned nbytes)\n{\n\tunsigned reqsize = sizeof(struct fuse_out_header);\n\n\tif (out->h.error)\n\t\treturn nbytes != reqsize ? -EINVAL : 0;\n\n\treqsize += len_args(out->numargs, out->args);\n\n\tif (reqsize < nbytes || (reqsize > nbytes && !out->argvar))\n\t\treturn -EINVAL;\n\telse if (reqsize > nbytes) {\n\t\tstruct fuse_arg *lastarg = &out->args[out->numargs-1];\n\t\tunsigned diffsize = reqsize - nbytes;\n\t\tif (diffsize > lastarg->size)\n\t\t\treturn -EINVAL;\n\t\tlastarg->size -= diffsize;\n\t}\n\treturn fuse_copy_args(cs, out->numargs, out->argpages, out->args,\n\t\t\t      out->page_zeroing);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int copy_out_args(struct fuse_copy_state *cs, struct fuse_out *out,\n\t\t\t unsigned nbytes)\n{\n\tunsigned reqsize = sizeof(struct fuse_out_header);\n\n\tif (out->h.error)\n\t\treturn nbytes != reqsize ? -EINVAL : 0;\n\n\treqsize += len_args(out->numargs, out->args);\n\n\tif (reqsize < nbytes || (reqsize > nbytes && !out->argvar))\n\t\treturn -EINVAL;\n\telse if (reqsize > nbytes) {\n\t\tstruct fuse_arg *lastarg = &out->args[out->numargs-1];\n\t\tunsigned diffsize = reqsize - nbytes;\n\t\tif (diffsize > lastarg->size)\n\t\t\treturn -EINVAL;\n\t\tlastarg->size -= diffsize;\n\t}\n\treturn fuse_copy_args(cs, out->numargs, out->argpages, out->args,\n\t\t\t      out->page_zeroing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&req->list",
            "&fc->io"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_interrupt",
          "args": [
            "fc",
            "req"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "426-431",
          "snippet": "static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_find",
          "args": [
            "fc",
            "oh.unique"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "request_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1840-1849",
          "snippet": "static struct fuse_req *request_find(struct fuse_conn *fc, u64 unique)\n{\n\tstruct fuse_req *req;\n\n\tlist_for_each_entry(req, &fc->processing, list) {\n\t\tif (req->in.h.unique == unique || req->intr_unique == unique)\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *request_find(struct fuse_conn *fc, u64 unique)\n{\n\tstruct fuse_req *req;\n\n\tlist_for_each_entry(req, &fc->processing, list) {\n\t\tif (req->in.h.unique == unique || req->intr_unique == unique)\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify",
          "args": [
            "fc",
            "oh.error",
            "nbytes - sizeof(oh)",
            "cs"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1808-1837",
          "snippet": "static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,\n\t\t       unsigned int size, struct fuse_copy_state *cs)\n{\n\t/* Don't try to move pages (yet) */\n\tcs->move_pages = 0;\n\n\tswitch (code) {\n\tcase FUSE_NOTIFY_POLL:\n\t\treturn fuse_notify_poll(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_INODE:\n\t\treturn fuse_notify_inval_inode(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_ENTRY:\n\t\treturn fuse_notify_inval_entry(fc, size, cs);\n\n\tcase FUSE_NOTIFY_STORE:\n\t\treturn fuse_notify_store(fc, size, cs);\n\n\tcase FUSE_NOTIFY_RETRIEVE:\n\t\treturn fuse_notify_retrieve(fc, size, cs);\n\n\tcase FUSE_NOTIFY_DELETE:\n\t\treturn fuse_notify_delete(fc, size, cs);\n\n\tdefault:\n\t\tfuse_copy_finish(cs);\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,\n\t\t       unsigned int size, struct fuse_copy_state *cs)\n{\n\t/* Don't try to move pages (yet) */\n\tcs->move_pages = 0;\n\n\tswitch (code) {\n\tcase FUSE_NOTIFY_POLL:\n\t\treturn fuse_notify_poll(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_INODE:\n\t\treturn fuse_notify_inval_inode(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_ENTRY:\n\t\treturn fuse_notify_inval_entry(fc, size, cs);\n\n\tcase FUSE_NOTIFY_STORE:\n\t\treturn fuse_notify_store(fc, size, cs);\n\n\tcase FUSE_NOTIFY_RETRIEVE:\n\t\treturn fuse_notify_retrieve(fc, size, cs);\n\n\tcase FUSE_NOTIFY_DELETE:\n\t\treturn fuse_notify_delete(fc, size, cs);\n\n\tdefault:\n\t\tfuse_copy_finish(cs);\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&oh",
            "sizeof(oh)"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_write(struct fuse_conn *fc,\n\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_out_header oh;\n\n\tif (nbytes < sizeof(struct fuse_out_header))\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &oh, sizeof(oh));\n\tif (err)\n\t\tgoto err_finish;\n\n\terr = -EINVAL;\n\tif (oh.len != nbytes)\n\t\tgoto err_finish;\n\n\t/*\n\t * Zero oh.unique indicates unsolicited notification message\n\t * and error contains notification code.\n\t */\n\tif (!oh.unique) {\n\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);\n\t\treturn err ? err : nbytes;\n\t}\n\n\terr = -EINVAL;\n\tif (oh.error <= -1000 || oh.error > 0)\n\t\tgoto err_finish;\n\n\tspin_lock(&fc->lock);\n\terr = -ENOENT;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\n\treq = request_find(fc, oh.unique);\n\tif (!req)\n\t\tgoto err_unlock;\n\n\tif (req->aborted) {\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\tspin_lock(&fc->lock);\n\t\trequest_end(fc, req);\n\t\treturn -ENOENT;\n\t}\n\t/* Is it an interrupt reply? */\n\tif (req->intr_unique == oh.unique) {\n\t\terr = -EINVAL;\n\t\tif (nbytes != sizeof(struct fuse_out_header))\n\t\t\tgoto err_unlock;\n\n\t\tif (oh.error == -ENOSYS)\n\t\t\tfc->no_interrupt = 1;\n\t\telse if (oh.error == -EAGAIN)\n\t\t\tqueue_interrupt(fc, req);\n\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_copy_finish(cs);\n\t\treturn nbytes;\n\t}\n\n\treq->state = FUSE_REQ_WRITING;\n\tlist_move(&req->list, &fc->io);\n\treq->out.h = oh;\n\treq->locked = 1;\n\tcs->req = req;\n\tif (!req->out.page_replace)\n\t\tcs->move_pages = 0;\n\tspin_unlock(&fc->lock);\n\n\terr = copy_out_args(cs, &req->out, nbytes);\n\tfuse_copy_finish(cs);\n\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (!err) {\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t} else if (!req->aborted)\n\t\treq->out.h.error = -EIO;\n\trequest_end(fc, req);\n\n\treturn err ? err : nbytes;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n err_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "copy_out_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1851-1872",
    "snippet": "static int copy_out_args(struct fuse_copy_state *cs, struct fuse_out *out,\n\t\t\t unsigned nbytes)\n{\n\tunsigned reqsize = sizeof(struct fuse_out_header);\n\n\tif (out->h.error)\n\t\treturn nbytes != reqsize ? -EINVAL : 0;\n\n\treqsize += len_args(out->numargs, out->args);\n\n\tif (reqsize < nbytes || (reqsize > nbytes && !out->argvar))\n\t\treturn -EINVAL;\n\telse if (reqsize > nbytes) {\n\t\tstruct fuse_arg *lastarg = &out->args[out->numargs-1];\n\t\tunsigned diffsize = reqsize - nbytes;\n\t\tif (diffsize > lastarg->size)\n\t\t\treturn -EINVAL;\n\t\tlastarg->size -= diffsize;\n\t}\n\treturn fuse_copy_args(cs, out->numargs, out->argpages, out->args,\n\t\t\t      out->page_zeroing);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_args",
          "args": [
            "cs",
            "out->numargs",
            "out->argpages",
            "out->args",
            "out->page_zeroing"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1060-1075",
          "snippet": "static int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "len_args",
          "args": [
            "out->numargs",
            "out->args"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "len_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "302-311",
          "snippet": "static unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int copy_out_args(struct fuse_copy_state *cs, struct fuse_out *out,\n\t\t\t unsigned nbytes)\n{\n\tunsigned reqsize = sizeof(struct fuse_out_header);\n\n\tif (out->h.error)\n\t\treturn nbytes != reqsize ? -EINVAL : 0;\n\n\treqsize += len_args(out->numargs, out->args);\n\n\tif (reqsize < nbytes || (reqsize > nbytes && !out->argvar))\n\t\treturn -EINVAL;\n\telse if (reqsize > nbytes) {\n\t\tstruct fuse_arg *lastarg = &out->args[out->numargs-1];\n\t\tunsigned diffsize = reqsize - nbytes;\n\t\tif (diffsize > lastarg->size)\n\t\t\treturn -EINVAL;\n\t\tlastarg->size -= diffsize;\n\t}\n\treturn fuse_copy_args(cs, out->numargs, out->argpages, out->args,\n\t\t\t      out->page_zeroing);\n}"
  },
  {
    "function_name": "request_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1840-1849",
    "snippet": "static struct fuse_req *request_find(struct fuse_conn *fc, u64 unique)\n{\n\tstruct fuse_req *req;\n\n\tlist_for_each_entry(req, &fc->processing, list) {\n\t\tif (req->in.h.unique == unique || req->intr_unique == unique)\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "req",
            "&fc->processing",
            "list"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *request_find(struct fuse_conn *fc, u64 unique)\n{\n\tstruct fuse_req *req;\n\n\tlist_for_each_entry(req, &fc->processing, list) {\n\t\tif (req->in.h.unique == unique || req->intr_unique == unique)\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fuse_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1808-1837",
    "snippet": "static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,\n\t\t       unsigned int size, struct fuse_copy_state *cs)\n{\n\t/* Don't try to move pages (yet) */\n\tcs->move_pages = 0;\n\n\tswitch (code) {\n\tcase FUSE_NOTIFY_POLL:\n\t\treturn fuse_notify_poll(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_INODE:\n\t\treturn fuse_notify_inval_inode(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_ENTRY:\n\t\treturn fuse_notify_inval_entry(fc, size, cs);\n\n\tcase FUSE_NOTIFY_STORE:\n\t\treturn fuse_notify_store(fc, size, cs);\n\n\tcase FUSE_NOTIFY_RETRIEVE:\n\t\treturn fuse_notify_retrieve(fc, size, cs);\n\n\tcase FUSE_NOTIFY_DELETE:\n\t\treturn fuse_notify_delete(fc, size, cs);\n\n\tdefault:\n\t\tfuse_copy_finish(cs);\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_delete",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1559-1609",
          "snippet": "static int fuse_notify_delete(struct fuse_conn *fc, unsigned int size,\n\t\t\t      struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_delete_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent,\n\t\t\t\t\t       outarg.child, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_delete(struct fuse_conn *fc, unsigned int size,\n\t\t\t      struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_delete_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent,\n\t\t\t\t\t       outarg.child, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_retrieve",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_retrieve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1771-1806",
          "snippet": "static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,\n\t\t\t\tstruct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_retrieve_out outarg;\n\tstruct inode *inode;\n\tint err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg))\n\t\tgoto copy_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto copy_finish;\n\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\tu64 nodeid = outarg.nodeid;\n\n\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\terr = fuse_retrieve(fc, inode, &outarg);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\tup_read(&fc->killsb);\n\n\treturn err;\n\ncopy_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,\n\t\t\t\tstruct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_retrieve_out outarg;\n\tstruct inode *inode;\n\tint err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg))\n\t\tgoto copy_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto copy_finish;\n\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\tu64 nodeid = outarg.nodeid;\n\n\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\terr = fuse_retrieve(fc, inode, &outarg);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\tup_read(&fc->killsb);\n\n\treturn err;\n\ncopy_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_store",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1611-1695",
          "snippet": "static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,\n\t\t\t     struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_store_out outarg;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tu64 nodeid;\n\tint err;\n\tpgoff_t index;\n\tunsigned int offset;\n\tunsigned int num;\n\tloff_t file_size;\n\tloff_t end;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto out_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto out_finish;\n\n\terr = -EINVAL;\n\tif (size - sizeof(outarg) != outarg.size)\n\t\tgoto out_finish;\n\n\tnodeid = outarg.nodeid;\n\n\tdown_read(&fc->killsb);\n\n\terr = -ENOENT;\n\tif (!fc->sb)\n\t\tgoto out_up_killsb;\n\n\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\tgoto out_up_killsb;\n\n\tmapping = inode->i_mapping;\n\tindex = outarg.offset >> PAGE_CACHE_SHIFT;\n\toffset = outarg.offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\tend = outarg.offset + outarg.size;\n\tif (end > file_size) {\n\t\tfile_size = end;\n\t\tfuse_write_update_size(inode, file_size);\n\t}\n\n\tnum = outarg.size;\n\twhile (num) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\terr = -ENOMEM;\n\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t   mapping_gfp_mask(mapping));\n\t\tif (!page)\n\t\t\tgoto out_iput;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\terr = fuse_copy_page(cs, &page, offset, this_num, 0);\n\t\tif (!err && offset == 0 &&\n\t\t    (this_num == PAGE_CACHE_SIZE || file_size == end))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (err)\n\t\t\tgoto out_iput;\n\n\t\tnum -= this_num;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\n\terr = 0;\n\nout_iput:\n\tiput(inode);\nout_up_killsb:\n\tup_read(&fc->killsb);\nout_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_store(struct fuse_conn *fc, unsigned int size,\n\t\t\t     struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_store_out outarg;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tu64 nodeid;\n\tint err;\n\tpgoff_t index;\n\tunsigned int offset;\n\tunsigned int num;\n\tloff_t file_size;\n\tloff_t end;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto out_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto out_finish;\n\n\terr = -EINVAL;\n\tif (size - sizeof(outarg) != outarg.size)\n\t\tgoto out_finish;\n\n\tnodeid = outarg.nodeid;\n\n\tdown_read(&fc->killsb);\n\n\terr = -ENOENT;\n\tif (!fc->sb)\n\t\tgoto out_up_killsb;\n\n\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\tgoto out_up_killsb;\n\n\tmapping = inode->i_mapping;\n\tindex = outarg.offset >> PAGE_CACHE_SHIFT;\n\toffset = outarg.offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\tend = outarg.offset + outarg.size;\n\tif (end > file_size) {\n\t\tfile_size = end;\n\t\tfuse_write_update_size(inode, file_size);\n\t}\n\n\tnum = outarg.size;\n\twhile (num) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\terr = -ENOMEM;\n\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t   mapping_gfp_mask(mapping));\n\t\tif (!page)\n\t\t\tgoto out_iput;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\terr = fuse_copy_page(cs, &page, offset, this_num, 0);\n\t\tif (!err && offset == 0 &&\n\t\t    (this_num == PAGE_CACHE_SIZE || file_size == end))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (err)\n\t\t\tgoto out_iput;\n\n\t\tnum -= this_num;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\n\terr = 0;\n\nout_iput:\n\tiput(inode);\nout_up_killsb:\n\tup_read(&fc->killsb);\nout_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_inval_entry",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_inval_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1508-1557",
          "snippet": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, 0, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, 0, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_inval_inode",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1480-1506",
          "snippet": "static int fuse_notify_inval_inode(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_inode_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\terr = fuse_reverse_inval_inode(fc->sb, outarg.ino,\n\t\t\t\t\t       outarg.off, outarg.len);\n\t}\n\tup_read(&fc->killsb);\n\treturn err;\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_inval_inode(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_inode_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\terr = fuse_reverse_inval_inode(fc->sb, outarg.ino,\n\t\t\t\t\t       outarg.off, outarg.len);\n\t}\n\tup_read(&fc->killsb);\n\treturn err;\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_poll",
          "args": [
            "fc",
            "size",
            "cs"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1459-1478",
          "snippet": "static int fuse_notify_poll(struct fuse_conn *fc, unsigned int size,\n\t\t\t    struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_poll_wakeup_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\tfuse_copy_finish(cs);\n\treturn fuse_notify_poll_wakeup(fc, &outarg);\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_poll(struct fuse_conn *fc, unsigned int size,\n\t\t\t    struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_poll_wakeup_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\tfuse_copy_finish(cs);\n\treturn fuse_notify_poll_wakeup(fc, &outarg);\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,\n\t\t       unsigned int size, struct fuse_copy_state *cs)\n{\n\t/* Don't try to move pages (yet) */\n\tcs->move_pages = 0;\n\n\tswitch (code) {\n\tcase FUSE_NOTIFY_POLL:\n\t\treturn fuse_notify_poll(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_INODE:\n\t\treturn fuse_notify_inval_inode(fc, size, cs);\n\n\tcase FUSE_NOTIFY_INVAL_ENTRY:\n\t\treturn fuse_notify_inval_entry(fc, size, cs);\n\n\tcase FUSE_NOTIFY_STORE:\n\t\treturn fuse_notify_store(fc, size, cs);\n\n\tcase FUSE_NOTIFY_RETRIEVE:\n\t\treturn fuse_notify_retrieve(fc, size, cs);\n\n\tcase FUSE_NOTIFY_DELETE:\n\t\treturn fuse_notify_delete(fc, size, cs);\n\n\tdefault:\n\t\tfuse_copy_finish(cs);\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "fuse_notify_retrieve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1771-1806",
    "snippet": "static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,\n\t\t\t\tstruct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_retrieve_out outarg;\n\tstruct inode *inode;\n\tint err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg))\n\t\tgoto copy_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto copy_finish;\n\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\tu64 nodeid = outarg.nodeid;\n\n\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\terr = fuse_retrieve(fc, inode, &outarg);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\tup_read(&fc->killsb);\n\n\treturn err;\n\ncopy_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_retrieve",
          "args": [
            "fc",
            "inode",
            "&outarg"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_retrieve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1702-1769",
          "snippet": "static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,\n\t\t\t struct fuse_notify_retrieve_out *outarg)\n{\n\tint err;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct fuse_req *req;\n\tpgoff_t index;\n\tloff_t file_size;\n\tunsigned int num;\n\tunsigned int offset;\n\tsize_t total_len = 0;\n\tint num_pages;\n\n\toffset = outarg->offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\n\tnum = outarg->size;\n\tif (outarg->offset > file_size)\n\t\tnum = 0;\n\telse if (outarg->offset + num > file_size)\n\t\tnum = file_size - outarg->offset;\n\n\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnum_pages = min(num_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.h.opcode = FUSE_NOTIFY_REPLY;\n\treq->in.h.nodeid = outarg->nodeid;\n\treq->in.numargs = 2;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\treq->end = fuse_retrieve_end;\n\n\tindex = outarg->offset >> PAGE_CACHE_SHIFT;\n\n\twhile (num && req->num_pages < num_pages) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = this_num;\n\t\treq->num_pages++;\n\n\t\toffset = 0;\n\t\tnum -= this_num;\n\t\ttotal_len += this_num;\n\t\tindex++;\n\t}\n\treq->misc.retrieve_in.offset = outarg->offset;\n\treq->misc.retrieve_in.size = total_len;\n\treq->in.args[0].size = sizeof(req->misc.retrieve_in);\n\treq->in.args[0].value = &req->misc.retrieve_in;\n\treq->in.args[1].size = total_len;\n\n\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);\n\tif (err)\n\t\tfuse_retrieve_end(fc, req);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,\n\t\t\t struct fuse_notify_retrieve_out *outarg)\n{\n\tint err;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct fuse_req *req;\n\tpgoff_t index;\n\tloff_t file_size;\n\tunsigned int num;\n\tunsigned int offset;\n\tsize_t total_len = 0;\n\tint num_pages;\n\n\toffset = outarg->offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\n\tnum = outarg->size;\n\tif (outarg->offset > file_size)\n\t\tnum = 0;\n\telse if (outarg->offset + num > file_size)\n\t\tnum = file_size - outarg->offset;\n\n\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnum_pages = min(num_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.h.opcode = FUSE_NOTIFY_REPLY;\n\treq->in.h.nodeid = outarg->nodeid;\n\treq->in.numargs = 2;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\treq->end = fuse_retrieve_end;\n\n\tindex = outarg->offset >> PAGE_CACHE_SHIFT;\n\n\twhile (num && req->num_pages < num_pages) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = this_num;\n\t\treq->num_pages++;\n\n\t\toffset = 0;\n\t\tnum -= this_num;\n\t\ttotal_len += this_num;\n\t\tindex++;\n\t}\n\treq->misc.retrieve_in.offset = outarg->offset;\n\treq->misc.retrieve_in.size = total_len;\n\treq->in.args[0].size = sizeof(req->misc.retrieve_in);\n\treq->in.args[0].value = &req->misc.retrieve_in;\n\treq->in.args[1].size = total_len;\n\n\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);\n\tif (err)\n\t\tfuse_retrieve_end(fc, req);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "fc->sb",
            "nodeid",
            "fuse_inode_eq",
            "&nodeid"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&outarg",
            "sizeof(outarg)"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,\n\t\t\t\tstruct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_retrieve_out outarg;\n\tstruct inode *inode;\n\tint err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg))\n\t\tgoto copy_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto copy_finish;\n\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\tu64 nodeid = outarg.nodeid;\n\n\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\terr = fuse_retrieve(fc, inode, &outarg);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\tup_read(&fc->killsb);\n\n\treturn err;\n\ncopy_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_retrieve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1702-1769",
    "snippet": "static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,\n\t\t\t struct fuse_notify_retrieve_out *outarg)\n{\n\tint err;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct fuse_req *req;\n\tpgoff_t index;\n\tloff_t file_size;\n\tunsigned int num;\n\tunsigned int offset;\n\tsize_t total_len = 0;\n\tint num_pages;\n\n\toffset = outarg->offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\n\tnum = outarg->size;\n\tif (outarg->offset > file_size)\n\t\tnum = 0;\n\telse if (outarg->offset + num > file_size)\n\t\tnum = file_size - outarg->offset;\n\n\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnum_pages = min(num_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.h.opcode = FUSE_NOTIFY_REPLY;\n\treq->in.h.nodeid = outarg->nodeid;\n\treq->in.numargs = 2;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\treq->end = fuse_retrieve_end;\n\n\tindex = outarg->offset >> PAGE_CACHE_SHIFT;\n\n\twhile (num && req->num_pages < num_pages) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = this_num;\n\t\treq->num_pages++;\n\n\t\toffset = 0;\n\t\tnum -= this_num;\n\t\ttotal_len += this_num;\n\t\tindex++;\n\t}\n\treq->misc.retrieve_in.offset = outarg->offset;\n\treq->misc.retrieve_in.size = total_len;\n\treq->in.args[0].size = sizeof(req->misc.retrieve_in);\n\treq->in.args[0].value = &req->misc.retrieve_in;\n\treq->in.args[1].size = total_len;\n\n\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);\n\tif (err)\n\t\tfuse_retrieve_end(fc, req);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_retrieve_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_retrieve_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1697-1700",
          "snippet": "static void fuse_retrieve_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\trelease_pages(req->pages, req->num_pages, false);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_retrieve_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\trelease_pages(req->pages, req->num_pages, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send_notify_reply",
          "args": [
            "fc",
            "req",
            "outarg->notify_unique"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_notify_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "625-640",
          "snippet": "static int fuse_request_send_notify_reply(struct fuse_conn *fc,\n\t\t\t\t\t  struct fuse_req *req, u64 unique)\n{\n\tint err = -ENODEV;\n\n\treq->isreply = 0;\n\treq->in.h.unique = unique;\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tqueue_request(fc, req);\n\t\terr = 0;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_request_send_notify_reply(struct fuse_conn *fc,\n\t\t\t\t\t  struct fuse_req *req, u64 unique)\n{\n\tint err = -ENODEV;\n\n\treq->isreply = 0;\n\treq->in.h.unique = unique;\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tqueue_request(fc, req);\n\t\terr = 0;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "num",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "num_pages"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "num_pages",
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,\n\t\t\t struct fuse_notify_retrieve_out *outarg)\n{\n\tint err;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct fuse_req *req;\n\tpgoff_t index;\n\tloff_t file_size;\n\tunsigned int num;\n\tunsigned int offset;\n\tsize_t total_len = 0;\n\tint num_pages;\n\n\toffset = outarg->offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\n\tnum = outarg->size;\n\tif (outarg->offset > file_size)\n\t\tnum = 0;\n\telse if (outarg->offset + num > file_size)\n\t\tnum = file_size - outarg->offset;\n\n\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnum_pages = min(num_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.h.opcode = FUSE_NOTIFY_REPLY;\n\treq->in.h.nodeid = outarg->nodeid;\n\treq->in.numargs = 2;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\treq->end = fuse_retrieve_end;\n\n\tindex = outarg->offset >> PAGE_CACHE_SHIFT;\n\n\twhile (num && req->num_pages < num_pages) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = this_num;\n\t\treq->num_pages++;\n\n\t\toffset = 0;\n\t\tnum -= this_num;\n\t\ttotal_len += this_num;\n\t\tindex++;\n\t}\n\treq->misc.retrieve_in.offset = outarg->offset;\n\treq->misc.retrieve_in.size = total_len;\n\treq->in.args[0].size = sizeof(req->misc.retrieve_in);\n\treq->in.args[0].value = &req->misc.retrieve_in;\n\treq->in.args[1].size = total_len;\n\n\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);\n\tif (err)\n\t\tfuse_retrieve_end(fc, req);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_retrieve_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1697-1700",
    "snippet": "static void fuse_retrieve_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\trelease_pages(req->pages, req->num_pages, false);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "req->pages",
            "req->num_pages",
            "false"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_retrieve_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\trelease_pages(req->pages, req->num_pages, false);\n}"
  },
  {
    "function_name": "fuse_notify_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1611-1695",
    "snippet": "static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,\n\t\t\t     struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_store_out outarg;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tu64 nodeid;\n\tint err;\n\tpgoff_t index;\n\tunsigned int offset;\n\tunsigned int num;\n\tloff_t file_size;\n\tloff_t end;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto out_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto out_finish;\n\n\terr = -EINVAL;\n\tif (size - sizeof(outarg) != outarg.size)\n\t\tgoto out_finish;\n\n\tnodeid = outarg.nodeid;\n\n\tdown_read(&fc->killsb);\n\n\terr = -ENOENT;\n\tif (!fc->sb)\n\t\tgoto out_up_killsb;\n\n\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\tgoto out_up_killsb;\n\n\tmapping = inode->i_mapping;\n\tindex = outarg.offset >> PAGE_CACHE_SHIFT;\n\toffset = outarg.offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\tend = outarg.offset + outarg.size;\n\tif (end > file_size) {\n\t\tfile_size = end;\n\t\tfuse_write_update_size(inode, file_size);\n\t}\n\n\tnum = outarg.size;\n\twhile (num) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\terr = -ENOMEM;\n\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t   mapping_gfp_mask(mapping));\n\t\tif (!page)\n\t\t\tgoto out_iput;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\terr = fuse_copy_page(cs, &page, offset, this_num, 0);\n\t\tif (!err && offset == 0 &&\n\t\t    (this_num == PAGE_CACHE_SIZE || file_size == end))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (err)\n\t\t\tgoto out_iput;\n\n\t\tnum -= this_num;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\n\terr = 0;\n\nout_iput:\n\tiput(inode);\nout_up_killsb:\n\tup_read(&fc->killsb);\nout_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_page",
          "args": [
            "cs",
            "&page",
            "offset",
            "this_num",
            "0"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "986-1021",
          "snippet": "static int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "num",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "file_size"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "fc->sb",
            "nodeid",
            "fuse_inode_eq",
            "&nodeid"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&outarg",
            "sizeof(outarg)"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_store(struct fuse_conn *fc, unsigned int size,\n\t\t\t     struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_store_out outarg;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tu64 nodeid;\n\tint err;\n\tpgoff_t index;\n\tunsigned int offset;\n\tunsigned int num;\n\tloff_t file_size;\n\tloff_t end;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto out_finish;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto out_finish;\n\n\terr = -EINVAL;\n\tif (size - sizeof(outarg) != outarg.size)\n\t\tgoto out_finish;\n\n\tnodeid = outarg.nodeid;\n\n\tdown_read(&fc->killsb);\n\n\terr = -ENOENT;\n\tif (!fc->sb)\n\t\tgoto out_up_killsb;\n\n\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\tgoto out_up_killsb;\n\n\tmapping = inode->i_mapping;\n\tindex = outarg.offset >> PAGE_CACHE_SHIFT;\n\toffset = outarg.offset & ~PAGE_CACHE_MASK;\n\tfile_size = i_size_read(inode);\n\tend = outarg.offset + outarg.size;\n\tif (end > file_size) {\n\t\tfile_size = end;\n\t\tfuse_write_update_size(inode, file_size);\n\t}\n\n\tnum = outarg.size;\n\twhile (num) {\n\t\tstruct page *page;\n\t\tunsigned int this_num;\n\n\t\terr = -ENOMEM;\n\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t   mapping_gfp_mask(mapping));\n\t\tif (!page)\n\t\t\tgoto out_iput;\n\n\t\tthis_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);\n\t\terr = fuse_copy_page(cs, &page, offset, this_num, 0);\n\t\tif (!err && offset == 0 &&\n\t\t    (this_num == PAGE_CACHE_SIZE || file_size == end))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tif (err)\n\t\t\tgoto out_iput;\n\n\t\tnum -= this_num;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\n\terr = 0;\n\nout_iput:\n\tiput(inode);\nout_up_killsb:\n\tup_read(&fc->killsb);\nout_finish:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_notify_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1559-1609",
    "snippet": "static int fuse_notify_delete(struct fuse_conn *fc, unsigned int size,\n\t\t\t      struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_delete_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent,\n\t\t\t\t\t       outarg.child, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_reverse_inval_entry",
          "args": [
            "fc->sb",
            "outarg.parent",
            "outarg.child",
            "&name"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reverse_inval_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "935-998",
          "snippet": "int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "name.name",
            "name.len"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "buf",
            "outarg.namelen + 1"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "FUSE_NAME_MAX + 1",
            "GFP_KERNEL"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_delete(struct fuse_conn *fc, unsigned int size,\n\t\t\t      struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_delete_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent,\n\t\t\t\t\t       outarg.child, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_notify_inval_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1508-1557",
    "snippet": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, 0, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_reverse_inval_entry",
          "args": [
            "fc->sb",
            "outarg.parent",
            "0",
            "&name"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reverse_inval_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "935-998",
          "snippet": "int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "name.name",
            "name.len"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "buf",
            "outarg.namelen + 1"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "FUSE_NAME_MAX + 1",
            "GFP_KERNEL"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, 0, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_notify_inval_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1480-1506",
    "snippet": "static int fuse_notify_inval_inode(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_inode_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\terr = fuse_reverse_inval_inode(fc->sb, outarg.ino,\n\t\t\t\t\t       outarg.off, outarg.len);\n\t}\n\tup_read(&fc->killsb);\n\treturn err;\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_reverse_inval_inode",
          "args": [
            "fc->sb",
            "outarg.ino",
            "outarg.off",
            "outarg.len"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reverse_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "329-352",
          "snippet": "int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tpgoff_t pg_start;\n\tpgoff_t pg_end;\n\n\tinode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tfuse_invalidate_attr(inode);\n\tif (offset >= 0) {\n\t\tpg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tif (len <= 0)\n\t\t\tpg_end = -1;\n\t\telse\n\t\t\tpg_end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pg_start, pg_end);\n\t}\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,\n\t\t\t     loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tpgoff_t pg_start;\n\tpgoff_t pg_end;\n\n\tinode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tfuse_invalidate_attr(inode);\n\tif (offset >= 0) {\n\t\tpg_start = offset >> PAGE_CACHE_SHIFT;\n\t\tif (len <= 0)\n\t\t\tpg_end = -1;\n\t\telse\n\t\t\tpg_end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pg_start, pg_end);\n\t}\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fc->killsb"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&outarg",
            "sizeof(outarg)"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_inval_inode(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_inode_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb) {\n\t\terr = fuse_reverse_inval_inode(fc->sb, outarg.ino,\n\t\t\t\t\t       outarg.off, outarg.len);\n\t}\n\tup_read(&fc->killsb);\n\treturn err;\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_notify_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1459-1478",
    "snippet": "static int fuse_notify_poll(struct fuse_conn *fc, unsigned int size,\n\t\t\t    struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_poll_wakeup_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\tfuse_copy_finish(cs);\n\treturn fuse_notify_poll_wakeup(fc, &outarg);\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_notify_poll_wakeup",
          "args": [
            "fc",
            "&outarg"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_notify_poll_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2761-2779",
          "snippet": "int fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&outarg",
            "sizeof(outarg)"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_notify_poll(struct fuse_conn *fc, unsigned int size,\n\t\t\t    struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_poll_wakeup_out outarg;\n\tint err = -EINVAL;\n\n\tif (size != sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\tfuse_copy_finish(cs);\n\treturn fuse_notify_poll_wakeup(fc, &outarg);\n\nerr:\n\tfuse_copy_finish(cs);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_dev_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1381-1457",
    "snippet": "static ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tint ret;\n\tint page_nr = 0;\n\tint do_wakeup = 0;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc = fuse_get_conn(in);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tfuse_copy_init(&cs, fc, 1, NULL, 0);\n\tcs.pipebufs = bufs;\n\tcs.pipe = pipe;\n\tret = fuse_dev_do_read(fc, in, &cs, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tif (!ret)\n\t\t\tret = -EPIPE;\n\t\tgoto out_unlock;\n\t}\n\n\tif (pipe->nrbufs + cs.nr_segs > pipe->buffers) {\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (page_nr < cs.nr_segs) {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\tbuf->page = bufs[page_nr].page;\n\t\tbuf->offset = bufs[page_nr].offset;\n\t\tbuf->len = bufs[page_nr].len;\n\t\t/*\n\t\t * Need to be careful about this.  Having buf->ops in module\n\t\t * code can Oops if the buffer persists after module unload.\n\t\t */\n\t\tbuf->ops = &nosteal_pipe_buf_ops;\n\n\t\tpipe->nrbufs++;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (pipe->files)\n\t\t\tdo_wakeup = 1;\n\t}\n\nout_unlock:\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&pipe->wait))\n\t\t\twake_up_interruptible(&pipe->wait);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\nout:\n\tfor (; page_nr < cs.nr_segs; page_nr++)\n\t\tpage_cache_release(bufs[page_nr].page);\n\n\tkfree(bufs);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bufs"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bufs[page_nr].page"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_dev_do_read",
          "args": [
            "fc",
            "in",
            "&cs",
            "len"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1270-1354",
          "snippet": "static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_init",
          "args": [
            "&cs",
            "fc",
            "1",
            "NULL",
            "0"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "727-736",
          "snippet": "static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pipe->buffers * sizeof(struct pipe_buffer)",
            "GFP_KERNEL"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "in"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tint ret;\n\tint page_nr = 0;\n\tint do_wakeup = 0;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_conn *fc = fuse_get_conn(in);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tfuse_copy_init(&cs, fc, 1, NULL, 0);\n\tcs.pipebufs = bufs;\n\tcs.pipe = pipe;\n\tret = fuse_dev_do_read(fc, in, &cs, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tif (!ret)\n\t\t\tret = -EPIPE;\n\t\tgoto out_unlock;\n\t}\n\n\tif (pipe->nrbufs + cs.nr_segs > pipe->buffers) {\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (page_nr < cs.nr_segs) {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\tbuf->page = bufs[page_nr].page;\n\t\tbuf->offset = bufs[page_nr].offset;\n\t\tbuf->len = bufs[page_nr].len;\n\t\t/*\n\t\t * Need to be careful about this.  Having buf->ops in module\n\t\t * code can Oops if the buffer persists after module unload.\n\t\t */\n\t\tbuf->ops = &nosteal_pipe_buf_ops;\n\n\t\tpipe->nrbufs++;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (pipe->files)\n\t\t\tdo_wakeup = 1;\n\t}\n\nout_unlock:\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&pipe->wait))\n\t\t\twake_up_interruptible(&pipe->wait);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\nout:\n\tfor (; page_nr < cs.nr_segs; page_nr++)\n\t\tpage_cache_release(bufs[page_nr].page);\n\n\tkfree(bufs);\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_dev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1367-1379",
    "snippet": "static ssize_t fuse_dev_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t      unsigned long nr_segs, loff_t pos)\n{\n\tstruct fuse_copy_state cs;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tfuse_copy_init(&cs, fc, 1, iov, nr_segs);\n\n\treturn fuse_dev_do_read(fc, file, &cs, iov_length(iov, nr_segs));\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dev_do_read",
          "args": [
            "fc",
            "file",
            "&cs",
            "iov_length(iov, nr_segs)"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1270-1354",
          "snippet": "static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "iov",
            "nr_segs"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_init",
          "args": [
            "&cs",
            "fc",
            "1",
            "iov",
            "nr_segs"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "727-736",
          "snippet": "static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_conn",
          "args": [
            "file"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "29-36",
          "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t      unsigned long nr_segs, loff_t pos)\n{\n\tstruct fuse_copy_state cs;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tfuse_copy_init(&cs, fc, 1, iov, nr_segs);\n\n\treturn fuse_dev_do_read(fc, file, &cs, iov_length(iov, nr_segs));\n}"
  },
  {
    "function_name": "fuse_dev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1356-1365",
    "snippet": "static int fuse_dev_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * The fuse device's file's private_data is used to hold\n\t * the fuse_conn(ection) when it is mounted, and is used to\n\t * keep track of whether the file has been mounted already.\n\t */\n\tfile->private_data = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dev_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * The fuse device's file's private_data is used to hold\n\t * the fuse_conn(ection) when it is mounted, and is used to\n\t * keep track of whether the file has been mounted already.\n\t */\n\tfile->private_data = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_dev_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1270-1354",
    "snippet": "static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_interrupt",
          "args": [
            "fc",
            "req"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "426-431",
          "snippet": "static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&req->list",
            "&fc->processing"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "request_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "379-411",
          "snippet": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_args",
          "args": [
            "cs",
            "in->numargs",
            "in->argpages",
            "(struct fuse_arg *) in->args",
            "0"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1060-1075",
          "snippet": "static int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&in->h",
            "sizeof(in->h)"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&req->list",
            "&fc->io"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fc->pending.next",
            "structfuse_req",
            "list"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_read_forget",
          "args": [
            "fc",
            "cs",
            "nbytes"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1251-1259",
          "snippet": "static int fuse_read_forget(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t    size_t nbytes)\n__releases(fc->lock)\n{\n\tif (fc->minor < 16 || fc->forget_list_head.next->next == NULL)\n\t\treturn fuse_read_single_forget(fc, cs, nbytes);\n\telse\n\t\treturn fuse_read_batch_forget(fc, cs, nbytes);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_forget(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t    size_t nbytes)\n__releases(fc->lock)\n{\n\tif (fc->minor < 16 || fc->forget_list_head.next->next == NULL)\n\t\treturn fuse_read_single_forget(fc, cs, nbytes);\n\telse\n\t\treturn fuse_read_batch_forget(fc, cs, nbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fc->pending"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "forget_pending",
          "args": [
            "fc"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "forget_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1077-1080",
          "snippet": "static int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_read_interrupt",
          "args": [
            "fc",
            "cs",
            "nbytes",
            "req"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1117-1145",
          "snippet": "static int fuse_read_interrupt(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t       size_t nbytes, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tstruct fuse_in_header ih;\n\tstruct fuse_interrupt_in arg;\n\tunsigned reqsize = sizeof(ih) + sizeof(arg);\n\tint err;\n\n\tlist_del_init(&req->intr_entry);\n\treq->intr_unique = fuse_get_unique(fc);\n\tmemset(&ih, 0, sizeof(ih));\n\tmemset(&arg, 0, sizeof(arg));\n\tih.len = reqsize;\n\tih.opcode = FUSE_INTERRUPT;\n\tih.unique = req->intr_unique;\n\targ.unique = req->in.h.unique;\n\n\tspin_unlock(&fc->lock);\n\tif (nbytes < reqsize)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\treturn err ? err : reqsize;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_interrupt(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t       size_t nbytes, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tstruct fuse_in_header ih;\n\tstruct fuse_interrupt_in arg;\n\tunsigned reqsize = sizeof(ih) + sizeof(arg);\n\tint err;\n\n\tlist_del_init(&req->intr_entry);\n\treq->intr_unique = fuse_get_unique(fc);\n\tmemset(&ih, 0, sizeof(ih));\n\tmemset(&arg, 0, sizeof(arg));\n\tih.len = reqsize;\n\tih.opcode = FUSE_INTERRUPT;\n\tih.unique = req->intr_unique;\n\targ.unique = req->in.h.unique;\n\n\tspin_unlock(&fc->lock);\n\tif (nbytes < reqsize)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\treturn err ? err : reqsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fc->interrupts.next",
            "structfuse_req",
            "intr_entry"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_pending",
          "args": [
            "fc"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "request_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1082-1086",
          "snippet": "static int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_wait",
          "args": [
            "fc"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "request_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1089-1107",
          "snippet": "static void request_wait(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(&fc->waitq, &wait);\n\twhile (fc->connected && !request_pending(fc)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tspin_unlock(&fc->lock);\n\t\tschedule();\n\t\tspin_lock(&fc->lock);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&fc->waitq, &wait);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_wait(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(&fc->waitq, &wait);\n\twhile (fc->connected && !request_pending(fc)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tspin_unlock(&fc->lock);\n\t\tschedule();\n\t\tspin_lock(&fc->lock);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&fc->waitq, &wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n\t\t\t\tstruct fuse_copy_state *cs, size_t nbytes)\n{\n\tint err;\n\tstruct fuse_req *req;\n\tstruct fuse_in *in;\n\tunsigned reqsize;\n\n restart:\n\tspin_lock(&fc->lock);\n\terr = -EAGAIN;\n\tif ((file->f_flags & O_NONBLOCK) && fc->connected &&\n\t    !request_pending(fc))\n\t\tgoto err_unlock;\n\n\trequest_wait(fc);\n\terr = -ENODEV;\n\tif (!fc->connected)\n\t\tgoto err_unlock;\n\terr = -ERESTARTSYS;\n\tif (!request_pending(fc))\n\t\tgoto err_unlock;\n\n\tif (!list_empty(&fc->interrupts)) {\n\t\treq = list_entry(fc->interrupts.next, struct fuse_req,\n\t\t\t\t intr_entry);\n\t\treturn fuse_read_interrupt(fc, cs, nbytes, req);\n\t}\n\n\tif (forget_pending(fc)) {\n\t\tif (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n\t\t\treturn fuse_read_forget(fc, cs, nbytes);\n\n\t\tif (fc->forget_batch <= -8)\n\t\t\tfc->forget_batch = 16;\n\t}\n\n\treq = list_entry(fc->pending.next, struct fuse_req, list);\n\treq->state = FUSE_REQ_READING;\n\tlist_move(&req->list, &fc->io);\n\n\tin = &req->in;\n\treqsize = in->h.len;\n\t/* If request is too large, reply with an error and restart the read */\n\tif (nbytes < reqsize) {\n\t\treq->out.h.error = -EIO;\n\t\t/* SETXATTR is special, since it may contain too large data */\n\t\tif (in->h.opcode == FUSE_SETXATTR)\n\t\t\treq->out.h.error = -E2BIG;\n\t\trequest_end(fc, req);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&fc->lock);\n\tcs->req = req;\n\terr = fuse_copy_one(cs, &in->h, sizeof(in->h));\n\tif (!err)\n\t\terr = fuse_copy_args(cs, in->numargs, in->argpages,\n\t\t\t\t     (struct fuse_arg *) in->args, 0);\n\tfuse_copy_finish(cs);\n\tspin_lock(&fc->lock);\n\treq->locked = 0;\n\tif (req->aborted) {\n\t\trequest_end(fc, req);\n\t\treturn -ENODEV;\n\t}\n\tif (err) {\n\t\treq->out.h.error = -EIO;\n\t\trequest_end(fc, req);\n\t\treturn err;\n\t}\n\tif (!req->isreply)\n\t\trequest_end(fc, req);\n\telse {\n\t\treq->state = FUSE_REQ_SENT;\n\t\tlist_move_tail(&req->list, &fc->processing);\n\t\tif (req->interrupted)\n\t\t\tqueue_interrupt(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn reqsize;\n\n err_unlock:\n\tspin_unlock(&fc->lock);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_read_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1251-1259",
    "snippet": "static int fuse_read_forget(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t    size_t nbytes)\n__releases(fc->lock)\n{\n\tif (fc->minor < 16 || fc->forget_list_head.next->next == NULL)\n\t\treturn fuse_read_single_forget(fc, cs, nbytes);\n\telse\n\t\treturn fuse_read_batch_forget(fc, cs, nbytes);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_read_batch_forget",
          "args": [
            "fc",
            "cs",
            "nbytes"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_batch_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1202-1249",
          "snippet": "static int fuse_read_batch_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs, size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tunsigned max_forgets;\n\tunsigned count;\n\tstruct fuse_forget_link *head;\n\tstruct fuse_batch_forget_in arg = { .count = 0 };\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_BATCH_FORGET,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tif (nbytes < ih.len) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_forgets = (nbytes - ih.len) / sizeof(struct fuse_forget_one);\n\thead = dequeue_forget(fc, max_forgets, &count);\n\tspin_unlock(&fc->lock);\n\n\targ.count = count;\n\tih.len += count * sizeof(struct fuse_forget_one);\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\n\twhile (head) {\n\t\tstruct fuse_forget_link *forget = head;\n\n\t\tif (!err) {\n\t\t\terr = fuse_copy_one(cs, &forget->forget_one,\n\t\t\t\t\t    sizeof(forget->forget_one));\n\t\t}\n\t\thead = forget->next;\n\t\tkfree(forget);\n\t}\n\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_batch_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs, size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tunsigned max_forgets;\n\tunsigned count;\n\tstruct fuse_forget_link *head;\n\tstruct fuse_batch_forget_in arg = { .count = 0 };\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_BATCH_FORGET,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tif (nbytes < ih.len) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_forgets = (nbytes - ih.len) / sizeof(struct fuse_forget_one);\n\thead = dequeue_forget(fc, max_forgets, &count);\n\tspin_unlock(&fc->lock);\n\n\targ.count = count;\n\tih.len += count * sizeof(struct fuse_forget_one);\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\n\twhile (head) {\n\t\tstruct fuse_forget_link *forget = head;\n\n\t\tif (!err) {\n\t\t\terr = fuse_copy_one(cs, &forget->forget_one,\n\t\t\t\t\t    sizeof(forget->forget_one));\n\t\t}\n\t\thead = forget->next;\n\t\tkfree(forget);\n\t}\n\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_read_single_forget",
          "args": [
            "fc",
            "cs",
            "nbytes"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_single_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1169-1200",
          "snippet": "static int fuse_read_single_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs,\n\t\t\t\t   size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tstruct fuse_forget_link *forget = dequeue_forget(fc, 1, NULL);\n\tstruct fuse_forget_in arg = {\n\t\t.nlookup = forget->forget_one.nlookup,\n\t};\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_FORGET,\n\t\t.nodeid = forget->forget_one.nodeid,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tspin_unlock(&fc->lock);\n\tkfree(forget);\n\tif (nbytes < ih.len)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_single_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs,\n\t\t\t\t   size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tstruct fuse_forget_link *forget = dequeue_forget(fc, 1, NULL);\n\tstruct fuse_forget_in arg = {\n\t\t.nlookup = forget->forget_one.nlookup,\n\t};\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_FORGET,\n\t\t.nodeid = forget->forget_one.nodeid,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tspin_unlock(&fc->lock);\n\tkfree(forget);\n\tif (nbytes < ih.len)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_forget(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t    size_t nbytes)\n__releases(fc->lock)\n{\n\tif (fc->minor < 16 || fc->forget_list_head.next->next == NULL)\n\t\treturn fuse_read_single_forget(fc, cs, nbytes);\n\telse\n\t\treturn fuse_read_batch_forget(fc, cs, nbytes);\n}"
  },
  {
    "function_name": "fuse_read_batch_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1202-1249",
    "snippet": "static int fuse_read_batch_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs, size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tunsigned max_forgets;\n\tunsigned count;\n\tstruct fuse_forget_link *head;\n\tstruct fuse_batch_forget_in arg = { .count = 0 };\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_BATCH_FORGET,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tif (nbytes < ih.len) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_forgets = (nbytes - ih.len) / sizeof(struct fuse_forget_one);\n\thead = dequeue_forget(fc, max_forgets, &count);\n\tspin_unlock(&fc->lock);\n\n\targ.count = count;\n\tih.len += count * sizeof(struct fuse_forget_one);\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\n\twhile (head) {\n\t\tstruct fuse_forget_link *forget = head;\n\n\t\tif (!err) {\n\t\t\terr = fuse_copy_one(cs, &forget->forget_one,\n\t\t\t\t\t    sizeof(forget->forget_one));\n\t\t}\n\t\thead = forget->next;\n\t\tkfree(forget);\n\t}\n\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&forget->forget_one",
            "sizeof(forget->forget_one)"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_forget",
          "args": [
            "fc",
            "max_forgets",
            "&count"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1147-1167",
          "snippet": "static struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_unique",
          "args": [
            "fc"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "313-321",
          "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_batch_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs, size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tunsigned max_forgets;\n\tunsigned count;\n\tstruct fuse_forget_link *head;\n\tstruct fuse_batch_forget_in arg = { .count = 0 };\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_BATCH_FORGET,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tif (nbytes < ih.len) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_forgets = (nbytes - ih.len) / sizeof(struct fuse_forget_one);\n\thead = dequeue_forget(fc, max_forgets, &count);\n\tspin_unlock(&fc->lock);\n\n\targ.count = count;\n\tih.len += count * sizeof(struct fuse_forget_one);\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\n\twhile (head) {\n\t\tstruct fuse_forget_link *forget = head;\n\n\t\tif (!err) {\n\t\t\terr = fuse_copy_one(cs, &forget->forget_one,\n\t\t\t\t\t    sizeof(forget->forget_one));\n\t\t}\n\t\thead = forget->next;\n\t\tkfree(forget);\n\t}\n\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}"
  },
  {
    "function_name": "fuse_read_single_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1169-1200",
    "snippet": "static int fuse_read_single_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs,\n\t\t\t\t   size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tstruct fuse_forget_link *forget = dequeue_forget(fc, 1, NULL);\n\tstruct fuse_forget_in arg = {\n\t\t.nlookup = forget->forget_one.nlookup,\n\t};\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_FORGET,\n\t\t.nodeid = forget->forget_one.nodeid,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tspin_unlock(&fc->lock);\n\tkfree(forget);\n\tif (nbytes < ih.len)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&arg",
            "sizeof(arg)"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_unique",
          "args": [
            "fc"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "313-321",
          "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_forget",
          "args": [
            "fc",
            "1",
            "NULL"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1147-1167",
          "snippet": "static struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_single_forget(struct fuse_conn *fc,\n\t\t\t\t   struct fuse_copy_state *cs,\n\t\t\t\t   size_t nbytes)\n__releases(fc->lock)\n{\n\tint err;\n\tstruct fuse_forget_link *forget = dequeue_forget(fc, 1, NULL);\n\tstruct fuse_forget_in arg = {\n\t\t.nlookup = forget->forget_one.nlookup,\n\t};\n\tstruct fuse_in_header ih = {\n\t\t.opcode = FUSE_FORGET,\n\t\t.nodeid = forget->forget_one.nodeid,\n\t\t.unique = fuse_get_unique(fc),\n\t\t.len = sizeof(ih) + sizeof(arg),\n\t};\n\n\tspin_unlock(&fc->lock);\n\tkfree(forget);\n\tif (nbytes < ih.len)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\tif (err)\n\t\treturn err;\n\n\treturn ih.len;\n}"
  },
  {
    "function_name": "dequeue_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1147-1167",
    "snippet": "static struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,\n\t\t\t\t\t       unsigned max,\n\t\t\t\t\t       unsigned *countp)\n{\n\tstruct fuse_forget_link *head = fc->forget_list_head.next;\n\tstruct fuse_forget_link **newhead = &head;\n\tunsigned count;\n\n\tfor (count = 0; *newhead != NULL && count < max; count++)\n\t\tnewhead = &(*newhead)->next;\n\n\tfc->forget_list_head.next = *newhead;\n\t*newhead = NULL;\n\tif (fc->forget_list_head.next == NULL)\n\t\tfc->forget_list_tail = &fc->forget_list_head;\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\n\treturn head;\n}"
  },
  {
    "function_name": "fuse_read_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1117-1145",
    "snippet": "static int fuse_read_interrupt(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t       size_t nbytes, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tstruct fuse_in_header ih;\n\tstruct fuse_interrupt_in arg;\n\tunsigned reqsize = sizeof(ih) + sizeof(arg);\n\tint err;\n\n\tlist_del_init(&req->intr_entry);\n\treq->intr_unique = fuse_get_unique(fc);\n\tmemset(&ih, 0, sizeof(ih));\n\tmemset(&arg, 0, sizeof(arg));\n\tih.len = reqsize;\n\tih.opcode = FUSE_INTERRUPT;\n\tih.unique = req->intr_unique;\n\targ.unique = req->in.h.unique;\n\n\tspin_unlock(&fc->lock);\n\tif (nbytes < reqsize)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\treturn err ? err : reqsize;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "&arg",
            "sizeof(arg)"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&arg",
            "0",
            "sizeof(arg)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ih",
            "0",
            "sizeof(ih)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_unique",
          "args": [
            "fc"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "313-321",
          "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->intr_entry"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_read_interrupt(struct fuse_conn *fc, struct fuse_copy_state *cs,\n\t\t\t       size_t nbytes, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tstruct fuse_in_header ih;\n\tstruct fuse_interrupt_in arg;\n\tunsigned reqsize = sizeof(ih) + sizeof(arg);\n\tint err;\n\n\tlist_del_init(&req->intr_entry);\n\treq->intr_unique = fuse_get_unique(fc);\n\tmemset(&ih, 0, sizeof(ih));\n\tmemset(&arg, 0, sizeof(arg));\n\tih.len = reqsize;\n\tih.opcode = FUSE_INTERRUPT;\n\tih.unique = req->intr_unique;\n\targ.unique = req->in.h.unique;\n\n\tspin_unlock(&fc->lock);\n\tif (nbytes < reqsize)\n\t\treturn -EINVAL;\n\n\terr = fuse_copy_one(cs, &ih, sizeof(ih));\n\tif (!err)\n\t\terr = fuse_copy_one(cs, &arg, sizeof(arg));\n\tfuse_copy_finish(cs);\n\n\treturn err ? err : reqsize;\n}"
  },
  {
    "function_name": "request_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1089-1107",
    "snippet": "static void request_wait(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(&fc->waitq, &wait);\n\twhile (fc->connected && !request_pending(fc)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tspin_unlock(&fc->lock);\n\t\tschedule();\n\t\tspin_lock(&fc->lock);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&fc->waitq, &wait);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&fc->waitq",
            "&wait"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_pending",
          "args": [
            "fc"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "request_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1082-1086",
          "snippet": "static int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "&fc->waitq",
            "&wait"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_wait(struct fuse_conn *fc)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(&fc->waitq, &wait);\n\twhile (fc->connected && !request_pending(fc)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tspin_unlock(&fc->lock);\n\t\tschedule();\n\t\tspin_lock(&fc->lock);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&fc->waitq, &wait);\n}"
  },
  {
    "function_name": "request_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1082-1086",
    "snippet": "static int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "forget_pending",
          "args": [
            "fc"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "forget_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1077-1080",
          "snippet": "static int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fc->interrupts"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int request_pending(struct fuse_conn *fc)\n{\n\treturn !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||\n\t\tforget_pending(fc);\n}"
  },
  {
    "function_name": "forget_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1077-1080",
    "snippet": "static int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int forget_pending(struct fuse_conn *fc)\n{\n\treturn fc->forget_list_head.next != NULL;\n}"
  },
  {
    "function_name": "fuse_copy_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1060-1075",
    "snippet": "static int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_one",
          "args": [
            "cs",
            "arg->value",
            "arg->size"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1046-1057",
          "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_pages",
          "args": [
            "cs",
            "arg->size",
            "zeroing"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "1024-1043",
          "snippet": "static int fuse_copy_pages(struct fuse_copy_state *cs, unsigned nbytes,\n\t\t\t   int zeroing)\n{\n\tunsigned i;\n\tstruct fuse_req *req = cs->req;\n\n\tfor (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {\n\t\tint err;\n\t\tunsigned offset = req->page_descs[i].offset;\n\t\tunsigned count = min(nbytes, req->page_descs[i].length);\n\n\t\terr = fuse_copy_page(cs, &req->pages[i], offset, count,\n\t\t\t\t     zeroing);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnbytes -= count;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_pages(struct fuse_copy_state *cs, unsigned nbytes,\n\t\t\t   int zeroing)\n{\n\tunsigned i;\n\tstruct fuse_req *req = cs->req;\n\n\tfor (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {\n\t\tint err;\n\t\tunsigned offset = req->page_descs[i].offset;\n\t\tunsigned count = min(nbytes, req->page_descs[i].length);\n\n\t\terr = fuse_copy_page(cs, &req->pages[i], offset, count,\n\t\t\t\t     zeroing);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnbytes -= count;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,\n\t\t\t  unsigned argpages, struct fuse_arg *args,\n\t\t\t  int zeroing)\n{\n\tint err = 0;\n\tunsigned i;\n\n\tfor (i = 0; !err && i < numargs; i++)  {\n\t\tstruct fuse_arg *arg = &args[i];\n\t\tif (i == numargs - 1 && argpages)\n\t\t\terr = fuse_copy_pages(cs, arg->size, zeroing);\n\t\telse\n\t\t\terr = fuse_copy_one(cs, arg->value, arg->size);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_copy_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1046-1057",
    "snippet": "static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_do",
          "args": [
            "cs",
            "&val",
            "&size"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_do",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "825-844",
          "snippet": "static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_fill",
          "args": [
            "cs"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "761-822",
          "snippet": "static int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)\n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_copy_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "1024-1043",
    "snippet": "static int fuse_copy_pages(struct fuse_copy_state *cs, unsigned nbytes,\n\t\t\t   int zeroing)\n{\n\tunsigned i;\n\tstruct fuse_req *req = cs->req;\n\n\tfor (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {\n\t\tint err;\n\t\tunsigned offset = req->page_descs[i].offset;\n\t\tunsigned count = min(nbytes, req->page_descs[i].length);\n\n\t\terr = fuse_copy_page(cs, &req->pages[i], offset, count,\n\t\t\t\t     zeroing);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnbytes -= count;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_copy_page",
          "args": [
            "cs",
            "&req->pages[i]",
            "offset",
            "count",
            "zeroing"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "986-1021",
          "snippet": "static int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nbytes",
            "req->page_descs[i].length"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_pages(struct fuse_copy_state *cs, unsigned nbytes,\n\t\t\t   int zeroing)\n{\n\tunsigned i;\n\tstruct fuse_req *req = cs->req;\n\n\tfor (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {\n\t\tint err;\n\t\tunsigned offset = req->page_descs[i].offset;\n\t\tunsigned count = min(nbytes, req->page_descs[i].length);\n\n\t\terr = fuse_copy_page(cs, &req->pages[i], offset, count,\n\t\t\t\t     zeroing);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnbytes -= count;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_copy_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "986-1021",
    "snippet": "static int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_copy_do",
          "args": [
            "cs",
            "NULL",
            "&count"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_do",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "825-844",
          "snippet": "static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapaddr"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_fill",
          "args": [
            "cs"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "761-822",
          "snippet": "static int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_try_move_page",
          "args": [
            "cs",
            "pagep"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_try_move_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "865-956",
          "snippet": "static int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)\n{\n\tint err;\n\tstruct page *oldpage = *pagep;\n\tstruct page *newpage;\n\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\terr = buf->ops->confirm(cs->pipe, buf);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!cs->nr_segs);\n\tcs->currbuf = buf;\n\tcs->len = buf->len;\n\tcs->pipebufs++;\n\tcs->nr_segs--;\n\n\tif (cs->len != PAGE_SIZE)\n\t\tgoto out_fallback;\n\n\tif (buf->ops->steal(cs->pipe, buf) != 0)\n\t\tgoto out_fallback;\n\n\tnewpage = buf->page;\n\n\tif (!PageUptodate(newpage))\n\t\tSetPageUptodate(newpage);\n\n\tClearPageMappedToDisk(newpage);\n\n\tif (fuse_check_page(newpage) != 0)\n\t\tgoto out_fallback_unlock;\n\n\t/*\n\t * This is a new and locked page, it shouldn't be mapped or\n\t * have any special flags on it\n\t */\n\tif (WARN_ON(page_mapped(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(page_has_private(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageDirty(oldpage) || PageWriteback(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageMlocked(oldpage)))\n\t\tgoto out_fallback_unlock;\n\n\terr = replace_page_cache_page(oldpage, newpage, GFP_KERNEL);\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\treturn err;\n\t}\n\n\tpage_cache_get(newpage);\n\n\tif (!(buf->flags & PIPE_BUF_FLAG_LRU))\n\t\tlru_cache_add_file(newpage);\n\n\terr = 0;\n\tspin_lock(&cs->fc->lock);\n\tif (cs->req->aborted)\n\t\terr = -ENOENT;\n\telse\n\t\t*pagep = newpage;\n\tspin_unlock(&cs->fc->lock);\n\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\tpage_cache_release(newpage);\n\t\treturn err;\n\t}\n\n\tunlock_page(oldpage);\n\tpage_cache_release(oldpage);\n\tcs->len = 0;\n\n\treturn 0;\n\nout_fallback_unlock:\n\tunlock_page(newpage);\nout_fallback:\n\tcs->pg = buf->page;\n\tcs->offset = buf->offset;\n\n\terr = lock_request(cs->fc, cs->req);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)\n{\n\tint err;\n\tstruct page *oldpage = *pagep;\n\tstruct page *newpage;\n\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\terr = buf->ops->confirm(cs->pipe, buf);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!cs->nr_segs);\n\tcs->currbuf = buf;\n\tcs->len = buf->len;\n\tcs->pipebufs++;\n\tcs->nr_segs--;\n\n\tif (cs->len != PAGE_SIZE)\n\t\tgoto out_fallback;\n\n\tif (buf->ops->steal(cs->pipe, buf) != 0)\n\t\tgoto out_fallback;\n\n\tnewpage = buf->page;\n\n\tif (!PageUptodate(newpage))\n\t\tSetPageUptodate(newpage);\n\n\tClearPageMappedToDisk(newpage);\n\n\tif (fuse_check_page(newpage) != 0)\n\t\tgoto out_fallback_unlock;\n\n\t/*\n\t * This is a new and locked page, it shouldn't be mapped or\n\t * have any special flags on it\n\t */\n\tif (WARN_ON(page_mapped(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(page_has_private(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageDirty(oldpage) || PageWriteback(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageMlocked(oldpage)))\n\t\tgoto out_fallback_unlock;\n\n\terr = replace_page_cache_page(oldpage, newpage, GFP_KERNEL);\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\treturn err;\n\t}\n\n\tpage_cache_get(newpage);\n\n\tif (!(buf->flags & PIPE_BUF_FLAG_LRU))\n\t\tlru_cache_add_file(newpage);\n\n\terr = 0;\n\tspin_lock(&cs->fc->lock);\n\tif (cs->req->aborted)\n\t\terr = -ENOENT;\n\telse\n\t\t*pagep = newpage;\n\tspin_unlock(&cs->fc->lock);\n\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\tpage_cache_release(newpage);\n\t\treturn err;\n\t}\n\n\tunlock_page(oldpage);\n\tpage_cache_release(oldpage);\n\tcs->len = 0;\n\n\treturn 0;\n\nout_fallback_unlock:\n\tunlock_page(newpage);\nout_fallback:\n\tcs->pg = buf->page;\n\tcs->offset = buf->offset;\n\n\terr = lock_request(cs->fc, cs->req);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ref_page",
          "args": [
            "cs",
            "page",
            "offset",
            "count"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ref_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "958-980",
          "snippet": "static int fuse_ref_page(struct fuse_copy_state *cs, struct page *page,\n\t\t\t unsigned offset, unsigned count)\n{\n\tstruct pipe_buffer *buf;\n\n\tif (cs->nr_segs == cs->pipe->buffers)\n\t\treturn -EIO;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\tbuf = cs->pipebufs;\n\tpage_cache_get(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = count;\n\n\tcs->pipebufs++;\n\tcs->nr_segs++;\n\tcs->len = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_ref_page(struct fuse_copy_state *cs, struct page *page,\n\t\t\t unsigned offset, unsigned count)\n{\n\tstruct pipe_buffer *buf;\n\n\tif (cs->nr_segs == cs->pipe->buffers)\n\t\treturn -EIO;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\tbuf = cs->pipebufs;\n\tpage_cache_get(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = count;\n\n\tcs->pipebufs++;\n\tcs->nr_segs++;\n\tcs->len = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,\n\t\t\t  unsigned offset, unsigned count, int zeroing)\n{\n\tint err;\n\tstruct page *page = *pagep;\n\n\tif (page && zeroing && count < PAGE_SIZE)\n\t\tclear_highpage(page);\n\n\twhile (count) {\n\t\tif (cs->write && cs->pipebufs && page) {\n\t\t\treturn fuse_ref_page(cs, page, offset, count);\n\t\t} else if (!cs->len) {\n\t\t\tif (cs->move_pages && page &&\n\t\t\t    offset == 0 && count == PAGE_SIZE) {\n\t\t\t\terr = fuse_try_move_page(cs, pagep);\n\t\t\t\tif (err <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = fuse_copy_fill(cs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (page) {\n\t\t\tvoid *mapaddr = kmap_atomic(page);\n\t\t\tvoid *buf = mapaddr + offset;\n\t\t\toffset += fuse_copy_do(cs, &buf, &count);\n\t\t\tkunmap_atomic(mapaddr);\n\t\t} else\n\t\t\toffset += fuse_copy_do(cs, NULL, &count);\n\t}\n\tif (page && !cs->write)\n\t\tflush_dcache_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_ref_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "958-980",
    "snippet": "static int fuse_ref_page(struct fuse_copy_state *cs, struct page *page,\n\t\t\t unsigned offset, unsigned count)\n{\n\tstruct pipe_buffer *buf;\n\n\tif (cs->nr_segs == cs->pipe->buffers)\n\t\treturn -EIO;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\tbuf = cs->pipebufs;\n\tpage_cache_get(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = count;\n\n\tcs->pipebufs++;\n\tcs->nr_segs++;\n\tcs->len = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_request",
          "args": [
            "cs->fc",
            "cs->req"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "699-708",
          "snippet": "static void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_ref_page(struct fuse_copy_state *cs, struct page *page,\n\t\t\t unsigned offset, unsigned count)\n{\n\tstruct pipe_buffer *buf;\n\n\tif (cs->nr_segs == cs->pipe->buffers)\n\t\treturn -EIO;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\tbuf = cs->pipebufs;\n\tpage_cache_get(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = count;\n\n\tcs->pipebufs++;\n\tcs->nr_segs++;\n\tcs->len = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_try_move_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "865-956",
    "snippet": "static int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)\n{\n\tint err;\n\tstruct page *oldpage = *pagep;\n\tstruct page *newpage;\n\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\terr = buf->ops->confirm(cs->pipe, buf);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!cs->nr_segs);\n\tcs->currbuf = buf;\n\tcs->len = buf->len;\n\tcs->pipebufs++;\n\tcs->nr_segs--;\n\n\tif (cs->len != PAGE_SIZE)\n\t\tgoto out_fallback;\n\n\tif (buf->ops->steal(cs->pipe, buf) != 0)\n\t\tgoto out_fallback;\n\n\tnewpage = buf->page;\n\n\tif (!PageUptodate(newpage))\n\t\tSetPageUptodate(newpage);\n\n\tClearPageMappedToDisk(newpage);\n\n\tif (fuse_check_page(newpage) != 0)\n\t\tgoto out_fallback_unlock;\n\n\t/*\n\t * This is a new and locked page, it shouldn't be mapped or\n\t * have any special flags on it\n\t */\n\tif (WARN_ON(page_mapped(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(page_has_private(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageDirty(oldpage) || PageWriteback(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageMlocked(oldpage)))\n\t\tgoto out_fallback_unlock;\n\n\terr = replace_page_cache_page(oldpage, newpage, GFP_KERNEL);\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\treturn err;\n\t}\n\n\tpage_cache_get(newpage);\n\n\tif (!(buf->flags & PIPE_BUF_FLAG_LRU))\n\t\tlru_cache_add_file(newpage);\n\n\terr = 0;\n\tspin_lock(&cs->fc->lock);\n\tif (cs->req->aborted)\n\t\terr = -ENOENT;\n\telse\n\t\t*pagep = newpage;\n\tspin_unlock(&cs->fc->lock);\n\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\tpage_cache_release(newpage);\n\t\treturn err;\n\t}\n\n\tunlock_page(oldpage);\n\tpage_cache_release(oldpage);\n\tcs->len = 0;\n\n\treturn 0;\n\nout_fallback_unlock:\n\tunlock_page(newpage);\nout_fallback:\n\tcs->pg = buf->page;\n\tcs->offset = buf->offset;\n\n\terr = lock_request(cs->fc, cs->req);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_request",
          "args": [
            "cs->fc",
            "cs->req"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "699-708",
          "snippet": "static void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "newpage"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "oldpage"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "newpage"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cs->fc->lock"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cs->fc->lock"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "newpage"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "newpage"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_page_cache_page",
          "args": [
            "oldpage",
            "newpage",
            "GFP_KERNEL"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageMlocked(oldpage)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "oldpage"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(oldpage) || PageWriteback(oldpage)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "oldpage"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "oldpage"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_has_private(oldpage)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "oldpage"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_mapped(oldpage)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "oldpage"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_check_page",
          "args": [
            "newpage"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "846-863",
          "snippet": "static int fuse_check_page(struct page *page)\n{\n\tif (page_mapcount(page) ||\n\t    page->mapping != NULL ||\n\t    page_count(page) != 1 ||\n\t    (page->flags & PAGE_FLAGS_CHECK_AT_PREP &\n\t     ~(1 << PG_locked |\n\t       1 << PG_referenced |\n\t       1 << PG_uptodate |\n\t       1 << PG_lru |\n\t       1 << PG_active |\n\t       1 << PG_reclaim))) {\n\t\tprintk(KERN_WARNING \"fuse: trying to steal weird page\\n\");\n\t\tprintk(KERN_WARNING \"  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\\n\", page, page->index, page->flags, page_count(page), page_mapcount(page), page->mapping);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_check_page(struct page *page)\n{\n\tif (page_mapcount(page) ||\n\t    page->mapping != NULL ||\n\t    page_count(page) != 1 ||\n\t    (page->flags & PAGE_FLAGS_CHECK_AT_PREP &\n\t     ~(1 << PG_locked |\n\t       1 << PG_referenced |\n\t       1 << PG_uptodate |\n\t       1 << PG_lru |\n\t       1 << PG_active |\n\t       1 << PG_reclaim))) {\n\t\tprintk(KERN_WARNING \"fuse: trying to steal weird page\\n\");\n\t\tprintk(KERN_WARNING \"  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\\n\", page, page->index, page->flags, page_count(page), page_mapcount(page), page->mapping);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "newpage"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "newpage"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "newpage"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->steal",
          "args": [
            "cs->pipe",
            "buf"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cs->nr_segs"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->confirm",
          "args": [
            "cs->pipe",
            "buf"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)\n{\n\tint err;\n\tstruct page *oldpage = *pagep;\n\tstruct page *newpage;\n\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\n\terr = buf->ops->confirm(cs->pipe, buf);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!cs->nr_segs);\n\tcs->currbuf = buf;\n\tcs->len = buf->len;\n\tcs->pipebufs++;\n\tcs->nr_segs--;\n\n\tif (cs->len != PAGE_SIZE)\n\t\tgoto out_fallback;\n\n\tif (buf->ops->steal(cs->pipe, buf) != 0)\n\t\tgoto out_fallback;\n\n\tnewpage = buf->page;\n\n\tif (!PageUptodate(newpage))\n\t\tSetPageUptodate(newpage);\n\n\tClearPageMappedToDisk(newpage);\n\n\tif (fuse_check_page(newpage) != 0)\n\t\tgoto out_fallback_unlock;\n\n\t/*\n\t * This is a new and locked page, it shouldn't be mapped or\n\t * have any special flags on it\n\t */\n\tif (WARN_ON(page_mapped(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(page_has_private(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageDirty(oldpage) || PageWriteback(oldpage)))\n\t\tgoto out_fallback_unlock;\n\tif (WARN_ON(PageMlocked(oldpage)))\n\t\tgoto out_fallback_unlock;\n\n\terr = replace_page_cache_page(oldpage, newpage, GFP_KERNEL);\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\treturn err;\n\t}\n\n\tpage_cache_get(newpage);\n\n\tif (!(buf->flags & PIPE_BUF_FLAG_LRU))\n\t\tlru_cache_add_file(newpage);\n\n\terr = 0;\n\tspin_lock(&cs->fc->lock);\n\tif (cs->req->aborted)\n\t\terr = -ENOENT;\n\telse\n\t\t*pagep = newpage;\n\tspin_unlock(&cs->fc->lock);\n\n\tif (err) {\n\t\tunlock_page(newpage);\n\t\tpage_cache_release(newpage);\n\t\treturn err;\n\t}\n\n\tunlock_page(oldpage);\n\tpage_cache_release(oldpage);\n\tcs->len = 0;\n\n\treturn 0;\n\nout_fallback_unlock:\n\tunlock_page(newpage);\nout_fallback:\n\tcs->pg = buf->page;\n\tcs->offset = buf->offset;\n\n\terr = lock_request(cs->fc, cs->req);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fuse_check_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "846-863",
    "snippet": "static int fuse_check_page(struct page *page)\n{\n\tif (page_mapcount(page) ||\n\t    page->mapping != NULL ||\n\t    page_count(page) != 1 ||\n\t    (page->flags & PAGE_FLAGS_CHECK_AT_PREP &\n\t     ~(1 << PG_locked |\n\t       1 << PG_referenced |\n\t       1 << PG_uptodate |\n\t       1 << PG_lru |\n\t       1 << PG_active |\n\t       1 << PG_reclaim))) {\n\t\tprintk(KERN_WARNING \"fuse: trying to steal weird page\\n\");\n\t\tprintk(KERN_WARNING \"  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\\n\", page, page->index, page->flags, page_count(page), page_mapcount(page), page->mapping);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\\n\"",
            "page",
            "page->index",
            "page->flags",
            "page_count(page)",
            "page_mapcount(page)",
            "page->mapping"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_check_page(struct page *page)\n{\n\tif (page_mapcount(page) ||\n\t    page->mapping != NULL ||\n\t    page_count(page) != 1 ||\n\t    (page->flags & PAGE_FLAGS_CHECK_AT_PREP &\n\t     ~(1 << PG_locked |\n\t       1 << PG_referenced |\n\t       1 << PG_uptodate |\n\t       1 << PG_lru |\n\t       1 << PG_active |\n\t       1 << PG_reclaim))) {\n\t\tprintk(KERN_WARNING \"fuse: trying to steal weird page\\n\");\n\t\tprintk(KERN_WARNING \"  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\\n\", page, page->index, page->flags, page_count(page), page_mapcount(page), page->mapping);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_copy_do",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "825-844",
    "snippet": "static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pgaddr"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*val",
            "buf",
            "ncpy"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "*val",
            "ncpy"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cs->pg"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*size",
            "cs->len"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)\n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tvoid *pgaddr = kmap_atomic(cs->pg);\n\t\tvoid *buf = pgaddr + cs->offset;\n\n\t\tif (cs->write)\n\t\t\tmemcpy(buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, buf, ncpy);\n\n\t\tkunmap_atomic(pgaddr);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->offset += ncpy;\n\treturn ncpy;\n}"
  },
  {
    "function_name": "fuse_copy_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "761-822",
    "snippet": "static int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_request",
          "args": [
            "cs->fc",
            "cs->req"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "699-708",
          "snippet": "static void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "PAGE_SIZE - cs->offset",
            "cs->seglen"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != 1"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "cs->addr",
            "1",
            "cs->write",
            "&page"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cs->nr_segs"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cs->nr_segs"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->confirm",
          "args": [
            "cs->pipe",
            "buf"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_finish",
          "args": [
            "cs"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "739-755",
          "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_fill(struct fuse_copy_state *cs)\n{\n\tstruct page *page;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = buf->page;\n\t\t\tcs->offset = buf->offset;\n\t\t\tcs->len = buf->len;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->pg = page;\n\t\t\tcs->offset = 0;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\tcs->pg = page;\n\t\tcs->offset = cs->addr % PAGE_SIZE;\n\t\tcs->len = min(PAGE_SIZE - cs->offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}"
  },
  {
    "function_name": "fuse_copy_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "739-755",
    "snippet": "static void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "cs->pg"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "cs->pg"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "cs->pg"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_finish(struct fuse_copy_state *cs)\n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (cs->write)\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\tcs->currbuf = NULL;\n\t} else if (cs->pg) {\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t}\n\tcs->pg = NULL;\n}"
  },
  {
    "function_name": "fuse_copy_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "727-736",
    "snippet": "static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cs",
            "0",
            "sizeof(*cs)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,\n\t\t\t   int write,\n\t\t\t   const struct iovec *iov, unsigned long nr_segs)\n{\n\tmemset(cs, 0, sizeof(*cs));\n\tcs->fc = fc;\n\tcs->write = write;\n\tcs->iov = iov;\n\tcs->nr_segs = nr_segs;\n}"
  },
  {
    "function_name": "unlock_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "699-708",
    "snippet": "static void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&req->waitq"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void unlock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\treq->locked = 0;\n\t\tif (req->aborted)\n\t\t\twake_up(&req->waitq);\n\t\tspin_unlock(&fc->lock);\n\t}\n}"
  },
  {
    "function_name": "lock_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "680-692",
    "snippet": "static int lock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint err = 0;\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t\telse\n\t\t\treq->locked = 1;\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int lock_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint err = 0;\n\tif (req) {\n\t\tspin_lock(&fc->lock);\n\t\tif (req->aborted)\n\t\t\terr = -ENOENT;\n\t\telse\n\t\t\treq->locked = 1;\n\t\tspin_unlock(&fc->lock);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_force_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "654-673",
    "snippet": "void fuse_force_forget(struct file *file, u64 nodeid)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_forget_in inarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.nlookup = 1;\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\treq->in.h.opcode = FUSE_FORGET;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->isreply = 0;\n\t__fuse_request_send(fc, req);\n\t/* ignore errors */\n\tfuse_put_request(fc, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "498-516",
          "snippet": "static void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_req_nofail_nopages",
          "args": [
            "fc",
            "file"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_force_forget(struct file *file, u64 nodeid)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_forget_in inarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.nlookup = 1;\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\treq->in.h.opcode = FUSE_FORGET;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->isreply = 0;\n\t__fuse_request_send(fc, req);\n\t/* ignore errors */\n\tfuse_put_request(fc, req);\n}"
  },
  {
    "function_name": "fuse_request_send_background_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "647-652",
    "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send_nowait_locked",
          "args": [
            "fc",
            "req"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_nowait_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "590-604",
          "snippet": "static void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
  },
  {
    "function_name": "fuse_request_send_notify_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "625-640",
    "snippet": "static int fuse_request_send_notify_reply(struct fuse_conn *fc,\n\t\t\t\t\t  struct fuse_req *req, u64 unique)\n{\n\tint err = -ENODEV;\n\n\treq->isreply = 0;\n\treq->in.h.unique = unique;\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tqueue_request(fc, req);\n\t\terr = 0;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "queue_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "323-335",
          "snippet": "static void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_request_send_notify_reply(struct fuse_conn *fc,\n\t\t\t\t\t  struct fuse_req *req, u64 unique)\n{\n\tint err = -ENODEV;\n\n\treq->isreply = 0;\n\treq->in.h.unique = unique;\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tqueue_request(fc, req);\n\t\terr = 0;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_request_send_background",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "618-622",
    "snippet": "void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait(fc, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send_nowait",
          "args": [
            "fc",
            "req"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "606-616",
          "snippet": "static void fuse_request_send_nowait(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfuse_request_send_nowait_locked(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t} else {\n\t\treq->out.h.error = -ENOTCONN;\n\t\trequest_end(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_send_nowait(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfuse_request_send_nowait_locked(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t} else {\n\t\treq->out.h.error = -ENOTCONN;\n\t\trequest_end(fc, req);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait(fc, req);\n}"
  },
  {
    "function_name": "fuse_request_send_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "606-616",
    "snippet": "static void fuse_request_send_nowait(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfuse_request_send_nowait_locked(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t} else {\n\t\treq->out.h.error = -ENOTCONN;\n\t\trequest_end(fc, req);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "request_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "379-411",
          "snippet": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send_nowait_locked",
          "args": [
            "fc",
            "req"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_nowait_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "590-604",
          "snippet": "static void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_send_nowait(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfuse_request_send_nowait_locked(fc, req);\n\t\tspin_unlock(&fc->lock);\n\t} else {\n\t\treq->out.h.error = -ENOTCONN;\n\t\trequest_end(fc, req);\n\t}\n}"
  },
  {
    "function_name": "fuse_request_send_nowait_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "590-604",
    "snippet": "static void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_bg_queue",
          "args": [
            "fc"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "flush_bg_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "355-367",
          "snippet": "static void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->list",
            "&fc->bg_queue"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&fc->bdi",
            "BLK_RW_ASYNC"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&fc->bdi",
            "BLK_RW_SYNC"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!req->background"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_send_nowait_locked(struct fuse_conn *fc,\n\t\t\t\t\t    struct fuse_req *req)\n{\n\tBUG_ON(!req->background);\n\tfc->num_background++;\n\tif (fc->num_background == fc->max_background)\n\t\tfc->blocked = 1;\n\tif (fc->num_background == fc->congestion_threshold &&\n\t    fc->bdi_initialized) {\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\tset_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t}\n\tlist_add_tail(&req->list, &fc->bg_queue);\n\tflush_bg_queue(fc);\n}"
  },
  {
    "function_name": "fuse_simple_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "558-588",
    "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "args->out.numargs != 1"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->out.args",
            "args->out.args",
            "args->out.numargs * sizeof(struct fuse_arg)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->in.args",
            "args->in.args",
            "args->in.numargs * sizeof(struct fuse_in_arg)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_adjust_compat",
          "args": [
            "fc",
            "args"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_adjust_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "525-556",
          "snippet": "static void fuse_adjust_compat(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tif (fc->minor < 4 && args->in.h.opcode == FUSE_STATFS)\n\t\targs->out.args[0].size = FUSE_COMPAT_STATFS_SIZE;\n\n\tif (fc->minor < 9) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_LOOKUP:\n\t\tcase FUSE_CREATE:\n\t\tcase FUSE_MKNOD:\n\t\tcase FUSE_MKDIR:\n\t\tcase FUSE_SYMLINK:\n\t\tcase FUSE_LINK:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;\n\t\t\tbreak;\n\t\tcase FUSE_GETATTR:\n\t\tcase FUSE_SETATTR:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fc->minor < 12) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_CREATE:\n\t\t\targs->in.args[0].size = sizeof(struct fuse_open_in);\n\t\t\tbreak;\n\t\tcase FUSE_MKNOD:\n\t\t\targs->in.args[0].size = FUSE_COMPAT_MKNOD_IN_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_adjust_compat(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tif (fc->minor < 4 && args->in.h.opcode == FUSE_STATFS)\n\t\targs->out.args[0].size = FUSE_COMPAT_STATFS_SIZE;\n\n\tif (fc->minor < 9) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_LOOKUP:\n\t\tcase FUSE_CREATE:\n\t\tcase FUSE_MKNOD:\n\t\tcase FUSE_MKDIR:\n\t\tcase FUSE_SYMLINK:\n\t\tcase FUSE_LINK:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;\n\t\t\tbreak;\n\t\tcase FUSE_GETATTR:\n\t\tcase FUSE_SETATTR:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fc->minor < 12) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_CREATE:\n\t\t\targs->in.args[0].size = sizeof(struct fuse_open_in);\n\t\t\tbreak;\n\t\tcase FUSE_MKNOD:\n\t\t\targs->in.args[0].size = FUSE_COMPAT_MKNOD_IN_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "0"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_adjust_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "525-556",
    "snippet": "static void fuse_adjust_compat(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tif (fc->minor < 4 && args->in.h.opcode == FUSE_STATFS)\n\t\targs->out.args[0].size = FUSE_COMPAT_STATFS_SIZE;\n\n\tif (fc->minor < 9) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_LOOKUP:\n\t\tcase FUSE_CREATE:\n\t\tcase FUSE_MKNOD:\n\t\tcase FUSE_MKDIR:\n\t\tcase FUSE_SYMLINK:\n\t\tcase FUSE_LINK:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;\n\t\t\tbreak;\n\t\tcase FUSE_GETATTR:\n\t\tcase FUSE_SETATTR:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fc->minor < 12) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_CREATE:\n\t\t\targs->in.args[0].size = sizeof(struct fuse_open_in);\n\t\t\tbreak;\n\t\tcase FUSE_MKNOD:\n\t\t\targs->in.args[0].size = FUSE_COMPAT_MKNOD_IN_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_adjust_compat(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tif (fc->minor < 4 && args->in.h.opcode == FUSE_STATFS)\n\t\targs->out.args[0].size = FUSE_COMPAT_STATFS_SIZE;\n\n\tif (fc->minor < 9) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_LOOKUP:\n\t\tcase FUSE_CREATE:\n\t\tcase FUSE_MKNOD:\n\t\tcase FUSE_MKDIR:\n\t\tcase FUSE_SYMLINK:\n\t\tcase FUSE_LINK:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;\n\t\t\tbreak;\n\t\tcase FUSE_GETATTR:\n\t\tcase FUSE_SETATTR:\n\t\t\targs->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fc->minor < 12) {\n\t\tswitch (args->in.h.opcode) {\n\t\tcase FUSE_CREATE:\n\t\t\targs->in.args[0].size = sizeof(struct fuse_open_in);\n\t\t\tbreak;\n\t\tcase FUSE_MKNOD:\n\t\t\targs->in.args[0].size = FUSE_COMPAT_MKNOD_IN_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fuse_request_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "518-522",
    "snippet": "void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->isreply = 1;\n\t__fuse_request_send(fc, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_request_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "498-516",
          "snippet": "static void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->isreply = 1;\n\t__fuse_request_send(fc, req);\n}"
  },
  {
    "function_name": "__fuse_request_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "498-516",
    "snippet": "static void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_wait_answer",
          "args": [
            "fc",
            "req"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "request_wait_answer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "433-496",
          "snippet": "static void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (!fc->no_interrupt) {\n\t\t/* Any signal may interrupt this */\n\t\twait_answer_interruptible(fc, req);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\treq->interrupted = 1;\n\t\tif (req->state == FUSE_REQ_SENT)\n\t\t\tqueue_interrupt(fc, req);\n\t}\n\n\tif (!req->force) {\n\t\tsigset_t oldset;\n\n\t\t/* Only fatal signals may interrupt this */\n\t\tblock_sigs(&oldset);\n\t\twait_answer_interruptible(fc, req);\n\t\trestore_sigs(&oldset);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\t/* Request is not yet in userspace, bail out */\n\t\tif (req->state == FUSE_REQ_PENDING) {\n\t\t\tlist_del(&req->list);\n\t\t\t__fuse_put_request(req);\n\t\t\treq->out.h.error = -EINTR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Either request is already in userspace, or it was forced.\n\t * Wait it out.\n\t */\n\tspin_unlock(&fc->lock);\n\twait_event(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n\n\tif (!req->aborted)\n\t\treturn;\n\n aborted:\n\tBUG_ON(req->state != FUSE_REQ_FINISHED);\n\tif (req->locked) {\n\t\t/* This is uninterruptible sleep, because data is\n\t\t   being copied to/from the buffers of req.  During\n\t\t   locked state, there mustn't be any filesystem\n\t\t   operation (e.g. page fault), since that could lead\n\t\t   to deadlock */\n\t\tspin_unlock(&fc->lock);\n\t\twait_event(req->waitq, !req->locked);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (!fc->no_interrupt) {\n\t\t/* Any signal may interrupt this */\n\t\twait_answer_interruptible(fc, req);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\treq->interrupted = 1;\n\t\tif (req->state == FUSE_REQ_SENT)\n\t\t\tqueue_interrupt(fc, req);\n\t}\n\n\tif (!req->force) {\n\t\tsigset_t oldset;\n\n\t\t/* Only fatal signals may interrupt this */\n\t\tblock_sigs(&oldset);\n\t\twait_answer_interruptible(fc, req);\n\t\trestore_sigs(&oldset);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\t/* Request is not yet in userspace, bail out */\n\t\tif (req->state == FUSE_REQ_PENDING) {\n\t\t\tlist_del(&req->list);\n\t\t\t__fuse_put_request(req);\n\t\t\treq->out.h.error = -EINTR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Either request is already in userspace, or it was forced.\n\t * Wait it out.\n\t */\n\tspin_unlock(&fc->lock);\n\twait_event(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n\n\tif (!req->aborted)\n\t\treturn;\n\n aborted:\n\tBUG_ON(req->state != FUSE_REQ_FINISHED);\n\tif (req->locked) {\n\t\t/* This is uninterruptible sleep, because data is\n\t\t   being copied to/from the buffers of req.  During\n\t\t   locked state, there mustn't be any filesystem\n\t\t   operation (e.g. page fault), since that could lead\n\t\t   to deadlock */\n\t\tspin_unlock(&fc->lock);\n\t\twait_event(req->waitq, !req->locked);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_get_request",
          "args": [
            "req"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "115-118",
          "snippet": "void __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "queue_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "323-335",
          "snippet": "static void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_unique",
          "args": [
            "fc"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "313-321",
          "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->background"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tBUG_ON(req->background);\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "request_wait_answer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "433-496",
    "snippet": "static void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (!fc->no_interrupt) {\n\t\t/* Any signal may interrupt this */\n\t\twait_answer_interruptible(fc, req);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\treq->interrupted = 1;\n\t\tif (req->state == FUSE_REQ_SENT)\n\t\t\tqueue_interrupt(fc, req);\n\t}\n\n\tif (!req->force) {\n\t\tsigset_t oldset;\n\n\t\t/* Only fatal signals may interrupt this */\n\t\tblock_sigs(&oldset);\n\t\twait_answer_interruptible(fc, req);\n\t\trestore_sigs(&oldset);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\t/* Request is not yet in userspace, bail out */\n\t\tif (req->state == FUSE_REQ_PENDING) {\n\t\t\tlist_del(&req->list);\n\t\t\t__fuse_put_request(req);\n\t\t\treq->out.h.error = -EINTR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Either request is already in userspace, or it was forced.\n\t * Wait it out.\n\t */\n\tspin_unlock(&fc->lock);\n\twait_event(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n\n\tif (!req->aborted)\n\t\treturn;\n\n aborted:\n\tBUG_ON(req->state != FUSE_REQ_FINISHED);\n\tif (req->locked) {\n\t\t/* This is uninterruptible sleep, because data is\n\t\t   being copied to/from the buffers of req.  During\n\t\t   locked state, there mustn't be any filesystem\n\t\t   operation (e.g. page fault), since that could lead\n\t\t   to deadlock */\n\t\tspin_unlock(&fc->lock);\n\t\twait_event(req->waitq, !req->locked);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "req->waitq",
            "!req->locked"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->state != FUSE_REQ_FINISHED"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "req->waitq",
            "req->state == FUSE_REQ_FINISHED"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fuse_put_request",
          "args": [
            "req"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "121-125",
          "snippet": "static void __fuse_put_request(struct fuse_req *req)\n{\n\tBUG_ON(atomic_read(&req->count) < 2);\n\tatomic_dec(&req->count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_put_request(struct fuse_req *req)\n{\n\tBUG_ON(atomic_read(&req->count) < 2);\n\tatomic_dec(&req->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->list"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_sigs",
          "args": [
            "&oldset"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "restore_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "110-113",
          "snippet": "static void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_answer_interruptible",
          "args": [
            "fc",
            "req"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "wait_answer_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "413-424",
          "snippet": "static void wait_answer_interruptible(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (signal_pending(current))\n\t\treturn;\n\n\tspin_unlock(&fc->lock);\n\twait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void wait_answer_interruptible(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (signal_pending(current))\n\t\treturn;\n\n\tspin_unlock(&fc->lock);\n\twait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_sigs",
          "args": [
            "&oldset"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "block_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "102-108",
          "snippet": "static void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_interrupt",
          "args": [
            "fc",
            "req"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "queue_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "426-431",
          "snippet": "static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (!fc->no_interrupt) {\n\t\t/* Any signal may interrupt this */\n\t\twait_answer_interruptible(fc, req);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\treq->interrupted = 1;\n\t\tif (req->state == FUSE_REQ_SENT)\n\t\t\tqueue_interrupt(fc, req);\n\t}\n\n\tif (!req->force) {\n\t\tsigset_t oldset;\n\n\t\t/* Only fatal signals may interrupt this */\n\t\tblock_sigs(&oldset);\n\t\twait_answer_interruptible(fc, req);\n\t\trestore_sigs(&oldset);\n\n\t\tif (req->aborted)\n\t\t\tgoto aborted;\n\t\tif (req->state == FUSE_REQ_FINISHED)\n\t\t\treturn;\n\n\t\t/* Request is not yet in userspace, bail out */\n\t\tif (req->state == FUSE_REQ_PENDING) {\n\t\t\tlist_del(&req->list);\n\t\t\t__fuse_put_request(req);\n\t\t\treq->out.h.error = -EINTR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Either request is already in userspace, or it was forced.\n\t * Wait it out.\n\t */\n\tspin_unlock(&fc->lock);\n\twait_event(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n\n\tif (!req->aborted)\n\t\treturn;\n\n aborted:\n\tBUG_ON(req->state != FUSE_REQ_FINISHED);\n\tif (req->locked) {\n\t\t/* This is uninterruptible sleep, because data is\n\t\t   being copied to/from the buffers of req.  During\n\t\t   locked state, there mustn't be any filesystem\n\t\t   operation (e.g. page fault), since that could lead\n\t\t   to deadlock */\n\t\tspin_unlock(&fc->lock);\n\t\twait_event(req->waitq, !req->locked);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
  },
  {
    "function_name": "queue_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "426-431",
    "snippet": "static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fc->fasync",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fc->waitq"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->intr_entry",
            "&fc->interrupts"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tlist_add_tail(&req->intr_entry, &fc->interrupts);\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
  },
  {
    "function_name": "wait_answer_interruptible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "413-424",
    "snippet": "static void wait_answer_interruptible(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (signal_pending(current))\n\t\treturn;\n\n\tspin_unlock(&fc->lock);\n\twait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "req->waitq",
            "req->state == FUSE_REQ_FINISHED"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void wait_answer_interruptible(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tif (signal_pending(current))\n\t\treturn;\n\n\tspin_unlock(&fc->lock);\n\twait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);\n\tspin_lock(&fc->lock);\n}"
  },
  {
    "function_name": "request_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "379-411",
    "snippet": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end",
          "args": [
            "fc",
            "req"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "end_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2089-2100",
          "snippet": "static void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void end_requests(struct fuse_conn *fc, struct list_head *head)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct fuse_req *req;\n\t\treq = list_entry(head->next, struct fuse_req, list);\n\t\treq->out.h.error = -ECONNABORTED;\n\t\trequest_end(fc, req);\n\t\tspin_lock(&fc->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&req->waitq"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_bg_queue",
          "args": [
            "fc"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "flush_bg_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "355-367",
          "snippet": "static void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bdi_congested",
          "args": [
            "&fc->bdi",
            "BLK_RW_ASYNC"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bdi_congested",
          "args": [
            "&fc->bdi",
            "BLK_RW_SYNC"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->intr_entry"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void request_end(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n{\n\tvoid (*end) (struct fuse_conn *, struct fuse_req *) = req->end;\n\treq->end = NULL;\n\tlist_del(&req->list);\n\tlist_del(&req->intr_entry);\n\treq->state = FUSE_REQ_FINISHED;\n\tif (req->background) {\n\t\treq->background = 0;\n\n\t\tif (fc->num_background == fc->max_background)\n\t\t\tfc->blocked = 0;\n\n\t\t/* Wake up next waiter, if any */\n\t\tif (!fc->blocked && waitqueue_active(&fc->blocked_waitq))\n\t\t\twake_up(&fc->blocked_waitq);\n\n\t\tif (fc->num_background == fc->congestion_threshold &&\n\t\t    fc->connected && fc->bdi_initialized) {\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t}\n\tspin_unlock(&fc->lock);\n\twake_up(&req->waitq);\n\tif (end)\n\t\tend(fc, req);\n\tfuse_put_request(fc, req);\n}"
  },
  {
    "function_name": "flush_bg_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "355-367",
    "snippet": "static void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "queue_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "323-335",
          "snippet": "static void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_unique",
          "args": [
            "fc"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "313-321",
          "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->list"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fc->bg_queue.next",
            "structfuse_req",
            "list"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fc->bg_queue"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void flush_bg_queue(struct fuse_conn *fc)\n{\n\twhile (fc->active_background < fc->max_background &&\n\t       !list_empty(&fc->bg_queue)) {\n\t\tstruct fuse_req *req;\n\n\t\treq = list_entry(fc->bg_queue.next, struct fuse_req, list);\n\t\tlist_del(&req->list);\n\t\tfc->active_background++;\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t}\n}"
  },
  {
    "function_name": "fuse_queue_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "337-353",
    "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fc->fasync",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fc->waitq"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "queue_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "323-335",
    "snippet": "static void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fc->fasync",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fc->waitq"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->list",
            "&fc->pending"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len_args",
          "args": [
            "req->in.numargs",
            "(struct fuse_arg *) req->in.args"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "len_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "302-311",
          "snippet": "static unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void queue_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}"
  },
  {
    "function_name": "fuse_get_unique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "313-321",
    "snippet": "static u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_get_unique(struct fuse_conn *fc)\n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}"
  },
  {
    "function_name": "len_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "302-311",
    "snippet": "static unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic unsigned len_args(unsigned numargs, struct fuse_arg *args)\n{\n\tunsigned nbytes = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < numargs; i++)\n\t\tnbytes += args[i].size;\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "fuse_put_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "277-299",
    "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "req"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_reserved_req",
          "args": [
            "fc",
            "req"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "put_reserved_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "231-243",
          "snippet": "static void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct file *file = req->stolen_file;\n\tstruct fuse_file *ff = file->private_data;\n\n\tspin_lock(&fc->lock);\n\tfuse_request_init(req, req->pages, req->page_descs, req->max_pages);\n\tBUG_ON(ff->reserved_req);\n\tff->reserved_req = req;\n\twake_up_all(&fc->reserved_req_waitq);\n\tspin_unlock(&fc->lock);\n\tfput(file);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct file *file = req->stolen_file;\n\tstruct fuse_file *ff = file->private_data;\n\n\tspin_lock(&fc->lock);\n\tfuse_request_init(req, req->pages, req->page_descs, req->max_pages);\n\tBUG_ON(ff->reserved_req);\n\tff->reserved_req = req;\n\twake_up_all(&fc->reserved_req_waitq);\n\tspin_unlock(&fc->lock);\n\tfput(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "req->background"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&req->count"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
  },
  {
    "function_name": "fuse_get_req_nofail_nopages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "258-275",
    "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_req_init_context",
          "args": [
            "req"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_req_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "127-132",
          "snippet": "static void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reserved_req",
          "args": [
            "fc",
            "file"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "get_reserved_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "208-226",
          "snippet": "static struct fuse_req *get_reserved_req(struct fuse_conn *fc,\n\t\t\t\t\t struct file *file)\n{\n\tstruct fuse_req *req = NULL;\n\tstruct fuse_file *ff = file->private_data;\n\n\tdo {\n\t\twait_event(fc->reserved_req_waitq, ff->reserved_req);\n\t\tspin_lock(&fc->lock);\n\t\tif (ff->reserved_req) {\n\t\t\treq = ff->reserved_req;\n\t\t\tff->reserved_req = NULL;\n\t\t\treq->stolen_file = get_file(file);\n\t\t}\n\t\tspin_unlock(&fc->lock);\n\t} while (!req);\n\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *get_reserved_req(struct fuse_conn *fc,\n\t\t\t\t\t struct file *file)\n{\n\tstruct fuse_req *req = NULL;\n\tstruct fuse_file *ff = file->private_data;\n\n\tdo {\n\t\twait_event(fc->reserved_req_waitq, ff->reserved_req);\n\t\tspin_lock(&fc->lock);\n\t\tif (ff->reserved_req) {\n\t\t\treq = ff->reserved_req;\n\t\t\tff->reserved_req = NULL;\n\t\t\treq->stolen_file = get_file(file);\n\t\t}\n\t\tspin_unlock(&fc->lock);\n\t} while (!req);\n\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc",
          "args": [
            "0"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fc->blocked_waitq",
            "fc->initialized"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
  },
  {
    "function_name": "put_reserved_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "231-243",
    "snippet": "static void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct file *file = req->stolen_file;\n\tstruct fuse_file *ff = file->private_data;\n\n\tspin_lock(&fc->lock);\n\tfuse_request_init(req, req->pages, req->page_descs, req->max_pages);\n\tBUG_ON(ff->reserved_req);\n\tff->reserved_req = req;\n\twake_up_all(&fc->reserved_req_waitq);\n\tspin_unlock(&fc->lock);\n\tfput(file);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&fc->reserved_req_waitq"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ff->reserved_req"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_init",
          "args": [
            "req",
            "req->pages",
            "req->page_descs",
            "req->max_pages"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "38-52",
          "snippet": "static void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct file *file = req->stolen_file;\n\tstruct fuse_file *ff = file->private_data;\n\n\tspin_lock(&fc->lock);\n\tfuse_request_init(req, req->pages, req->page_descs, req->max_pages);\n\tBUG_ON(ff->reserved_req);\n\tff->reserved_req = req;\n\twake_up_all(&fc->reserved_req_waitq);\n\tspin_unlock(&fc->lock);\n\tfput(file);\n}"
  },
  {
    "function_name": "get_reserved_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "208-226",
    "snippet": "static struct fuse_req *get_reserved_req(struct fuse_conn *fc,\n\t\t\t\t\t struct file *file)\n{\n\tstruct fuse_req *req = NULL;\n\tstruct fuse_file *ff = file->private_data;\n\n\tdo {\n\t\twait_event(fc->reserved_req_waitq, ff->reserved_req);\n\t\tspin_lock(&fc->lock);\n\t\tif (ff->reserved_req) {\n\t\t\treq = ff->reserved_req;\n\t\t\tff->reserved_req = NULL;\n\t\t\treq->stolen_file = get_file(file);\n\t\t}\n\t\tspin_unlock(&fc->lock);\n\t} while (!req);\n\n\treturn req;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fc->reserved_req_waitq",
            "ff->reserved_req"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *get_reserved_req(struct fuse_conn *fc,\n\t\t\t\t\t struct file *file)\n{\n\tstruct fuse_req *req = NULL;\n\tstruct fuse_file *ff = file->private_data;\n\n\tdo {\n\t\twait_event(fc->reserved_req_waitq, ff->reserved_req);\n\t\tspin_lock(&fc->lock);\n\t\tif (ff->reserved_req) {\n\t\t\treq = ff->reserved_req;\n\t\t\tff->reserved_req = NULL;\n\t\t\treq->stolen_file = get_file(file);\n\t\t}\n\t\tspin_unlock(&fc->lock);\n\t} while (!req);\n\n\treturn req;\n}"
  },
  {
    "function_name": "fuse_get_req_for_background",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "196-200",
    "snippet": "struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_get_req",
          "args": [
            "fc",
            "npages",
            "true"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_get_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "146-188",
          "snippet": "static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}"
  },
  {
    "function_name": "fuse_get_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "190-193",
    "snippet": "struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, false);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_get_req",
          "args": [
            "fc",
            "npages",
            "false"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_get_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "146-188",
          "snippet": "static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, false);\n}"
  },
  {
    "function_name": "__fuse_get_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "146-188",
    "snippet": "static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_req_init_context",
          "args": [
            "req"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_req_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "127-132",
          "snippet": "static void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fc->blocked_waitq"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc",
          "args": [
            "npages"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_sigs",
          "args": [
            "&oldset"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "restore_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "110-113",
          "snippet": "static void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_exclusive",
          "args": [
            "fc->blocked_waitq",
            "!fuse_block_alloc(fc, for_background)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_block_alloc",
          "args": [
            "fc",
            "for_background"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_block_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "141-144",
          "snippet": "static bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)\n{\n\treturn !fc->initialized || (for_background && fc->blocked);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)\n{\n\treturn !fc->initialized || (for_background && fc->blocked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_sigs",
          "args": [
            "&oldset"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "block_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "102-108",
          "snippet": "static void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\tsigset_t oldset;\n\t\tint intr;\n\n\t\tblock_sigs(&oldset);\n\t\tintr = wait_event_interruptible_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background));\n\t\trestore_sigs(&oldset);\n\t\terr = -EINTR;\n\t\tif (intr)\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = for_background;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "fuse_block_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "141-144",
    "snippet": "static bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)\n{\n\treturn !fc->initialized || (for_background && fc->blocked);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)\n{\n\treturn !fc->initialized || (for_background && fc->blocked);\n}"
  },
  {
    "function_name": "fuse_set_initialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "134-139",
    "snippet": "void fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_initialized(struct fuse_conn *fc)\n{\n\t/* Make sure stores before this are seen on another CPU */\n\tsmp_wmb();\n\tfc->initialized = 1;\n}"
  },
  {
    "function_name": "fuse_req_init_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "127-132",
    "snippet": "static void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "current_fsgid()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "current_fsuid()"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_req_init_context(struct fuse_req *req)\n{\n\treq->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());\n\treq->in.h.pid = current->pid;\n}"
  },
  {
    "function_name": "__fuse_put_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "121-125",
    "snippet": "static void __fuse_put_request(struct fuse_req *req)\n{\n\tBUG_ON(atomic_read(&req->count) < 2);\n\tatomic_dec(&req->count);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&req->count"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&req->count) < 2"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&req->count"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_put_request(struct fuse_req *req)\n{\n\tBUG_ON(atomic_read(&req->count) < 2);\n\tatomic_dec(&req->count);\n}"
  },
  {
    "function_name": "__fuse_get_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "115-118",
    "snippet": "void __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&req->count"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}"
  },
  {
    "function_name": "restore_sigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "110-113",
    "snippet": "static void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "oldset",
            "NULL"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void restore_sigs(sigset_t *oldset)\n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}"
  },
  {
    "function_name": "block_sigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "102-108",
    "snippet": "static void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "oldset"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitsetinv",
          "args": [
            "&mask",
            "sigmask(SIGKILL)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void block_sigs(sigset_t *oldset)\n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}"
  },
  {
    "function_name": "fuse_request_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "93-100",
    "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_req_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fuse_req_cachep",
            "req"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req->page_descs"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req->pages"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
  },
  {
    "function_name": "fuse_request_alloc_nofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "88-91",
    "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_request_alloc",
          "args": [
            "npages",
            "GFP_NOFS"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_request_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "54-80",
          "snippet": "static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nstatic struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
  },
  {
    "function_name": "fuse_request_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "82-85",
    "snippet": "struct fuse_req *fuse_request_alloc(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_request_alloc",
          "args": [
            "npages",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_request_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "54-80",
          "snippet": "static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nstatic struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_KERNEL);\n}"
  },
  {
    "function_name": "__fuse_request_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "54-80",
    "snippet": "static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fuse_req_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_init",
          "args": [
            "req",
            "pages",
            "page_descs",
            "npages"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "38-52",
          "snippet": "static void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fuse_req_cachep",
            "req"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page_descs"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages",
            "flags"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fuse_req_cachep",
            "flags"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nstatic struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, flags);\n\tif (req) {\n\t\tstruct page **pages;\n\t\tstruct fuse_page_desc *page_descs;\n\n\t\tif (npages <= FUSE_REQ_INLINE_PAGES) {\n\t\t\tpages = req->inline_pages;\n\t\t\tpage_descs = req->inline_page_descs;\n\t\t} else {\n\t\t\tpages = kmalloc(sizeof(struct page *) * npages, flags);\n\t\t\tpage_descs = kmalloc(sizeof(struct fuse_page_desc) *\n\t\t\t\t\t     npages, flags);\n\t\t}\n\n\t\tif (!pages || !page_descs) {\n\t\t\tkfree(pages);\n\t\t\tkfree(page_descs);\n\t\t\tkmem_cache_free(fuse_req_cachep, req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfuse_request_init(req, pages, page_descs, npages);\n\t}\n\treturn req;\n}"
  },
  {
    "function_name": "fuse_request_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "38-52",
    "snippet": "static void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&req->count",
            "1"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&req->waitq"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->intr_entry"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->list"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_descs",
            "0",
            "sizeof(*page_descs) * npages"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pages",
            "0",
            "sizeof(*pages) * npages"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "req",
            "0",
            "sizeof(*req)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_request_init(struct fuse_req *req, struct page **pages,\n\t\t\t      struct fuse_page_desc *page_descs,\n\t\t\t      unsigned npages)\n{\n\tmemset(req, 0, sizeof(*req));\n\tmemset(pages, 0, sizeof(*pages) * npages);\n\tmemset(page_descs, 0, sizeof(*page_descs) * npages);\n\tINIT_LIST_HEAD(&req->list);\n\tINIT_LIST_HEAD(&req->intr_entry);\n\tinit_waitqueue_head(&req->waitq);\n\tatomic_set(&req->count, 1);\n\treq->pages = pages;\n\treq->page_descs = page_descs;\n\treq->max_pages = npages;\n}"
  },
  {
    "function_name": "fuse_get_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
    "lines": "29-36",
    "snippet": "static struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/splice.h>",
      "#include <linux/swap.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/uio.h>",
      "#include <linux/poll.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_get_conn(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn file->private_data;\n}"
  }
]