[
  {
    "function_name": "btrfs_destroy_delayed_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1978-1993",
    "snippet": "void btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "prev_node"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_delayed_node",
          "args": [
            "curr_node"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "224-249",
          "snippet": "static struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_kill_delayed_node",
          "args": [
            "curr_node"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_kill_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1905-1935",
          "snippet": "static void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_first_delayed_node",
          "args": [
            "delayed_root"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_first_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "205-222",
          "snippet": "static struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_root",
          "args": [
            "root"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "81-85",
          "snippet": "static inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}"
  },
  {
    "function_name": "btrfs_kill_all_delayed_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1949-1976",
    "snippet": "void btrfs_kill_all_delayed_nodes(struct btrfs_root *root)\n{\n\tu64 inode_id = 0;\n\tstruct btrfs_delayed_node *delayed_nodes[8];\n\tint i, n;\n\n\twhile (1) {\n\t\tspin_lock(&root->inode_lock);\n\t\tn = radix_tree_gang_lookup(&root->delayed_nodes_tree,\n\t\t\t\t\t   (void **)delayed_nodes, inode_id,\n\t\t\t\t\t   ARRAY_SIZE(delayed_nodes));\n\t\tif (!n) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tinode_id = delayed_nodes[n - 1]->inode_id + 1;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tatomic_inc(&delayed_nodes[i]->refs);\n\t\tspin_unlock(&root->inode_lock);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t__btrfs_kill_delayed_node(delayed_nodes[i]);\n\t\t\tbtrfs_release_delayed_node(delayed_nodes[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_nodes[i]"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_kill_delayed_node",
          "args": [
            "delayed_nodes[i]"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_kill_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1905-1935",
          "snippet": "static void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&delayed_nodes[i]->refs"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&root->delayed_nodes_tree",
            "(void **)delayed_nodes",
            "inode_id",
            "ARRAY_SIZE(delayed_nodes)"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "delayed_nodes"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_kill_all_delayed_nodes(struct btrfs_root *root)\n{\n\tu64 inode_id = 0;\n\tstruct btrfs_delayed_node *delayed_nodes[8];\n\tint i, n;\n\n\twhile (1) {\n\t\tspin_lock(&root->inode_lock);\n\t\tn = radix_tree_gang_lookup(&root->delayed_nodes_tree,\n\t\t\t\t\t   (void **)delayed_nodes, inode_id,\n\t\t\t\t\t   ARRAY_SIZE(delayed_nodes));\n\t\tif (!n) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tinode_id = delayed_nodes[n - 1]->inode_id + 1;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tatomic_inc(&delayed_nodes[i]->refs);\n\t\tspin_unlock(&root->inode_lock);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t__btrfs_kill_delayed_node(delayed_nodes[i]);\n\t\t\tbtrfs_release_delayed_node(delayed_nodes[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "btrfs_kill_delayed_inode_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1937-1947",
    "snippet": "void btrfs_kill_delayed_inode_items(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn;\n\n\t__btrfs_kill_delayed_node(delayed_node);\n\tbtrfs_release_delayed_node(delayed_node);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_kill_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_kill_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1905-1935",
          "snippet": "static void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_kill_delayed_inode_items(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn;\n\n\t__btrfs_kill_delayed_node(delayed_node);\n\tbtrfs_release_delayed_node(delayed_node);\n}"
  },
  {
    "function_name": "__btrfs_kill_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1905-1935",
    "snippet": "static void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_inode",
          "args": [
            "delayed_node"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1006-1019",
          "snippet": "static void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_inode_release_metadata",
          "args": [
            "root",
            "delayed_node"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_inode_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "699-713",
          "snippet": "static void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_iref",
          "args": [
            "delayed_node"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_iref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1021-1031",
          "snippet": "static void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "prev_item"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "prev_item"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_release_metadata",
          "args": [
            "root",
            "curr_item"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "569-583",
          "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_deletion_item",
          "args": [
            "delayed_node"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_deletion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "516-527",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_insertion_item",
          "args": [
            "delayed_node"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "503-514",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_kill_delayed_node(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_root *root = delayed_node->root;\n\tstruct btrfs_delayed_item *curr_item, *prev_item;\n\n\tmutex_lock(&delayed_node->mutex);\n\tcurr_item = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tcurr_item = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (curr_item) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr_item);\n\t\tprev_item = curr_item;\n\t\tcurr_item = __btrfs_next_delayed_item(prev_item);\n\t\tbtrfs_release_delayed_item(prev_item);\n\t}\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tbtrfs_release_delayed_iref(delayed_node);\n\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tbtrfs_delayed_inode_release_metadata(root, delayed_node);\n\t\tbtrfs_release_delayed_inode(delayed_node);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n}"
  },
  {
    "function_name": "btrfs_delayed_delete_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1862-1903",
    "snippet": "int btrfs_delayed_delete_inode_ref(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\t/*\n\t * we don't do delayed inode updates during log recovery because it\n\t * leads to enospc problems.  This means we also can't do\n\t * delayed inode refs\n\t */\n\tif (BTRFS_I(inode)->root->fs_info->log_root_recovering)\n\t\treturn -EAGAIN;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\t/*\n\t * We don't reserve space for inode ref deletion is because:\n\t * - We ONLY do async inode ref deletion for the inode who has only\n\t *   one link(i_nlink == 1), it means there is only one inode ref.\n\t *   And in most case, the inode ref and the inode item are in the\n\t *   same leaf, and we will deal with them at the same time.\n\t *   Since we are sure we will reserve the space for the inode item,\n\t *   it is unnecessary to reserve space for inode ref deletion.\n\t * - If the inode ref and the inode item are not in the same leaf,\n\t *   We also needn't worry about enospc problem, because we reserve\n\t *   much more space for the inode update than it needs.\n\t * - At the worst, we can steal some space from the global reservation.\n\t *   It is very rare.\n\t */\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tgoto release_node;\n\n\tset_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&BTRFS_I(inode)->root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&BTRFS_I(inode)->root->fs_info->delayed_root->items"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_DELAYED_NODE_DEL_IREF",
            "&delayed_node->flags"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_DEL_IREF",
            "&delayed_node->flags"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_or_create_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_or_create_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "121-162",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_delayed_delete_inode_ref(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\t/*\n\t * we don't do delayed inode updates during log recovery because it\n\t * leads to enospc problems.  This means we also can't do\n\t * delayed inode refs\n\t */\n\tif (BTRFS_I(inode)->root->fs_info->log_root_recovering)\n\t\treturn -EAGAIN;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\t/*\n\t * We don't reserve space for inode ref deletion is because:\n\t * - We ONLY do async inode ref deletion for the inode who has only\n\t *   one link(i_nlink == 1), it means there is only one inode ref.\n\t *   And in most case, the inode ref and the inode item are in the\n\t *   same leaf, and we will deal with them at the same time.\n\t *   Since we are sure we will reserve the space for the inode item,\n\t *   it is unnecessary to reserve space for inode ref deletion.\n\t * - If the inode ref and the inode item are not in the same leaf,\n\t *   We also needn't worry about enospc problem, because we reserve\n\t *   much more space for the inode update than it needs.\n\t * - At the worst, we can steal some space from the global reservation.\n\t *   It is very rare.\n\t */\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tgoto release_node;\n\n\tset_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&BTRFS_I(inode)->root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_delayed_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1831-1860",
    "snippet": "int btrfs_delayed_update_inode(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tint ret = 0;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tfill_stack_inode_item(trans, &delayed_node->inode_item, inode);\n\t\tgoto release_node;\n\t}\n\n\tret = btrfs_delayed_inode_reserve_metadata(trans, root, inode,\n\t\t\t\t\t\t   delayed_node);\n\tif (ret)\n\t\tgoto release_node;\n\n\tfill_stack_inode_item(trans, &delayed_node->inode_item, inode);\n\tset_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->fs_info->delayed_root->items"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_stack_inode_item",
          "args": [
            "trans",
            "&delayed_node->inode_item",
            "inode"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "fill_stack_inode_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1740-1777",
          "snippet": "static void fill_stack_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode_item *inode_item,\n\t\t\t\t  struct inode *inode)\n{\n\tbtrfs_set_stack_inode_uid(inode_item, i_uid_read(inode));\n\tbtrfs_set_stack_inode_gid(inode_item, i_gid_read(inode));\n\tbtrfs_set_stack_inode_size(inode_item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_stack_inode_mode(inode_item, inode->i_mode);\n\tbtrfs_set_stack_inode_nlink(inode_item, inode->i_nlink);\n\tbtrfs_set_stack_inode_nbytes(inode_item, inode_get_bytes(inode));\n\tbtrfs_set_stack_inode_generation(inode_item,\n\t\t\t\t\t BTRFS_I(inode)->generation);\n\tbtrfs_set_stack_inode_sequence(inode_item, inode->i_version);\n\tbtrfs_set_stack_inode_transid(inode_item, trans->transid);\n\tbtrfs_set_stack_inode_rdev(inode_item, inode->i_rdev);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_I(inode)->flags);\n\tbtrfs_set_stack_inode_block_group(inode_item, 0);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_nsec);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void fill_stack_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode_item *inode_item,\n\t\t\t\t  struct inode *inode)\n{\n\tbtrfs_set_stack_inode_uid(inode_item, i_uid_read(inode));\n\tbtrfs_set_stack_inode_gid(inode_item, i_gid_read(inode));\n\tbtrfs_set_stack_inode_size(inode_item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_stack_inode_mode(inode_item, inode->i_mode);\n\tbtrfs_set_stack_inode_nlink(inode_item, inode->i_nlink);\n\tbtrfs_set_stack_inode_nbytes(inode_item, inode_get_bytes(inode));\n\tbtrfs_set_stack_inode_generation(inode_item,\n\t\t\t\t\t BTRFS_I(inode)->generation);\n\tbtrfs_set_stack_inode_sequence(inode_item, inode->i_version);\n\tbtrfs_set_stack_inode_transid(inode_item, trans->transid);\n\tbtrfs_set_stack_inode_rdev(inode_item, inode->i_rdev);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_I(inode)->flags);\n\tbtrfs_set_stack_inode_block_group(inode_item, 0);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_inode_reserve_metadata",
          "args": [
            "trans",
            "root",
            "inode",
            "delayed_node"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_inode_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "585-697",
          "snippet": "static int btrfs_delayed_inode_reserve_metadata(\n\t\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\tbool release = false;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\n\t/*\n\t * btrfs_dirty_inode will update the inode under btrfs_join_transaction\n\t * which doesn't reserve space for speed.  This is a problem since we\n\t * still need to reserve space for this update, so try to reserve the\n\t * space.\n\t *\n\t * Now if src_rsv == delalloc_block_rsv we'll let it just steal since\n\t * we're accounted for.\n\t */\n\tif (!src_rsv || (!trans->bytes_reserved &&\n\t\t\t src_rsv->type != BTRFS_BLOCK_RSV_DELALLOC)) {\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\t/*\n\t\t * Since we're under a transaction reserve_metadata_bytes could\n\t\t * try to commit the transaction which will make it return\n\t\t * EAGAIN to make us stop the transaction we have, so return\n\t\t * ENOSPC instead so that btrfs_dirty_inode knows what to do.\n\t\t */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOSPC;\n\t\tif (!ret) {\n\t\t\tnode->bytes_reserved = num_bytes;\n\t\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t\t      \"delayed_inode\",\n\t\t\t\t\t\t      btrfs_ino(inode),\n\t\t\t\t\t\t      num_bytes, 1);\n\t\t}\n\t\treturn ret;\n\t} else if (src_rsv->type == BTRFS_BLOCK_RSV_DELALLOC) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tif (test_and_clear_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t\t       &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\trelease = true;\n\t\t\tgoto migrate;\n\t\t}\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\t\t/* Ok we didn't have space pre-reserved.  This shouldn't happen\n\t\t * too often but it can happen if we do delalloc to an existing\n\t\t * inode which gets dirtied because of the time update, and then\n\t\t * isn't touched again until after the transaction commits and\n\t\t * then we try to write out the data.  First try to be nice and\n\t\t * reserve something strictly for us.  If not be a pain and try\n\t\t * to steal from the delalloc block rsv.\n\t\t */\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\t\tif (!WARN_ON(ret))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Ok this is a problem, let's just steal from the global rsv\n\t\t * since this really shouldn't happen that often.\n\t\t */\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->global_block_rsv,\n\t\t\t\t\t      dst_rsv, num_bytes);\n\t\tgoto out;\n\t}\n\nmigrate:\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\nout:\n\t/*\n\t * Migrate only takes a reservation, it doesn't touch the size of the\n\t * block_rsv.  This is to simplify people who don't normally have things\n\t * migrated from their block rsv.  If they go to release their\n\t * reservation, that will decrease the size as well, so if migrate\n\t * reduced size we'd end up with a negative size.  But for the\n\t * delalloc_meta_reserved stuff we will only know to drop 1 reservation,\n\t * but we could in fact do this reserve/migrate dance several times\n\t * between the time we did the original reservation and we'd clean it\n\t * up.  So to take care of this, release the space for the meta\n\t * reservation here.  I think it may be time for a documentation page on\n\t * how block rsvs. work.\n\t */\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 1);\n\t\tnode->bytes_reserved = num_bytes;\n\t}\n\n\tif (release) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 0);\n\t\tbtrfs_block_rsv_release(root, src_rsv, num_bytes);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delayed_inode_reserve_metadata(\n\t\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\tbool release = false;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\n\t/*\n\t * btrfs_dirty_inode will update the inode under btrfs_join_transaction\n\t * which doesn't reserve space for speed.  This is a problem since we\n\t * still need to reserve space for this update, so try to reserve the\n\t * space.\n\t *\n\t * Now if src_rsv == delalloc_block_rsv we'll let it just steal since\n\t * we're accounted for.\n\t */\n\tif (!src_rsv || (!trans->bytes_reserved &&\n\t\t\t src_rsv->type != BTRFS_BLOCK_RSV_DELALLOC)) {\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\t/*\n\t\t * Since we're under a transaction reserve_metadata_bytes could\n\t\t * try to commit the transaction which will make it return\n\t\t * EAGAIN to make us stop the transaction we have, so return\n\t\t * ENOSPC instead so that btrfs_dirty_inode knows what to do.\n\t\t */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOSPC;\n\t\tif (!ret) {\n\t\t\tnode->bytes_reserved = num_bytes;\n\t\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t\t      \"delayed_inode\",\n\t\t\t\t\t\t      btrfs_ino(inode),\n\t\t\t\t\t\t      num_bytes, 1);\n\t\t}\n\t\treturn ret;\n\t} else if (src_rsv->type == BTRFS_BLOCK_RSV_DELALLOC) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tif (test_and_clear_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t\t       &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\trelease = true;\n\t\t\tgoto migrate;\n\t\t}\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\t\t/* Ok we didn't have space pre-reserved.  This shouldn't happen\n\t\t * too often but it can happen if we do delalloc to an existing\n\t\t * inode which gets dirtied because of the time update, and then\n\t\t * isn't touched again until after the transaction commits and\n\t\t * then we try to write out the data.  First try to be nice and\n\t\t * reserve something strictly for us.  If not be a pain and try\n\t\t * to steal from the delalloc block rsv.\n\t\t */\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\t\tif (!WARN_ON(ret))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Ok this is a problem, let's just steal from the global rsv\n\t\t * since this really shouldn't happen that often.\n\t\t */\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->global_block_rsv,\n\t\t\t\t\t      dst_rsv, num_bytes);\n\t\tgoto out;\n\t}\n\nmigrate:\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\nout:\n\t/*\n\t * Migrate only takes a reservation, it doesn't touch the size of the\n\t * block_rsv.  This is to simplify people who don't normally have things\n\t * migrated from their block rsv.  If they go to release their\n\t * reservation, that will decrease the size as well, so if migrate\n\t * reduced size we'd end up with a negative size.  But for the\n\t * delalloc_meta_reserved stuff we will only know to drop 1 reservation,\n\t * but we could in fact do this reserve/migrate dance several times\n\t * between the time we did the original reservation and we'd clean it\n\t * up.  So to take care of this, release the space for the meta\n\t * reservation here.  I think it may be time for a documentation page on\n\t * how block rsvs. work.\n\t */\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 1);\n\t\tnode->bytes_reserved = num_bytes;\n\t}\n\n\tif (release) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 0);\n\t\tbtrfs_block_rsv_release(root, src_rsv, num_bytes);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_or_create_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_or_create_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "121-162",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_delayed_update_inode(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tint ret = 0;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tfill_stack_inode_item(trans, &delayed_node->inode_item, inode);\n\t\tgoto release_node;\n\t}\n\n\tret = btrfs_delayed_inode_reserve_metadata(trans, root, inode,\n\t\t\t\t\t\t   delayed_node);\n\tif (ret)\n\t\tgoto release_node;\n\n\tfill_stack_inode_item(trans, &delayed_node->inode_item, inode);\n\tset_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_fill_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1779-1829",
    "snippet": "int btrfs_fill_inode(struct inode *inode, u32 *rdev)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_inode_item *inode_item;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOENT;\n\t}\n\n\tinode_item = &delayed_node->inode_item;\n\n\ti_uid_write(inode, btrfs_stack_inode_uid(inode_item));\n\ti_gid_write(inode, btrfs_stack_inode_gid(inode_item));\n\tbtrfs_i_size_write(inode, btrfs_stack_inode_size(inode_item));\n\tinode->i_mode = btrfs_stack_inode_mode(inode_item);\n\tset_nlink(inode, btrfs_stack_inode_nlink(inode_item));\n\tinode_set_bytes(inode, btrfs_stack_inode_nbytes(inode_item));\n\tBTRFS_I(inode)->generation = btrfs_stack_inode_generation(inode_item);\n\tinode->i_version = btrfs_stack_inode_sequence(inode_item);\n\tinode->i_rdev = 0;\n\t*rdev = btrfs_stack_inode_rdev(inode_item);\n\tBTRFS_I(inode)->flags = btrfs_stack_inode_flags(inode_item);\n\n\tinode->i_atime.tv_sec = btrfs_stack_timespec_sec(&inode_item->atime);\n\tinode->i_atime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->atime);\n\n\tinode->i_mtime.tv_sec = btrfs_stack_timespec_sec(&inode_item->mtime);\n\tinode->i_mtime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->mtime);\n\n\tinode->i_ctime.tv_sec = btrfs_stack_timespec_sec(&inode_item->ctime);\n\tinode->i_ctime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->ctime);\n\n\tBTRFS_I(inode)->i_otime.tv_sec =\n\t\tbtrfs_stack_timespec_sec(&inode_item->otime);\n\tBTRFS_I(inode)->i_otime.tv_nsec =\n\t\tbtrfs_stack_timespec_nsec(&inode_item->otime);\n\n\tinode->i_generation = BTRFS_I(inode)->generation;\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_nsec",
          "args": [
            "&inode_item->otime"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_sec",
          "args": [
            "&inode_item->otime"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_nsec",
          "args": [
            "&inode_item->ctime"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_sec",
          "args": [
            "&inode_item->ctime"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_nsec",
          "args": [
            "&inode_item->mtime"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_sec",
          "args": [
            "&inode_item->mtime"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_nsec",
          "args": [
            "&inode_item->atime"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_timespec_sec",
          "args": [
            "&inode_item->atime"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_flags",
          "args": [
            "inode_item"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_rdev",
          "args": [
            "inode_item"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_sequence",
          "args": [
            "inode_item"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_generation",
          "args": [
            "inode_item"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "btrfs_stack_inode_nbytes(inode_item)"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_nbytes",
          "args": [
            "inode_item"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "btrfs_stack_inode_nlink(inode_item)"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_nlink",
          "args": [
            "inode_item"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_mode",
          "args": [
            "inode_item"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "inode",
            "btrfs_stack_inode_size(inode_item)"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_size",
          "args": [
            "inode_item"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "btrfs_stack_inode_gid(inode_item)"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_gid",
          "args": [
            "inode_item"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "btrfs_stack_inode_uid(inode_item)"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_inode_uid",
          "args": [
            "inode_item"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_fill_inode(struct inode *inode, u32 *rdev)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_inode_item *inode_item;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOENT;\n\t}\n\n\tinode_item = &delayed_node->inode_item;\n\n\ti_uid_write(inode, btrfs_stack_inode_uid(inode_item));\n\ti_gid_write(inode, btrfs_stack_inode_gid(inode_item));\n\tbtrfs_i_size_write(inode, btrfs_stack_inode_size(inode_item));\n\tinode->i_mode = btrfs_stack_inode_mode(inode_item);\n\tset_nlink(inode, btrfs_stack_inode_nlink(inode_item));\n\tinode_set_bytes(inode, btrfs_stack_inode_nbytes(inode_item));\n\tBTRFS_I(inode)->generation = btrfs_stack_inode_generation(inode_item);\n\tinode->i_version = btrfs_stack_inode_sequence(inode_item);\n\tinode->i_rdev = 0;\n\t*rdev = btrfs_stack_inode_rdev(inode_item);\n\tBTRFS_I(inode)->flags = btrfs_stack_inode_flags(inode_item);\n\n\tinode->i_atime.tv_sec = btrfs_stack_timespec_sec(&inode_item->atime);\n\tinode->i_atime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->atime);\n\n\tinode->i_mtime.tv_sec = btrfs_stack_timespec_sec(&inode_item->mtime);\n\tinode->i_mtime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->mtime);\n\n\tinode->i_ctime.tv_sec = btrfs_stack_timespec_sec(&inode_item->ctime);\n\tinode->i_ctime.tv_nsec = btrfs_stack_timespec_nsec(&inode_item->ctime);\n\n\tBTRFS_I(inode)->i_otime.tv_sec =\n\t\tbtrfs_stack_timespec_sec(&inode_item->otime);\n\tBTRFS_I(inode)->i_otime.tv_nsec =\n\t\tbtrfs_stack_timespec_nsec(&inode_item->otime);\n\n\tinode->i_generation = BTRFS_I(inode)->generation;\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_stack_inode_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1740-1777",
    "snippet": "static void fill_stack_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode_item *inode_item,\n\t\t\t\t  struct inode *inode)\n{\n\tbtrfs_set_stack_inode_uid(inode_item, i_uid_read(inode));\n\tbtrfs_set_stack_inode_gid(inode_item, i_gid_read(inode));\n\tbtrfs_set_stack_inode_size(inode_item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_stack_inode_mode(inode_item, inode->i_mode);\n\tbtrfs_set_stack_inode_nlink(inode_item, inode->i_nlink);\n\tbtrfs_set_stack_inode_nbytes(inode_item, inode_get_bytes(inode));\n\tbtrfs_set_stack_inode_generation(inode_item,\n\t\t\t\t\t BTRFS_I(inode)->generation);\n\tbtrfs_set_stack_inode_sequence(inode_item, inode->i_version);\n\tbtrfs_set_stack_inode_transid(inode_item, trans->transid);\n\tbtrfs_set_stack_inode_rdev(inode_item, inode->i_rdev);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_I(inode)->flags);\n\tbtrfs_set_stack_inode_block_group(inode_item, 0);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_nsec);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&inode_item->otime",
            "BTRFS_I(inode)->i_otime.tv_nsec"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&inode_item->otime",
            "BTRFS_I(inode)->i_otime.tv_sec"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&inode_item->ctime",
            "inode->i_ctime.tv_nsec"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&inode_item->ctime",
            "inode->i_ctime.tv_sec"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&inode_item->mtime",
            "inode->i_mtime.tv_nsec"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&inode_item->mtime",
            "inode->i_mtime.tv_sec"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&inode_item->atime",
            "inode->i_atime.tv_nsec"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&inode_item->atime",
            "inode->i_atime.tv_sec"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_block_group",
          "args": [
            "inode_item",
            "0"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_flags",
          "args": [
            "inode_item",
            "BTRFS_I(inode)->flags"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_rdev",
          "args": [
            "inode_item",
            "inode->i_rdev"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_transid",
          "args": [
            "inode_item",
            "trans->transid"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_sequence",
          "args": [
            "inode_item",
            "inode->i_version"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_generation",
          "args": [
            "inode_item",
            "BTRFS_I(inode)->generation"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nbytes",
          "args": [
            "inode_item",
            "inode_get_bytes(inode)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_get_bytes",
          "args": [
            "inode"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "inode_get_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "491-499",
          "snippet": "loff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nloff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nlink",
          "args": [
            "inode_item",
            "inode->i_nlink"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_mode",
          "args": [
            "inode_item",
            "inode->i_mode"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_size",
          "args": [
            "inode_item",
            "BTRFS_I(inode)->disk_i_size"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_gid",
          "args": [
            "inode_item",
            "i_gid_read(inode)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_uid",
          "args": [
            "inode_item",
            "i_uid_read(inode)"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void fill_stack_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode_item *inode_item,\n\t\t\t\t  struct inode *inode)\n{\n\tbtrfs_set_stack_inode_uid(inode_item, i_uid_read(inode));\n\tbtrfs_set_stack_inode_gid(inode_item, i_gid_read(inode));\n\tbtrfs_set_stack_inode_size(inode_item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_stack_inode_mode(inode_item, inode->i_mode);\n\tbtrfs_set_stack_inode_nlink(inode_item, inode->i_nlink);\n\tbtrfs_set_stack_inode_nbytes(inode_item, inode_get_bytes(inode));\n\tbtrfs_set_stack_inode_generation(inode_item,\n\t\t\t\t\t BTRFS_I(inode)->generation);\n\tbtrfs_set_stack_inode_sequence(inode_item, inode->i_version);\n\tbtrfs_set_stack_inode_transid(inode_item, trans->transid);\n\tbtrfs_set_stack_inode_rdev(inode_item, inode->i_rdev);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_I(inode)->flags);\n\tbtrfs_set_stack_inode_block_group(inode_item, 0);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec);\n\n\tbtrfs_set_stack_timespec_sec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&inode_item->otime,\n\t\t\t\t     BTRFS_I(inode)->i_otime.tv_nsec);\n}"
  },
  {
    "function_name": "btrfs_readdir_delayed_dir_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1691-1738",
    "snippet": "int btrfs_readdir_delayed_dir_index(struct dir_context *ctx,\n\t\t\t\t    struct list_head *ins_list)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct btrfs_key location;\n\tchar *name;\n\tint name_len;\n\tint over = 0;\n\tunsigned char d_type;\n\n\tif (list_empty(ins_list))\n\t\treturn 0;\n\n\t/*\n\t * Changing the data of the delayed item is impossible. So\n\t * we needn't lock them. And we have held i_mutex of the\n\t * directory, nobody can delete any directory indexes now.\n\t */\n\tlist_for_each_entry_safe(curr, next, ins_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\n\t\tif (curr->key.offset < ctx->pos) {\n\t\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\t\tkfree(curr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx->pos = curr->key.offset;\n\n\t\tdi = (struct btrfs_dir_item *)curr->data;\n\t\tname = (char *)(di + 1);\n\t\tname_len = btrfs_stack_dir_name_len(di);\n\n\t\td_type = btrfs_filetype_table[di->type];\n\t\tbtrfs_disk_key_to_cpu(&location, &di->location);\n\n\t\tover = !dir_emit(ctx, name, name_len,\n\t\t\t       location.objectid, d_type);\n\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\n\t\tif (over)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "curr"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&curr->refs"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "name_len",
            "location.objectid",
            "d_type"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&location",
            "&di->location"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_dir_name_len",
          "args": [
            "di"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "curr"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&curr->refs"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&curr->readdir_list"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "ins_list",
            "readdir_list"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "ins_list"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_readdir_delayed_dir_index(struct dir_context *ctx,\n\t\t\t\t    struct list_head *ins_list)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct btrfs_key location;\n\tchar *name;\n\tint name_len;\n\tint over = 0;\n\tunsigned char d_type;\n\n\tif (list_empty(ins_list))\n\t\treturn 0;\n\n\t/*\n\t * Changing the data of the delayed item is impossible. So\n\t * we needn't lock them. And we have held i_mutex of the\n\t * directory, nobody can delete any directory indexes now.\n\t */\n\tlist_for_each_entry_safe(curr, next, ins_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\n\t\tif (curr->key.offset < ctx->pos) {\n\t\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\t\tkfree(curr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx->pos = curr->key.offset;\n\n\t\tdi = (struct btrfs_dir_item *)curr->data;\n\t\tname = (char *)(di + 1);\n\t\tname_len = btrfs_stack_dir_name_len(di);\n\n\t\td_type = btrfs_filetype_table[di->type];\n\t\tbtrfs_disk_key_to_cpu(&location, &di->location);\n\n\t\tover = !dir_emit(ctx, name, name_len,\n\t\t\t       location.objectid, d_type);\n\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\n\t\tif (over)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_should_delete_dir_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1660-1685",
    "snippet": "int btrfs_should_delete_dir_index(struct list_head *del_list,\n\t\t\t\t  u64 index)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint ret;\n\n\tif (list_empty(del_list))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(curr, next, del_list, readdir_list) {\n\t\tif (curr->key.offset > index)\n\t\t\tbreak;\n\n\t\tlist_del(&curr->readdir_list);\n\t\tret = (curr->key.offset == index);\n\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\n\t\tif (ret)\n\t\t\treturn 1;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "curr"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&curr->refs"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&curr->readdir_list"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "del_list",
            "readdir_list"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "del_list"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_should_delete_dir_index(struct list_head *del_list,\n\t\t\t\t  u64 index)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint ret;\n\n\tif (list_empty(del_list))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(curr, next, del_list, readdir_list) {\n\t\tif (curr->key.offset > index)\n\t\t\tbreak;\n\n\t\tlist_del(&curr->readdir_list);\n\t\tret = (curr->key.offset == index);\n\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\n\t\tif (ret)\n\t\t\treturn 1;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_put_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1642-1658",
    "snippet": "void btrfs_put_delayed_items(struct list_head *ins_list,\n\t\t\t     struct list_head *del_list)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\n\tlist_for_each_entry_safe(curr, next, ins_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, del_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "curr"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&curr->refs"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&curr->readdir_list"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "del_list",
            "readdir_list"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "curr"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&curr->refs"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "ins_list",
            "readdir_list"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_put_delayed_items(struct list_head *ins_list,\n\t\t\t     struct list_head *del_list)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\n\tlist_for_each_entry_safe(curr, next, ins_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\t}\n\n\tlist_for_each_entry_safe(curr, next, del_list, readdir_list) {\n\t\tlist_del(&curr->readdir_list);\n\t\tif (atomic_dec_and_test(&curr->refs))\n\t\t\tkfree(curr);\n\t}\n}"
  },
  {
    "function_name": "btrfs_get_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1605-1640",
    "snippet": "void btrfs_get_delayed_items(struct inode *inode, struct list_head *ins_list,\n\t\t\t     struct list_head *del_list)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_delayed_item *item;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn;\n\n\tmutex_lock(&delayed_node->mutex);\n\titem = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (item) {\n\t\tatomic_inc(&item->refs);\n\t\tlist_add_tail(&item->readdir_list, ins_list);\n\t\titem = __btrfs_next_delayed_item(item);\n\t}\n\n\titem = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (item) {\n\t\tatomic_inc(&item->refs);\n\t\tlist_add_tail(&item->readdir_list, del_list);\n\t\titem = __btrfs_next_delayed_item(item);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\t/*\n\t * This delayed node is still cached in the btrfs inode, so refs\n\t * must be > 1 now, and we needn't check it is going to be freed\n\t * or not.\n\t *\n\t * Besides that, this function is used to read dir, we do not\n\t * insert/delete delayed items in this period. So we also needn't\n\t * requeue or dequeue this delayed node.\n\t */\n\tatomic_dec(&delayed_node->refs);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&delayed_node->refs"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "item"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->readdir_list",
            "del_list"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&item->refs"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_deletion_item",
          "args": [
            "delayed_node"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_deletion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "516-527",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->readdir_list",
            "ins_list"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&item->refs"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_insertion_item",
          "args": [
            "delayed_node"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "503-514",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_get_delayed_items(struct inode *inode, struct list_head *ins_list,\n\t\t\t     struct list_head *del_list)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_delayed_item *item;\n\n\tdelayed_node = btrfs_get_delayed_node(inode);\n\tif (!delayed_node)\n\t\treturn;\n\n\tmutex_lock(&delayed_node->mutex);\n\titem = __btrfs_first_delayed_insertion_item(delayed_node);\n\twhile (item) {\n\t\tatomic_inc(&item->refs);\n\t\tlist_add_tail(&item->readdir_list, ins_list);\n\t\titem = __btrfs_next_delayed_item(item);\n\t}\n\n\titem = __btrfs_first_delayed_deletion_item(delayed_node);\n\twhile (item) {\n\t\tatomic_inc(&item->refs);\n\t\tlist_add_tail(&item->readdir_list, del_list);\n\t\titem = __btrfs_next_delayed_item(item);\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\t/*\n\t * This delayed node is still cached in the btrfs inode, so refs\n\t * must be > 1 now, and we needn't check it is going to be freed\n\t * or not.\n\t *\n\t * Besides that, this function is used to read dir, we do not\n\t * insert/delete delayed items in this period. So we also needn't\n\t * requeue or dequeue this delayed node.\n\t */\n\tatomic_dec(&delayed_node->refs);\n}"
  },
  {
    "function_name": "btrfs_inode_delayed_dir_index_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1583-1603",
    "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_delete_delayed_dir_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1531-1581",
    "snippet": "int btrfs_delete_delayed_dir_index(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root, struct inode *dir,\n\t\t\t\t   u64 index)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_delayed_item *item;\n\tstruct btrfs_key item_key;\n\tint ret;\n\n\tnode = btrfs_get_or_create_delayed_node(dir);\n\tif (IS_ERR(node))\n\t\treturn PTR_ERR(node);\n\n\titem_key.objectid = btrfs_ino(dir);\n\titem_key.type = BTRFS_DIR_INDEX_KEY;\n\titem_key.offset = index;\n\n\tret = btrfs_delete_delayed_insertion_item(root, node, &item_key);\n\tif (!ret)\n\t\tgoto end;\n\n\titem = btrfs_alloc_delayed_item(0);\n\tif (!item) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\titem->key = item_key;\n\n\tret = btrfs_delayed_item_reserve_metadata(trans, root, item);\n\t/*\n\t * we have reserved enough space when we start a new transaction,\n\t * so reserving metadata failure is impossible.\n\t */\n\tBUG_ON(ret);\n\n\tmutex_lock(&node->mutex);\n\tret = __btrfs_add_delayed_deletion_item(node, item);\n\tif (unlikely(ret)) {\n\t\tbtrfs_err(root->fs_info, \"err add delayed dir index item(index: %llu) \"\n\t\t\t\t\"into the deletion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\",\n\t\t\t\tindex, node->root->objectid, node->inode_id,\n\t\t\t\tret);\n\t\tBUG();\n\t}\n\tmutex_unlock(&node->mutex);\nend:\n\tbtrfs_release_delayed_node(node);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "node"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"err add delayed dir index item(index: %llu) \"\n\t\t\t\t\"into the deletion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\"",
            "index",
            "node->root->objectid",
            "node->inode_id",
            "ret"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_delayed_deletion_item",
          "args": [
            "node",
            "item"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_delayed_deletion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "456-461",
          "snippet": "static int __btrfs_add_delayed_deletion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t     struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_DELETION_ITEM);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_deletion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t     struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_DELETION_ITEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node->mutex"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_reserve_metadata",
          "args": [
            "trans",
            "root",
            "item"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "542-567",
          "snippet": "static int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_delayed_item",
          "args": [
            "0"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "315-327",
          "snippet": "static struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delete_delayed_insertion_item",
          "args": [
            "root",
            "node",
            "&item_key"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delete_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1512-1529",
          "snippet": "static int btrfs_delete_delayed_insertion_item(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_node *node,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\tmutex_lock(&node->mutex);\n\titem = __btrfs_lookup_delayed_insertion_item(node, key);\n\tif (!item) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 1;\n\t}\n\n\tbtrfs_delayed_item_release_metadata(root, item);\n\tbtrfs_release_delayed_item(item);\n\tmutex_unlock(&node->mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delete_delayed_insertion_item(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_node *node,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\tmutex_lock(&node->mutex);\n\titem = __btrfs_lookup_delayed_insertion_item(node, key);\n\tif (!item) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 1;\n\t}\n\n\tbtrfs_delayed_item_release_metadata(root, item);\n\tbtrfs_release_delayed_item(item);\n\tmutex_unlock(&node->mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "dir"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_delayed_dir_index_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1583-1603",
          "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_or_create_delayed_node",
          "args": [
            "dir"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_or_create_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "121-162",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_delete_delayed_dir_index(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root, struct inode *dir,\n\t\t\t\t   u64 index)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_delayed_item *item;\n\tstruct btrfs_key item_key;\n\tint ret;\n\n\tnode = btrfs_get_or_create_delayed_node(dir);\n\tif (IS_ERR(node))\n\t\treturn PTR_ERR(node);\n\n\titem_key.objectid = btrfs_ino(dir);\n\titem_key.type = BTRFS_DIR_INDEX_KEY;\n\titem_key.offset = index;\n\n\tret = btrfs_delete_delayed_insertion_item(root, node, &item_key);\n\tif (!ret)\n\t\tgoto end;\n\n\titem = btrfs_alloc_delayed_item(0);\n\tif (!item) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\titem->key = item_key;\n\n\tret = btrfs_delayed_item_reserve_metadata(trans, root, item);\n\t/*\n\t * we have reserved enough space when we start a new transaction,\n\t * so reserving metadata failure is impossible.\n\t */\n\tBUG_ON(ret);\n\n\tmutex_lock(&node->mutex);\n\tret = __btrfs_add_delayed_deletion_item(node, item);\n\tif (unlikely(ret)) {\n\t\tbtrfs_err(root->fs_info, \"err add delayed dir index item(index: %llu) \"\n\t\t\t\t\"into the deletion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\",\n\t\t\t\tindex, node->root->objectid, node->inode_id,\n\t\t\t\tret);\n\t\tBUG();\n\t}\n\tmutex_unlock(&node->mutex);\nend:\n\tbtrfs_release_delayed_node(node);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_delete_delayed_insertion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1512-1529",
    "snippet": "static int btrfs_delete_delayed_insertion_item(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_node *node,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\tmutex_lock(&node->mutex);\n\titem = __btrfs_lookup_delayed_insertion_item(node, key);\n\tif (!item) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 1;\n\t}\n\n\tbtrfs_delayed_item_release_metadata(root, item);\n\tbtrfs_release_delayed_item(item);\n\tmutex_unlock(&node->mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "item"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_release_metadata",
          "args": [
            "root",
            "item"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "569-583",
          "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_lookup_delayed_insertion_item",
          "args": [
            "node",
            "key"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_lookup_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "390-399",
          "snippet": "static struct btrfs_delayed_item *__btrfs_lookup_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\titem = __btrfs_lookup_delayed_item(&delayed_node->ins_root, key,\n\t\t\t\t\t   NULL, NULL);\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_lookup_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\titem = __btrfs_lookup_delayed_item(&delayed_node->ins_root, key,\n\t\t\t\t\t   NULL, NULL);\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node->mutex"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delete_delayed_insertion_item(struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_node *node,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\tmutex_lock(&node->mutex);\n\titem = __btrfs_lookup_delayed_insertion_item(node, key);\n\tif (!item) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 1;\n\t}\n\n\tbtrfs_delayed_item_release_metadata(root, item);\n\tbtrfs_release_delayed_item(item);\n\tmutex_unlock(&node->mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_insert_delayed_dir_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1454-1510",
    "snippet": "int btrfs_insert_delayed_dir_index(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root, const char *name,\n\t\t\t\t   int name_len, struct inode *dir,\n\t\t\t\t   struct btrfs_disk_key *disk_key, u8 type,\n\t\t\t\t   u64 index)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_delayed_item *delayed_item;\n\tstruct btrfs_dir_item *dir_item;\n\tint ret;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(dir);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\tdelayed_item = btrfs_alloc_delayed_item(sizeof(*dir_item) + name_len);\n\tif (!delayed_item) {\n\t\tret = -ENOMEM;\n\t\tgoto release_node;\n\t}\n\n\tdelayed_item->key.objectid = btrfs_ino(dir);\n\tdelayed_item->key.type = BTRFS_DIR_INDEX_KEY;\n\tdelayed_item->key.offset = index;\n\n\tdir_item = (struct btrfs_dir_item *)delayed_item->data;\n\tdir_item->location = *disk_key;\n\tbtrfs_set_stack_dir_transid(dir_item, trans->transid);\n\tbtrfs_set_stack_dir_data_len(dir_item, 0);\n\tbtrfs_set_stack_dir_name_len(dir_item, name_len);\n\tbtrfs_set_stack_dir_type(dir_item, type);\n\tmemcpy((char *)(dir_item + 1), name, name_len);\n\n\tret = btrfs_delayed_item_reserve_metadata(trans, root, delayed_item);\n\t/*\n\t * we have reserved enough space when we start a new transaction,\n\t * so reserving metadata failure is impossible\n\t */\n\tBUG_ON(ret);\n\n\n\tmutex_lock(&delayed_node->mutex);\n\tret = __btrfs_add_delayed_insertion_item(delayed_node, delayed_item);\n\tif (unlikely(ret)) {\n\t\tbtrfs_err(root->fs_info, \"err add delayed dir index item(name: %.*s) \"\n\t\t\t\t\"into the insertion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\",\n\t\t\t\tname_len, name, delayed_node->root->objectid,\n\t\t\t\tdelayed_node->inode_id, ret);\n\t\tBUG();\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\nrelease_node:\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"err add delayed dir index item(name: %.*s) \"\n\t\t\t\t\"into the insertion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\"",
            "name_len",
            "name",
            "delayed_node->root->objectid",
            "delayed_node->inode_id",
            "ret"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_delayed_insertion_item",
          "args": [
            "delayed_node",
            "delayed_item"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "449-454",
          "snippet": "static int __btrfs_add_delayed_insertion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t      struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_INSERTION_ITEM);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_insertion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t      struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_INSERTION_ITEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_reserve_metadata",
          "args": [
            "trans",
            "root",
            "delayed_item"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "542-567",
          "snippet": "static int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(dir_item + 1)",
            "name",
            "name_len"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_dir_type",
          "args": [
            "dir_item",
            "type"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_dir_name_len",
          "args": [
            "dir_item",
            "name_len"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_dir_data_len",
          "args": [
            "dir_item",
            "0"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_dir_transid",
          "args": [
            "dir_item",
            "trans->transid"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "dir"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_delayed_dir_index_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1583-1603",
          "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_delayed_item",
          "args": [
            "sizeof(*dir_item) + name_len"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "315-327",
          "snippet": "static struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "delayed_node"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_or_create_delayed_node",
          "args": [
            "dir"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_or_create_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "121-162",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_insert_delayed_dir_index(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root, const char *name,\n\t\t\t\t   int name_len, struct inode *dir,\n\t\t\t\t   struct btrfs_disk_key *disk_key, u8 type,\n\t\t\t\t   u64 index)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\tstruct btrfs_delayed_item *delayed_item;\n\tstruct btrfs_dir_item *dir_item;\n\tint ret;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(dir);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\tdelayed_item = btrfs_alloc_delayed_item(sizeof(*dir_item) + name_len);\n\tif (!delayed_item) {\n\t\tret = -ENOMEM;\n\t\tgoto release_node;\n\t}\n\n\tdelayed_item->key.objectid = btrfs_ino(dir);\n\tdelayed_item->key.type = BTRFS_DIR_INDEX_KEY;\n\tdelayed_item->key.offset = index;\n\n\tdir_item = (struct btrfs_dir_item *)delayed_item->data;\n\tdir_item->location = *disk_key;\n\tbtrfs_set_stack_dir_transid(dir_item, trans->transid);\n\tbtrfs_set_stack_dir_data_len(dir_item, 0);\n\tbtrfs_set_stack_dir_name_len(dir_item, name_len);\n\tbtrfs_set_stack_dir_type(dir_item, type);\n\tmemcpy((char *)(dir_item + 1), name, name_len);\n\n\tret = btrfs_delayed_item_reserve_metadata(trans, root, delayed_item);\n\t/*\n\t * we have reserved enough space when we start a new transaction,\n\t * so reserving metadata failure is impossible\n\t */\n\tBUG_ON(ret);\n\n\n\tmutex_lock(&delayed_node->mutex);\n\tret = __btrfs_add_delayed_insertion_item(delayed_node, delayed_item);\n\tif (unlikely(ret)) {\n\t\tbtrfs_err(root->fs_info, \"err add delayed dir index item(name: %.*s) \"\n\t\t\t\t\"into the insertion tree of the delayed node\"\n\t\t\t\t\"(root id: %llu, inode id: %llu, errno: %d)\",\n\t\t\t\tname_len, name, delayed_node->root->objectid,\n\t\t\t\tdelayed_node->inode_id, ret);\n\t\tBUG();\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\nrelease_node:\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_balance_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1426-1451",
    "snippet": "void btrfs_balance_delayed_items(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn;\n\n\tif (atomic_read(&delayed_root->items) >= BTRFS_DELAYED_WRITEBACK) {\n\t\tint seq;\n\t\tint ret;\n\n\t\tseq = atomic_read(&delayed_root->items_seq);\n\n\t\tret = btrfs_wq_run_delayed_node(delayed_root, root, 0);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\twait_event_interruptible(delayed_root->wait,\n\t\t\t\t\t could_end_wait(delayed_root, seq));\n\t\treturn;\n\t}\n\n\tbtrfs_wq_run_delayed_node(delayed_root, root, BTRFS_DELAYED_BATCH);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BTRFS_DELAYED_BATCH\t\t16",
      "#define BTRFS_DELAYED_BACKGROUND\t128",
      "#define BTRFS_DELAYED_WRITEBACK\t\t512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wq_run_delayed_node",
          "args": [
            "delayed_root",
            "root",
            "BTRFS_DELAYED_BATCH"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wq_run_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1385-1404",
          "snippet": "static int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 0;\n\n\tasync_work = kmalloc(sizeof(*async_work), GFP_NOFS);\n\tif (!async_work)\n\t\treturn -ENOMEM;\n\n\tasync_work->delayed_root = delayed_root;\n\tbtrfs_init_work(&async_work->work, btrfs_delayed_meta_helper,\n\t\t\tbtrfs_async_run_delayed_root, NULL, NULL);\n\tasync_work->nr = nr;\n\n\tbtrfs_queue_work(root->fs_info->delayed_workers, &async_work->work);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BACKGROUND\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 0;\n\n\tasync_work = kmalloc(sizeof(*async_work), GFP_NOFS);\n\tif (!async_work)\n\t\treturn -ENOMEM;\n\n\tasync_work->delayed_root = delayed_root;\n\tbtrfs_init_work(&async_work->work, btrfs_delayed_meta_helper,\n\t\t\tbtrfs_async_run_delayed_root, NULL, NULL);\n\tasync_work->nr = nr;\n\n\tbtrfs_queue_work(root->fs_info->delayed_workers, &async_work->work);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "delayed_root->wait",
            "could_end_wait(delayed_root, seq)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "could_end_wait",
          "args": [
            "delayed_root",
            "seq"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "could_end_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1413-1424",
          "snippet": "static int could_end_wait(struct btrfs_delayed_root *delayed_root, int seq)\n{\n\tint val = atomic_read(&delayed_root->items_seq);\n\n\tif (val < seq || val >= seq + BTRFS_DELAYED_BATCH)\n\t\treturn 1;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BATCH\t\t16",
            "#define BTRFS_DELAYED_BACKGROUND\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic int could_end_wait(struct btrfs_delayed_root *delayed_root, int seq)\n{\n\tint val = atomic_read(&delayed_root->items_seq);\n\n\tif (val < seq || val >= seq + BTRFS_DELAYED_BATCH)\n\t\treturn 1;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items_seq"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_root",
          "args": [
            "root"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "81-85",
          "snippet": "static inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n#define BTRFS_DELAYED_WRITEBACK\t\t512\n\nvoid btrfs_balance_delayed_items(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn;\n\n\tif (atomic_read(&delayed_root->items) >= BTRFS_DELAYED_WRITEBACK) {\n\t\tint seq;\n\t\tint ret;\n\n\t\tseq = atomic_read(&delayed_root->items_seq);\n\n\t\tret = btrfs_wq_run_delayed_node(delayed_root, root, 0);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\twait_event_interruptible(delayed_root->wait,\n\t\t\t\t\t could_end_wait(delayed_root, seq));\n\t\treturn;\n\t}\n\n\tbtrfs_wq_run_delayed_node(delayed_root, root, BTRFS_DELAYED_BATCH);\n}"
  },
  {
    "function_name": "could_end_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1413-1424",
    "snippet": "static int could_end_wait(struct btrfs_delayed_root *delayed_root, int seq)\n{\n\tint val = atomic_read(&delayed_root->items_seq);\n\n\tif (val < seq || val >= seq + BTRFS_DELAYED_BATCH)\n\t\treturn 1;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BTRFS_DELAYED_BATCH\t\t16",
      "#define BTRFS_DELAYED_BACKGROUND\t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items_seq"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic int could_end_wait(struct btrfs_delayed_root *delayed_root, int seq)\n{\n\tint val = atomic_read(&delayed_root->items_seq);\n\n\tif (val < seq || val >= seq + BTRFS_DELAYED_BATCH)\n\t\treturn 1;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_assert_delayed_root_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1406-1411",
    "snippet": "void btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_first_delayed_node(delayed_root)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_first_delayed_node",
          "args": [
            "delayed_root"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_first_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "205-222",
          "snippet": "static struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_root",
          "args": [
            "root"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "81-85",
          "snippet": "static inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}"
  },
  {
    "function_name": "btrfs_wq_run_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1385-1404",
    "snippet": "static int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 0;\n\n\tasync_work = kmalloc(sizeof(*async_work), GFP_NOFS);\n\tif (!async_work)\n\t\treturn -ENOMEM;\n\n\tasync_work->delayed_root = delayed_root;\n\tbtrfs_init_work(&async_work->work, btrfs_delayed_meta_helper,\n\t\t\tbtrfs_async_run_delayed_root, NULL, NULL);\n\tasync_work->nr = nr;\n\n\tbtrfs_queue_work(root->fs_info->delayed_workers, &async_work->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BTRFS_DELAYED_BACKGROUND\t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "root->fs_info->delayed_workers",
            "&async_work->work"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&async_work->work",
            "btrfs_delayed_meta_helper",
            "btrfs_async_run_delayed_root",
            "NULL",
            "NULL"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*async_work)",
            "GFP_NOFS"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn 0;\n\n\tasync_work = kmalloc(sizeof(*async_work), GFP_NOFS);\n\tif (!async_work)\n\t\treturn -ENOMEM;\n\n\tasync_work->delayed_root = delayed_root;\n\tbtrfs_init_work(&async_work->work, btrfs_delayed_meta_helper,\n\t\t\tbtrfs_async_run_delayed_root, NULL, NULL);\n\tasync_work->nr = nr;\n\n\tbtrfs_queue_work(root->fs_info->delayed_workers, &async_work->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_async_run_delayed_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1327-1382",
    "snippet": "static void btrfs_async_run_delayed_root(struct btrfs_work *work)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_delayed_node *delayed_node = NULL;\n\tstruct btrfs_root *root;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint total_done = 0;\n\n\tasync_work = container_of(work, struct btrfs_async_delayed_work, work);\n\tdelayed_root = async_work->delayed_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\tgoto out;\n\nagain:\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND / 2)\n\t\tgoto free_path;\n\n\tdelayed_node = btrfs_first_prepared_delayed_node(delayed_root);\n\tif (!delayed_node)\n\t\tgoto free_path;\n\n\tpath->leave_spinning = 1;\n\troot = delayed_node->root;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto release_path;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\t__btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\ttrans->block_rsv = block_rsv;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty_nodelay(root);\n\nrelease_path:\n\tbtrfs_release_path(path);\n\ttotal_done++;\n\n\tbtrfs_release_prepared_delayed_node(delayed_node);\n\tif (async_work->nr == 0 || total_done < async_work->nr)\n\t\tgoto again;\n\nfree_path:\n\tbtrfs_free_path(path);\nout:\n\twake_up(&delayed_root->wait);\n\tkfree(async_work);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BTRFS_DELAYED_BACKGROUND\t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "async_work"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&delayed_root->wait"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_prepared_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_prepared_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "309-313",
          "snippet": "static inline void btrfs_release_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty_nodelay",
          "args": [
            "root"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_commit_inode_delayed_items",
          "args": [
            "trans",
            "path",
            "delayed_node"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_commit_inode_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1133-1150",
          "snippet": "static inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_first_prepared_delayed_node",
          "args": [
            "delayed_root"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_first_prepared_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "289-307",
          "snippet": "static struct btrfs_delayed_node *btrfs_first_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->prepare_list))\n\t\tgoto out;\n\n\tp = delayed_root->prepare_list.next;\n\tlist_del_init(p);\n\tnode = list_entry(p, struct btrfs_delayed_node, p_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->prepare_list))\n\t\tgoto out;\n\n\tp = delayed_root->prepare_list.next;\n\tlist_del_init(p);\n\tnode = list_entry(p, struct btrfs_delayed_node, p_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_root->items"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_async_delayed_work",
            "work"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic void btrfs_async_run_delayed_root(struct btrfs_work *work)\n{\n\tstruct btrfs_async_delayed_work *async_work;\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_delayed_node *delayed_node = NULL;\n\tstruct btrfs_root *root;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint total_done = 0;\n\n\tasync_work = container_of(work, struct btrfs_async_delayed_work, work);\n\tdelayed_root = async_work->delayed_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\tgoto out;\n\nagain:\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND / 2)\n\t\tgoto free_path;\n\n\tdelayed_node = btrfs_first_prepared_delayed_node(delayed_root);\n\tif (!delayed_node)\n\t\tgoto free_path;\n\n\tpath->leave_spinning = 1;\n\troot = delayed_node->root;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto release_path;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\t__btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\ttrans->block_rsv = block_rsv;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty_nodelay(root);\n\nrelease_path:\n\tbtrfs_release_path(path);\n\ttotal_done++;\n\n\tbtrfs_release_prepared_delayed_node(delayed_node);\n\tif (async_work->nr == 0 || total_done < async_work->nr)\n\t\tgoto again;\n\nfree_path:\n\tbtrfs_free_path(path);\nout:\n\twake_up(&delayed_root->wait);\n\tkfree(async_work);\n}"
  },
  {
    "function_name": "btrfs_remove_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1309-1319",
    "snippet": "void btrfs_remove_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\tdelayed_node = ACCESS_ONCE(BTRFS_I(inode)->delayed_node);\n\tif (!delayed_node)\n\t\treturn;\n\n\tBTRFS_I(inode)->delayed_node = NULL;\n\tbtrfs_release_delayed_node(delayed_node);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "BTRFS_I(inode)->delayed_node"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_remove_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\tdelayed_node = ACCESS_ONCE(BTRFS_I(inode)->delayed_node);\n\tif (!delayed_node)\n\t\treturn;\n\n\tBTRFS_I(inode)->delayed_node = NULL;\n\tbtrfs_release_delayed_node(delayed_node);\n}"
  },
  {
    "function_name": "btrfs_commit_inode_delayed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1255-1307",
    "snippet": "int btrfs_commit_inode_delayed_inode(struct inode *inode)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\ttrans = btrfs_join_transaction(delayed_node->root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto trans_out;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags))\n\t\tret = __btrfs_update_delayed_inode(trans, delayed_node->root,\n\t\t\t\t\t\t   path, delayed_node);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&delayed_node->mutex);\n\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\ntrans_out:\n\tbtrfs_end_transaction(trans, delayed_node->root);\n\tbtrfs_btree_balance_dirty(delayed_node->root);\nout:\n\tbtrfs_release_delayed_node(delayed_node);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "delayed_node->root"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "delayed_node->root"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_update_delayed_inode",
          "args": [
            "trans",
            "delayed_node->root",
            "path",
            "delayed_node"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_update_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1033-1113",
          "snippet": "static int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "delayed_node->root"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_commit_inode_delayed_inode(struct inode *inode)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\ttrans = btrfs_join_transaction(delayed_node->root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto trans_out;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags))\n\t\tret = __btrfs_update_delayed_inode(trans, delayed_node->root,\n\t\t\t\t\t\t   path, delayed_node);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&delayed_node->mutex);\n\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\ntrans_out:\n\tbtrfs_end_transaction(trans, delayed_node->root);\n\tbtrfs_btree_balance_dirty(delayed_node->root);\nout:\n\tbtrfs_release_delayed_node(delayed_node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_commit_inode_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1217-1253",
    "snippet": "int btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!delayed_node->count) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tret = __btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\tbtrfs_release_delayed_node(delayed_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "delayed_node"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_commit_inode_delayed_items",
          "args": [
            "trans",
            "path",
            "delayed_node"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_commit_inode_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1133-1150",
          "snippet": "static inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!delayed_node->count) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tret = __btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\tbtrfs_release_delayed_node(delayed_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_run_delayed_items_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1211-1215",
    "snippet": "int btrfs_run_delayed_items_nr(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, int nr)\n{\n\treturn __btrfs_run_delayed_items(trans, root, nr);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_run_delayed_items",
          "args": [
            "trans",
            "root",
            "nr"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1158-1203",
          "snippet": "static int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items_nr(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, int nr)\n{\n\treturn __btrfs_run_delayed_items(trans, root, nr);\n}"
  },
  {
    "function_name": "btrfs_run_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1205-1209",
    "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_run_delayed_items",
          "args": [
            "trans",
            "root",
            "-1"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1158-1203",
          "snippet": "static int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
  },
  {
    "function_name": "__btrfs_run_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1158-1203",
    "snippet": "static int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_node",
          "args": [
            "curr_node"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "284-287",
          "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_delayed_node",
          "args": [
            "curr_node"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "224-249",
          "snippet": "static struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_commit_inode_delayed_items",
          "args": [
            "trans",
            "path",
            "curr_node"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_commit_inode_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1133-1150",
          "snippet": "static inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_first_delayed_node",
          "args": [
            "delayed_root"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_first_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "205-222",
          "snippet": "static struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_root",
          "args": [
            "root"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "81-85",
          "snippet": "static inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root, int nr)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret = 0;\n\tbool count = (nr > 0);\n\n\tif (trans->aborted)\n\t\treturn -EIO;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->delayed_block_rsv;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node && (!count || (count && nr--))) {\n\t\tret = __btrfs_commit_inode_delayed_items(trans, path,\n\t\t\t\t\t\t\t curr_node);\n\t\tif (ret) {\n\t\t\tbtrfs_release_delayed_node(curr_node);\n\t\t\tcurr_node = NULL;\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n\n\tif (curr_node)\n\t\tbtrfs_release_delayed_node(curr_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_commit_inode_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1133-1150",
    "snippet": "static inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_update_delayed_inode",
          "args": [
            "trans",
            "node->root",
            "path",
            "node"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1115-1131",
          "snippet": "static inline int btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t\t     struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tmutex_lock(&node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &node->flags)) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 0;\n\t}\n\n\tret = __btrfs_update_delayed_inode(trans, root, path, node);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t\t     struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tmutex_lock(&node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &node->flags)) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 0;\n\t}\n\n\tret = __btrfs_update_delayed_inode(trans, root, path, node);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delete_delayed_items",
          "args": [
            "trans",
            "path",
            "node->root",
            "node"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delete_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "961-1004",
          "snippet": "static int btrfs_delete_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_deletion_item(node);\n\tif (!curr)\n\t\tgoto delete_fail;\n\n\tret = btrfs_search_slot(trans, root, &curr->key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto delete_fail;\n\telse if (ret > 0) {\n\t\t/*\n\t\t * can't find the item which the node points to, so this node\n\t\t * is invalid, just drop it.\n\t\t */\n\t\tprev = curr;\n\t\tcurr = __btrfs_next_delayed_item(prev);\n\t\tbtrfs_release_delayed_item(prev);\n\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t\tif (curr) {\n\t\t\tmutex_unlock(&node->mutex);\n\t\t\tgoto do_again;\n\t\t} else\n\t\t\tgoto delete_fail;\n\t}\n\n\tbtrfs_batch_delete_items(trans, root, path, curr);\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ndelete_fail:\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delete_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_deletion_item(node);\n\tif (!curr)\n\t\tgoto delete_fail;\n\n\tret = btrfs_search_slot(trans, root, &curr->key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto delete_fail;\n\telse if (ret > 0) {\n\t\t/*\n\t\t * can't find the item which the node points to, so this node\n\t\t * is invalid, just drop it.\n\t\t */\n\t\tprev = curr;\n\t\tcurr = __btrfs_next_delayed_item(prev);\n\t\tbtrfs_release_delayed_item(prev);\n\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t\tif (curr) {\n\t\t\tmutex_unlock(&node->mutex);\n\t\t\tgoto do_again;\n\t\t} else\n\t\t\tgoto delete_fail;\n\t}\n\n\tbtrfs_batch_delete_items(trans, root, path, curr);\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ndelete_fail:\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_delayed_items",
          "args": [
            "trans",
            "path",
            "node->root",
            "node"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "859-896",
          "snippet": "static int btrfs_insert_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_insertion_item(node);\n\tif (!curr)\n\t\tgoto insert_end;\n\n\tret = btrfs_insert_delayed_item(trans, root, path, curr);\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\tgoto insert_end;\n\t}\n\n\tprev = curr;\n\tcurr = __btrfs_next_delayed_item(prev);\n\tif (curr && btrfs_is_continuous_delayed_item(prev, curr)) {\n\t\t/* insert the continuous items into the same leaf */\n\t\tpath->slots[0]++;\n\t\tbtrfs_batch_insert_items(root, path, curr);\n\t}\n\tbtrfs_release_delayed_item(prev);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ninsert_end:\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_insert_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_insertion_item(node);\n\tif (!curr)\n\t\tgoto insert_end;\n\n\tret = btrfs_insert_delayed_item(trans, root, path, curr);\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\tgoto insert_end;\n\t}\n\n\tprev = curr;\n\tcurr = __btrfs_next_delayed_item(prev);\n\tif (curr && btrfs_is_continuous_delayed_item(prev, curr)) {\n\t\t/* insert the continuous items into the same leaf */\n\t\tpath->slots[0]++;\n\t\tbtrfs_batch_insert_items(root, path, curr);\n\t}\n\tbtrfs_release_delayed_item(prev);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ninsert_end:\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int\n__btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tret = btrfs_insert_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delete_delayed_items(trans, path, node->root, node);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_update_delayed_inode(trans, node->root, path, node);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_update_delayed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1115-1131",
    "snippet": "static inline int btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t\t     struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tmutex_lock(&node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &node->flags)) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 0;\n\t}\n\n\tret = __btrfs_update_delayed_inode(trans, root, path, node);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_update_delayed_inode",
          "args": [
            "trans",
            "root",
            "path",
            "node"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_update_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1033-1113",
          "snippet": "static int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&node->flags"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node->mutex"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t\t     struct btrfs_delayed_node *node)\n{\n\tint ret;\n\n\tmutex_lock(&node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &node->flags)) {\n\t\tmutex_unlock(&node->mutex);\n\t\treturn 0;\n\t}\n\n\tret = __btrfs_update_delayed_inode(trans, root, path, node);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_update_delayed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1033-1113",
    "snippet": "static int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_inode",
          "args": [
            "node"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1006-1019",
          "snippet": "static void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_inode_release_metadata",
          "args": [
            "root",
            "node"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_inode_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "699-713",
          "snippet": "static void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_iref",
          "args": [
            "node"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_iref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1021-1031",
          "snippet": "static void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_DEL_IREF",
            "&node->flags"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "&node->inode_item",
            "(unsigned long)inode_item",
            "sizeof(struct btrfs_inode_item)"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_inode",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "mod"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "416-440",
          "snippet": "int btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t       *root, struct btrfs_path *path,\n\t\t       struct btrfs_key *location, int mod)\n{\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\n\tret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\n\tif (ret > 0 && location->type == BTRFS_ROOT_ITEM_KEY &&\n\t    location->offset == (u64)-1 && path->slots[0] != 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid == location->objectid &&\n\t\t    found_key.type == location->type) {\n\t\t\tpath->slots[0]--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t       *root, struct btrfs_path *path,\n\t\t       struct btrfs_key *location, int mod)\n{\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\n\tret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\n\tif (ret > 0 && location->type == BTRFS_ROOT_ITEM_KEY &&\n\t    location->offset == (u64)-1 && path->slots[0] != 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid == location->objectid &&\n\t\t    found_key.type == location->type) {\n\t\t\tpath->slots[0]--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tint mod;\n\tint ret;\n\n\tkey.objectid = node->inode_id;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tmod = -1;\n\telse\n\t\tmod = 1;\n\n\tret = btrfs_lookup_inode(trans, root, path, &key, mod);\n\tif (ret > 0) {\n\t\tbtrfs_release_path(path);\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tinode_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\twrite_extent_buffer(leaf, &node->inode_item, (unsigned long)inode_item,\n\t\t\t    sizeof(struct btrfs_inode_item));\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (!test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &node->flags))\n\t\tgoto no_iref;\n\n\tpath->slots[0]++;\n\tif (path->slots[0] >= btrfs_header_nritems(leaf))\n\t\tgoto search;\nagain:\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.objectid != node->inode_id)\n\t\tgoto out;\n\n\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\n\t/*\n\t * Delayed iref deletion is for the inode who has only one link,\n\t * so there is only one iref. The case that several irefs are\n\t * in the same item doesn't exist.\n\t */\n\tbtrfs_del_item(trans, root, path);\nout:\n\tbtrfs_release_delayed_iref(node);\nno_iref:\n\tbtrfs_release_path(path);\nerr_out:\n\tbtrfs_delayed_inode_release_metadata(root, node);\n\tbtrfs_release_delayed_inode(node);\n\n\treturn ret;\n\nsearch:\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = -1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tASSERT(ret);\n\n\tret = 0;\n\tleaf = path->nodes[0];\n\tpath->slots[0]--;\n\tgoto again;\n}"
  },
  {
    "function_name": "btrfs_release_delayed_iref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1021-1031",
    "snippet": "static void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_one_item",
          "args": [
            "delayed_root"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "finish_one_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "463-470",
          "snippet": "static void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BATCH\t\t16",
            "#define BTRFS_DELAYED_BACKGROUND\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_DELAYED_NODE_DEL_IREF",
            "&delayed_node->flags"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "delayed_node->root"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_iref(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tASSERT(delayed_node->root);\n\tclear_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count--;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\tfinish_one_item(delayed_root);\n}"
  },
  {
    "function_name": "btrfs_release_delayed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "1006-1019",
    "snippet": "static void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_one_item",
          "args": [
            "delayed_root"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "finish_one_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "463-470",
          "snippet": "static void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BATCH\t\t16",
            "#define BTRFS_DELAYED_BACKGROUND\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!delayed_node->root"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_INODE_DIRTY",
            "&delayed_node->flags"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_inode(struct btrfs_delayed_node *delayed_node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (delayed_node &&\n\t    test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tBUG_ON(!delayed_node->root);\n\t\tclear_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags);\n\t\tdelayed_node->count--;\n\n\t\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\t\tfinish_one_item(delayed_root);\n\t}\n}"
  },
  {
    "function_name": "btrfs_delete_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "961-1004",
    "snippet": "static int btrfs_delete_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_deletion_item(node);\n\tif (!curr)\n\t\tgoto delete_fail;\n\n\tret = btrfs_search_slot(trans, root, &curr->key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto delete_fail;\n\telse if (ret > 0) {\n\t\t/*\n\t\t * can't find the item which the node points to, so this node\n\t\t * is invalid, just drop it.\n\t\t */\n\t\tprev = curr;\n\t\tcurr = __btrfs_next_delayed_item(prev);\n\t\tbtrfs_release_delayed_item(prev);\n\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t\tif (curr) {\n\t\t\tmutex_unlock(&node->mutex);\n\t\t\tgoto do_again;\n\t\t} else\n\t\t\tgoto delete_fail;\n\t}\n\n\tbtrfs_batch_delete_items(trans, root, path, curr);\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ndelete_fail:\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_batch_delete_items",
          "args": [
            "trans",
            "root",
            "path",
            "curr"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_batch_delete_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "898-959",
          "snippet": "static int btrfs_batch_delete_items(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct list_head head;\n\tint nitems, i, last_item;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\n\ti = path->slots[0];\n\tlast_item = btrfs_header_nritems(leaf) - 1;\n\tif (i > last_item)\n\t\treturn -ENOENT;\t/* FIXME: Is errno suitable? */\n\n\tnext = item;\n\tINIT_LIST_HEAD(&head);\n\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\tnitems = 0;\n\t/*\n\t * count the number of the dir index items that we can delete in batch\n\t */\n\twhile (btrfs_comp_cpu_keys(&next->key, &key) == 0) {\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\n\t\ti++;\n\t\tif (i > last_item)\n\t\t\tbreak;\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t}\n\n\tif (!nitems)\n\t\treturn 0;\n\n\tret = btrfs_del_items(trans, root, path, path->slots[0], nitems);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_batch_delete_items(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct list_head head;\n\tint nitems, i, last_item;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\n\ti = path->slots[0];\n\tlast_item = btrfs_header_nritems(leaf) - 1;\n\tif (i > last_item)\n\t\treturn -ENOENT;\t/* FIXME: Is errno suitable? */\n\n\tnext = item;\n\tINIT_LIST_HEAD(&head);\n\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\tnitems = 0;\n\t/*\n\t * count the number of the dir index items that we can delete in batch\n\t */\n\twhile (btrfs_comp_cpu_keys(&next->key, &key) == 0) {\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\n\t\ti++;\n\t\tif (i > last_item)\n\t\t\tbreak;\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t}\n\n\tif (!nitems)\n\t\treturn 0;\n\n\tret = btrfs_del_items(trans, root, path, path->slots[0], nitems);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "prev"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "prev"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&curr->key",
            "path",
            "-1",
            "1"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_deletion_item",
          "args": [
            "node"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_deletion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "516-527",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node->mutex"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delete_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_deletion_item(node);\n\tif (!curr)\n\t\tgoto delete_fail;\n\n\tret = btrfs_search_slot(trans, root, &curr->key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto delete_fail;\n\telse if (ret > 0) {\n\t\t/*\n\t\t * can't find the item which the node points to, so this node\n\t\t * is invalid, just drop it.\n\t\t */\n\t\tprev = curr;\n\t\tcurr = __btrfs_next_delayed_item(prev);\n\t\tbtrfs_release_delayed_item(prev);\n\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t\tif (curr) {\n\t\t\tmutex_unlock(&node->mutex);\n\t\t\tgoto do_again;\n\t\t} else\n\t\t\tgoto delete_fail;\n\t}\n\n\tbtrfs_batch_delete_items(trans, root, path, curr);\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ndelete_fail:\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_batch_delete_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "898-959",
    "snippet": "static int btrfs_batch_delete_items(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct list_head head;\n\tint nitems, i, last_item;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\n\ti = path->slots[0];\n\tlast_item = btrfs_header_nritems(leaf) - 1;\n\tif (i > last_item)\n\t\treturn -ENOENT;\t/* FIXME: Is errno suitable? */\n\n\tnext = item;\n\tINIT_LIST_HEAD(&head);\n\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\tnitems = 0;\n\t/*\n\t * count the number of the dir index items that we can delete in batch\n\t */\n\twhile (btrfs_comp_cpu_keys(&next->key, &key) == 0) {\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\n\t\ti++;\n\t\tif (i > last_item)\n\t\t\tbreak;\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t}\n\n\tif (!nitems)\n\t\treturn 0;\n\n\tret = btrfs_del_items(trans, root, path, path->slots[0], nitems);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "curr"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&curr->tree_list"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_release_metadata",
          "args": [
            "root",
            "curr"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "569-583",
          "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "&head",
            "tree_list"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_items",
          "args": [
            "trans",
            "root",
            "path",
            "path->slots[0]",
            "nitems"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4930-5039",
          "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "i"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_continuous_delayed_item",
          "args": [
            "curr",
            "next"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_continuous_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "69-79",
          "snippet": "static inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "curr"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&next->tree_list",
            "&head"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&next->key",
            "&key"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path->nodes[0]"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_batch_delete_items(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct list_head head;\n\tint nitems, i, last_item;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\n\ti = path->slots[0];\n\tlast_item = btrfs_header_nritems(leaf) - 1;\n\tif (i > last_item)\n\t\treturn -ENOENT;\t/* FIXME: Is errno suitable? */\n\n\tnext = item;\n\tINIT_LIST_HEAD(&head);\n\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\tnitems = 0;\n\t/*\n\t * count the number of the dir index items that we can delete in batch\n\t */\n\twhile (btrfs_comp_cpu_keys(&next->key, &key) == 0) {\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\n\t\ti++;\n\t\tif (i > last_item)\n\t\t\tbreak;\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t}\n\n\tif (!nitems)\n\t\treturn 0;\n\n\tret = btrfs_del_items(trans, root, path, path->slots[0], nitems);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_insert_delayed_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "859-896",
    "snippet": "static int btrfs_insert_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_insertion_item(node);\n\tif (!curr)\n\t\tgoto insert_end;\n\n\tret = btrfs_insert_delayed_item(trans, root, path, curr);\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\tgoto insert_end;\n\t}\n\n\tprev = curr;\n\tcurr = __btrfs_next_delayed_item(prev);\n\tif (curr && btrfs_is_continuous_delayed_item(prev, curr)) {\n\t\t/* insert the continuous items into the same leaf */\n\t\tpath->slots[0]++;\n\t\tbtrfs_batch_insert_items(root, path, curr);\n\t}\n\tbtrfs_release_delayed_item(prev);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ninsert_end:\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&node->mutex"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "prev"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_batch_insert_items",
          "args": [
            "root",
            "path",
            "curr"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_batch_insert_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "719-823",
          "snippet": "static int btrfs_batch_insert_items(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint free_space;\n\tint total_data_size = 0, total_size = 0;\n\tstruct extent_buffer *leaf;\n\tchar *data_ptr;\n\tstruct btrfs_key *keys;\n\tu32 *data_size;\n\tstruct list_head head;\n\tint slot;\n\tint nitems;\n\tint i;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\tfree_space = btrfs_leaf_free_space(root, leaf);\n\tINIT_LIST_HEAD(&head);\n\n\tnext = item;\n\tnitems = 0;\n\n\t/*\n\t * count the number of the continuous items that we can insert in batch\n\t */\n\twhile (total_size + next->data_len + sizeof(struct btrfs_item) <=\n\t       free_space) {\n\t\ttotal_data_size += next->data_len;\n\t\ttotal_size += next->data_len + sizeof(struct btrfs_item);\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\t}\n\n\tif (!nitems) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we need allocate some memory space, but it might cause the task\n\t * to sleep, so we set all locked nodes in the path to blocking locks\n\t * first.\n\t */\n\tbtrfs_set_path_blocking(path);\n\n\tkeys = kmalloc_array(nitems, sizeof(struct btrfs_key), GFP_NOFS);\n\tif (!keys) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_size = kmalloc_array(nitems, sizeof(u32), GFP_NOFS);\n\tif (!data_size) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* get keys of all the delayed items */\n\ti = 0;\n\tlist_for_each_entry(next, &head, tree_list) {\n\t\tkeys[i] = next->key;\n\t\tdata_size[i] = next->data_len;\n\t\ti++;\n\t}\n\n\t/* reset all the locked nodes in the patch to spinning locks. */\n\tbtrfs_clear_path_blocking(path, NULL, 0);\n\n\t/* insert the keys of the items */\n\tsetup_items_for_insert(root, path, keys, data_size,\n\t\t\t       total_data_size, total_size, nitems);\n\n\t/* insert the dir index items */\n\tslot = path->slots[0];\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tdata_ptr = btrfs_item_ptr(leaf, slot, char);\n\t\twrite_extent_buffer(leaf, &curr->data,\n\t\t\t\t    (unsigned long)data_ptr,\n\t\t\t\t    curr->data_len);\n\t\tslot++;\n\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nerror:\n\tkfree(data_size);\n\tkfree(keys);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_batch_insert_items(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint free_space;\n\tint total_data_size = 0, total_size = 0;\n\tstruct extent_buffer *leaf;\n\tchar *data_ptr;\n\tstruct btrfs_key *keys;\n\tu32 *data_size;\n\tstruct list_head head;\n\tint slot;\n\tint nitems;\n\tint i;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\tfree_space = btrfs_leaf_free_space(root, leaf);\n\tINIT_LIST_HEAD(&head);\n\n\tnext = item;\n\tnitems = 0;\n\n\t/*\n\t * count the number of the continuous items that we can insert in batch\n\t */\n\twhile (total_size + next->data_len + sizeof(struct btrfs_item) <=\n\t       free_space) {\n\t\ttotal_data_size += next->data_len;\n\t\ttotal_size += next->data_len + sizeof(struct btrfs_item);\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\t}\n\n\tif (!nitems) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we need allocate some memory space, but it might cause the task\n\t * to sleep, so we set all locked nodes in the path to blocking locks\n\t * first.\n\t */\n\tbtrfs_set_path_blocking(path);\n\n\tkeys = kmalloc_array(nitems, sizeof(struct btrfs_key), GFP_NOFS);\n\tif (!keys) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_size = kmalloc_array(nitems, sizeof(u32), GFP_NOFS);\n\tif (!data_size) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* get keys of all the delayed items */\n\ti = 0;\n\tlist_for_each_entry(next, &head, tree_list) {\n\t\tkeys[i] = next->key;\n\t\tdata_size[i] = next->data_len;\n\t\ti++;\n\t}\n\n\t/* reset all the locked nodes in the patch to spinning locks. */\n\tbtrfs_clear_path_blocking(path, NULL, 0);\n\n\t/* insert the keys of the items */\n\tsetup_items_for_insert(root, path, keys, data_size,\n\t\t\t       total_data_size, total_size, nitems);\n\n\t/* insert the dir index items */\n\tslot = path->slots[0];\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tdata_ptr = btrfs_item_ptr(leaf, slot, char);\n\t\twrite_extent_buffer(leaf, &curr->data,\n\t\t\t\t    (unsigned long)data_ptr,\n\t\t\t\t    curr->data_len);\n\t\tslot++;\n\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nerror:\n\tkfree(data_size);\n\tkfree(keys);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_continuous_delayed_item",
          "args": [
            "prev",
            "curr"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_continuous_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "69-79",
          "snippet": "static inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "prev"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_delayed_item",
          "args": [
            "trans",
            "root",
            "path",
            "curr"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "859-896",
          "snippet": "static int btrfs_insert_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_insertion_item(node);\n\tif (!curr)\n\t\tgoto insert_end;\n\n\tret = btrfs_insert_delayed_item(trans, root, path, curr);\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\tgoto insert_end;\n\t}\n\n\tprev = curr;\n\tcurr = __btrfs_next_delayed_item(prev);\n\tif (curr && btrfs_is_continuous_delayed_item(prev, curr)) {\n\t\t/* insert the continuous items into the same leaf */\n\t\tpath->slots[0]++;\n\t\tbtrfs_batch_insert_items(root, path, curr);\n\t}\n\tbtrfs_release_delayed_item(prev);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ninsert_end:\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_first_delayed_insertion_item",
          "args": [
            "node"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_first_delayed_insertion_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "503-514",
          "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&node->mutex"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_insert_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_item *curr, *prev;\n\tint ret = 0;\n\ndo_again:\n\tmutex_lock(&node->mutex);\n\tcurr = __btrfs_first_delayed_insertion_item(node);\n\tif (!curr)\n\t\tgoto insert_end;\n\n\tret = btrfs_insert_delayed_item(trans, root, path, curr);\n\tif (ret < 0) {\n\t\tbtrfs_release_path(path);\n\t\tgoto insert_end;\n\t}\n\n\tprev = curr;\n\tcurr = __btrfs_next_delayed_item(prev);\n\tif (curr && btrfs_is_continuous_delayed_item(prev, curr)) {\n\t\t/* insert the continuous items into the same leaf */\n\t\tpath->slots[0]++;\n\t\tbtrfs_batch_insert_items(root, path, curr);\n\t}\n\tbtrfs_release_delayed_item(prev);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_release_path(path);\n\tmutex_unlock(&node->mutex);\n\tgoto do_again;\n\ninsert_end:\n\tmutex_unlock(&node->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_insert_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "829-853",
    "snippet": "static int btrfs_insert_delayed_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct btrfs_delayed_item *delayed_item)\n{\n\tstruct extent_buffer *leaf;\n\tchar *ptr;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &delayed_item->key,\n\t\t\t\t      delayed_item->data_len);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\n\tleaf = path->nodes[0];\n\n\tptr = btrfs_item_ptr(leaf, path->slots[0], char);\n\n\twrite_extent_buffer(leaf, delayed_item->data, (unsigned long)ptr,\n\t\t\t    delayed_item->data_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_delayed_item_release_metadata(root, delayed_item);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_delayed_item_release_metadata",
          "args": [
            "root",
            "delayed_item"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "569-583",
          "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "delayed_item->data",
            "(unsigned long)ptr",
            "delayed_item->data_len"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "char"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&delayed_item->key",
            "delayed_item->data_len"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_insert_delayed_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct btrfs_delayed_item *delayed_item)\n{\n\tstruct extent_buffer *leaf;\n\tchar *ptr;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &delayed_item->key,\n\t\t\t\t      delayed_item->data_len);\n\tif (ret < 0 && ret != -EEXIST)\n\t\treturn ret;\n\n\tleaf = path->nodes[0];\n\n\tptr = btrfs_item_ptr(leaf, path->slots[0], char);\n\n\twrite_extent_buffer(leaf, delayed_item->data, (unsigned long)ptr,\n\t\t\t    delayed_item->data_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_delayed_item_release_metadata(root, delayed_item);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_batch_insert_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "719-823",
    "snippet": "static int btrfs_batch_insert_items(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint free_space;\n\tint total_data_size = 0, total_size = 0;\n\tstruct extent_buffer *leaf;\n\tchar *data_ptr;\n\tstruct btrfs_key *keys;\n\tu32 *data_size;\n\tstruct list_head head;\n\tint slot;\n\tint nitems;\n\tint i;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\tfree_space = btrfs_leaf_free_space(root, leaf);\n\tINIT_LIST_HEAD(&head);\n\n\tnext = item;\n\tnitems = 0;\n\n\t/*\n\t * count the number of the continuous items that we can insert in batch\n\t */\n\twhile (total_size + next->data_len + sizeof(struct btrfs_item) <=\n\t       free_space) {\n\t\ttotal_data_size += next->data_len;\n\t\ttotal_size += next->data_len + sizeof(struct btrfs_item);\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\t}\n\n\tif (!nitems) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we need allocate some memory space, but it might cause the task\n\t * to sleep, so we set all locked nodes in the path to blocking locks\n\t * first.\n\t */\n\tbtrfs_set_path_blocking(path);\n\n\tkeys = kmalloc_array(nitems, sizeof(struct btrfs_key), GFP_NOFS);\n\tif (!keys) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_size = kmalloc_array(nitems, sizeof(u32), GFP_NOFS);\n\tif (!data_size) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* get keys of all the delayed items */\n\ti = 0;\n\tlist_for_each_entry(next, &head, tree_list) {\n\t\tkeys[i] = next->key;\n\t\tdata_size[i] = next->data_len;\n\t\ti++;\n\t}\n\n\t/* reset all the locked nodes in the patch to spinning locks. */\n\tbtrfs_clear_path_blocking(path, NULL, 0);\n\n\t/* insert the keys of the items */\n\tsetup_items_for_insert(root, path, keys, data_size,\n\t\t\t       total_data_size, total_size, nitems);\n\n\t/* insert the dir index items */\n\tslot = path->slots[0];\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tdata_ptr = btrfs_item_ptr(leaf, slot, char);\n\t\twrite_extent_buffer(leaf, &curr->data,\n\t\t\t\t    (unsigned long)data_ptr,\n\t\t\t\t    curr->data_len);\n\t\tslot++;\n\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nerror:\n\tkfree(data_size);\n\tkfree(keys);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "keys"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data_size"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_delayed_item",
          "args": [
            "curr"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "494-501",
          "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&curr->tree_list"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_item_release_metadata",
          "args": [
            "root",
            "curr"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_item_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "569-583",
          "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "&curr->data",
            "(unsigned long)data_ptr",
            "curr->data_len"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "char"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "curr",
            "next",
            "&head",
            "tree_list"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "path",
            "keys",
            "data_size",
            "total_data_size",
            "total_size",
            "nitems"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "path",
            "NULL",
            "0"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "next",
            "&head",
            "tree_list"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nitems",
            "sizeof(u32)",
            "GFP_NOFS"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nitems",
            "sizeof(struct btrfs_key)",
            "GFP_NOFS"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_continuous_delayed_item",
          "args": [
            "curr",
            "next"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_continuous_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "69-79",
          "snippet": "static inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_next_delayed_item",
          "args": [
            "curr"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_next_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "529-540",
          "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&next->tree_list",
            "&head"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path->nodes[0]"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_batch_insert_items(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_delayed_item *curr, *next;\n\tint free_space;\n\tint total_data_size = 0, total_size = 0;\n\tstruct extent_buffer *leaf;\n\tchar *data_ptr;\n\tstruct btrfs_key *keys;\n\tu32 *data_size;\n\tstruct list_head head;\n\tint slot;\n\tint nitems;\n\tint i;\n\tint ret = 0;\n\n\tBUG_ON(!path->nodes[0]);\n\n\tleaf = path->nodes[0];\n\tfree_space = btrfs_leaf_free_space(root, leaf);\n\tINIT_LIST_HEAD(&head);\n\n\tnext = item;\n\tnitems = 0;\n\n\t/*\n\t * count the number of the continuous items that we can insert in batch\n\t */\n\twhile (total_size + next->data_len + sizeof(struct btrfs_item) <=\n\t       free_space) {\n\t\ttotal_data_size += next->data_len;\n\t\ttotal_size += next->data_len + sizeof(struct btrfs_item);\n\t\tlist_add_tail(&next->tree_list, &head);\n\t\tnitems++;\n\n\t\tcurr = next;\n\t\tnext = __btrfs_next_delayed_item(curr);\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (!btrfs_is_continuous_delayed_item(curr, next))\n\t\t\tbreak;\n\t}\n\n\tif (!nitems) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we need allocate some memory space, but it might cause the task\n\t * to sleep, so we set all locked nodes in the path to blocking locks\n\t * first.\n\t */\n\tbtrfs_set_path_blocking(path);\n\n\tkeys = kmalloc_array(nitems, sizeof(struct btrfs_key), GFP_NOFS);\n\tif (!keys) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_size = kmalloc_array(nitems, sizeof(u32), GFP_NOFS);\n\tif (!data_size) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* get keys of all the delayed items */\n\ti = 0;\n\tlist_for_each_entry(next, &head, tree_list) {\n\t\tkeys[i] = next->key;\n\t\tdata_size[i] = next->data_len;\n\t\ti++;\n\t}\n\n\t/* reset all the locked nodes in the patch to spinning locks. */\n\tbtrfs_clear_path_blocking(path, NULL, 0);\n\n\t/* insert the keys of the items */\n\tsetup_items_for_insert(root, path, keys, data_size,\n\t\t\t       total_data_size, total_size, nitems);\n\n\t/* insert the dir index items */\n\tslot = path->slots[0];\n\tlist_for_each_entry_safe(curr, next, &head, tree_list) {\n\t\tdata_ptr = btrfs_item_ptr(leaf, slot, char);\n\t\twrite_extent_buffer(leaf, &curr->data,\n\t\t\t\t    (unsigned long)data_ptr,\n\t\t\t\t    curr->data_len);\n\t\tslot++;\n\n\t\tbtrfs_delayed_item_release_metadata(root, curr);\n\n\t\tlist_del(&curr->tree_list);\n\t\tbtrfs_release_delayed_item(curr);\n\t}\n\nerror:\n\tkfree(data_size);\n\tkfree(keys);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_delayed_inode_release_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "699-713",
    "snippet": "static void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "rsv",
            "node->bytes_reserved"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delayed_inode\"",
            "node->inode_id",
            "node->bytes_reserved",
            "0"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_inode_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!node->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t      node->inode_id, node->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\tnode->bytes_reserved);\n\tnode->bytes_reserved = 0;\n}"
  },
  {
    "function_name": "btrfs_delayed_inode_reserve_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "585-697",
    "snippet": "static int btrfs_delayed_inode_reserve_metadata(\n\t\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\tbool release = false;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\n\t/*\n\t * btrfs_dirty_inode will update the inode under btrfs_join_transaction\n\t * which doesn't reserve space for speed.  This is a problem since we\n\t * still need to reserve space for this update, so try to reserve the\n\t * space.\n\t *\n\t * Now if src_rsv == delalloc_block_rsv we'll let it just steal since\n\t * we're accounted for.\n\t */\n\tif (!src_rsv || (!trans->bytes_reserved &&\n\t\t\t src_rsv->type != BTRFS_BLOCK_RSV_DELALLOC)) {\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\t/*\n\t\t * Since we're under a transaction reserve_metadata_bytes could\n\t\t * try to commit the transaction which will make it return\n\t\t * EAGAIN to make us stop the transaction we have, so return\n\t\t * ENOSPC instead so that btrfs_dirty_inode knows what to do.\n\t\t */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOSPC;\n\t\tif (!ret) {\n\t\t\tnode->bytes_reserved = num_bytes;\n\t\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t\t      \"delayed_inode\",\n\t\t\t\t\t\t      btrfs_ino(inode),\n\t\t\t\t\t\t      num_bytes, 1);\n\t\t}\n\t\treturn ret;\n\t} else if (src_rsv->type == BTRFS_BLOCK_RSV_DELALLOC) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tif (test_and_clear_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t\t       &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\trelease = true;\n\t\t\tgoto migrate;\n\t\t}\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\t\t/* Ok we didn't have space pre-reserved.  This shouldn't happen\n\t\t * too often but it can happen if we do delalloc to an existing\n\t\t * inode which gets dirtied because of the time update, and then\n\t\t * isn't touched again until after the transaction commits and\n\t\t * then we try to write out the data.  First try to be nice and\n\t\t * reserve something strictly for us.  If not be a pain and try\n\t\t * to steal from the delalloc block rsv.\n\t\t */\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\t\tif (!WARN_ON(ret))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Ok this is a problem, let's just steal from the global rsv\n\t\t * since this really shouldn't happen that often.\n\t\t */\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->global_block_rsv,\n\t\t\t\t\t      dst_rsv, num_bytes);\n\t\tgoto out;\n\t}\n\nmigrate:\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\nout:\n\t/*\n\t * Migrate only takes a reservation, it doesn't touch the size of the\n\t * block_rsv.  This is to simplify people who don't normally have things\n\t * migrated from their block rsv.  If they go to release their\n\t * reservation, that will decrease the size as well, so if migrate\n\t * reduced size we'd end up with a negative size.  But for the\n\t * delalloc_meta_reserved stuff we will only know to drop 1 reservation,\n\t * but we could in fact do this reserve/migrate dance several times\n\t * between the time we did the original reservation and we'd clean it\n\t * up.  So to take care of this, release the space for the meta\n\t * reservation here.  I think it may be time for a documentation page on\n\t * how block rsvs. work.\n\t */\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 1);\n\t\tnode->bytes_reserved = num_bytes;\n\t}\n\n\tif (release) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 0);\n\t\tbtrfs_block_rsv_release(root, src_rsv, num_bytes);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "src_rsv",
            "num_bytes"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delalloc\"",
            "btrfs_ino(inode)",
            "num_bytes",
            "0"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_delayed_dir_index_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1583-1603",
          "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delayed_inode\"",
            "btrfs_ino(inode)",
            "num_bytes",
            "1"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_migrate",
          "args": [
            "src_rsv",
            "dst_rsv",
            "num_bytes"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4769-4774",
          "snippet": "int btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "dst_rsv",
            "num_bytes",
            "BTRFS_RESERVE_NO_FLUSH"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "BTRFS_INODE_DELALLOC_META_RESERVED",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delayed_inode\"",
            "btrfs_ino(inode)",
            "num_bytes",
            "1"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delayed_inode_reserve_metadata(\n\t\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\tbool release = false;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\n\t/*\n\t * btrfs_dirty_inode will update the inode under btrfs_join_transaction\n\t * which doesn't reserve space for speed.  This is a problem since we\n\t * still need to reserve space for this update, so try to reserve the\n\t * space.\n\t *\n\t * Now if src_rsv == delalloc_block_rsv we'll let it just steal since\n\t * we're accounted for.\n\t */\n\tif (!src_rsv || (!trans->bytes_reserved &&\n\t\t\t src_rsv->type != BTRFS_BLOCK_RSV_DELALLOC)) {\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\t/*\n\t\t * Since we're under a transaction reserve_metadata_bytes could\n\t\t * try to commit the transaction which will make it return\n\t\t * EAGAIN to make us stop the transaction we have, so return\n\t\t * ENOSPC instead so that btrfs_dirty_inode knows what to do.\n\t\t */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOSPC;\n\t\tif (!ret) {\n\t\t\tnode->bytes_reserved = num_bytes;\n\t\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t\t      \"delayed_inode\",\n\t\t\t\t\t\t      btrfs_ino(inode),\n\t\t\t\t\t\t      num_bytes, 1);\n\t\t}\n\t\treturn ret;\n\t} else if (src_rsv->type == BTRFS_BLOCK_RSV_DELALLOC) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tif (test_and_clear_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t\t       &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\trelease = true;\n\t\t\tgoto migrate;\n\t\t}\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\t\t/* Ok we didn't have space pre-reserved.  This shouldn't happen\n\t\t * too often but it can happen if we do delalloc to an existing\n\t\t * inode which gets dirtied because of the time update, and then\n\t\t * isn't touched again until after the transaction commits and\n\t\t * then we try to write out the data.  First try to be nice and\n\t\t * reserve something strictly for us.  If not be a pain and try\n\t\t * to steal from the delalloc block rsv.\n\t\t */\n\t\tret = btrfs_block_rsv_add(root, dst_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\t\tif (!WARN_ON(ret))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Ok this is a problem, let's just steal from the global rsv\n\t\t * since this really shouldn't happen that often.\n\t\t */\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->global_block_rsv,\n\t\t\t\t\t      dst_rsv, num_bytes);\n\t\tgoto out;\n\t}\n\nmigrate:\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\nout:\n\t/*\n\t * Migrate only takes a reservation, it doesn't touch the size of the\n\t * block_rsv.  This is to simplify people who don't normally have things\n\t * migrated from their block rsv.  If they go to release their\n\t * reservation, that will decrease the size as well, so if migrate\n\t * reduced size we'd end up with a negative size.  But for the\n\t * delalloc_meta_reserved stuff we will only know to drop 1 reservation,\n\t * but we could in fact do this reserve/migrate dance several times\n\t * between the time we did the original reservation and we'd clean it\n\t * up.  So to take care of this, release the space for the meta\n\t * reservation here.  I think it may be time for a documentation page on\n\t * how block rsvs. work.\n\t */\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_inode\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 1);\n\t\tnode->bytes_reserved = num_bytes;\n\t}\n\n\tif (release) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), num_bytes, 0);\n\t\tbtrfs_block_rsv_release(root, src_rsv, num_bytes);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_delayed_item_release_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "569-583",
    "snippet": "static void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "rsv",
            "item->bytes_reserved"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delayed_item\"",
            "item->key.objectid",
            "item->bytes_reserved",
            "0"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_delayed_item_release_metadata(struct btrfs_root *root,\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *rsv;\n\n\tif (!item->bytes_reserved)\n\t\treturn;\n\n\trsv = &root->fs_info->delayed_block_rsv;\n\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t      item->key.objectid, item->bytes_reserved,\n\t\t\t\t      0);\n\tbtrfs_block_rsv_release(root, rsv,\n\t\t\t\titem->bytes_reserved);\n}"
  },
  {
    "function_name": "btrfs_delayed_item_reserve_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "542-567",
    "snippet": "static int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"delayed_item\"",
            "item->key.objectid",
            "num_bytes",
            "1"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_migrate",
          "args": [
            "src_rsv",
            "dst_rsv",
            "num_bytes"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4769-4774",
          "snippet": "int btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int btrfs_delayed_item_reserve_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t\t       struct btrfs_delayed_item *item)\n{\n\tstruct btrfs_block_rsv *src_rsv;\n\tstruct btrfs_block_rsv *dst_rsv;\n\tu64 num_bytes;\n\tint ret;\n\n\tif (!trans->bytes_reserved)\n\t\treturn 0;\n\n\tsrc_rsv = trans->block_rsv;\n\tdst_rsv = &root->fs_info->delayed_block_rsv;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tret = btrfs_block_rsv_migrate(src_rsv, dst_rsv, num_bytes);\n\tif (!ret) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delayed_item\",\n\t\t\t\t\t      item->key.objectid,\n\t\t\t\t\t      num_bytes, 1);\n\t\titem->bytes_reserved = num_bytes;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_next_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "529-540",
    "snippet": "static struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&item->rb_node"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_next_delayed_item(\n\t\t\t\t\t\tstruct btrfs_delayed_item *item)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *next = NULL;\n\n\tp = rb_next(&item->rb_node);\n\tif (p)\n\t\tnext = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn next;\n}"
  },
  {
    "function_name": "__btrfs_first_delayed_deletion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "516-527",
    "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&delayed_node->del_root"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_deletion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->del_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
  },
  {
    "function_name": "__btrfs_first_delayed_insertion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "503-514",
    "snippet": "static struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&delayed_node->ins_root"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_first_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node)\n{\n\tstruct rb_node *p;\n\tstruct btrfs_delayed_item *item = NULL;\n\n\tp = rb_first(&delayed_node->ins_root);\n\tif (p)\n\t\titem = rb_entry(p, struct btrfs_delayed_item, rb_node);\n\n\treturn item;\n}"
  },
  {
    "function_name": "btrfs_release_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "494-501",
    "snippet": "static void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "item"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&item->refs"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_delayed_item",
          "args": [
            "item"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "472-492",
          "snippet": "static void __btrfs_remove_delayed_item(struct btrfs_delayed_item *delayed_item)\n{\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = delayed_item->delayed_node->root->fs_info->delayed_root;\n\n\tBUG_ON(!delayed_root);\n\tBUG_ON(delayed_item->ins_or_del != BTRFS_DELAYED_DELETION_ITEM &&\n\t       delayed_item->ins_or_del != BTRFS_DELAYED_INSERTION_ITEM);\n\n\tif (delayed_item->ins_or_del == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_item->delayed_node->ins_root;\n\telse\n\t\troot = &delayed_item->delayed_node->del_root;\n\n\trb_erase(&delayed_item->rb_node, root);\n\tdelayed_item->delayed_node->count--;\n\n\tfinish_one_item(delayed_root);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_remove_delayed_item(struct btrfs_delayed_item *delayed_item)\n{\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = delayed_item->delayed_node->root->fs_info->delayed_root;\n\n\tBUG_ON(!delayed_root);\n\tBUG_ON(delayed_item->ins_or_del != BTRFS_DELAYED_DELETION_ITEM &&\n\t       delayed_item->ins_or_del != BTRFS_DELAYED_INSERTION_ITEM);\n\n\tif (delayed_item->ins_or_del == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_item->delayed_node->ins_root;\n\telse\n\t\troot = &delayed_item->delayed_node->del_root;\n\n\trb_erase(&delayed_item->rb_node, root);\n\tdelayed_item->delayed_node->count--;\n\n\tfinish_one_item(delayed_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_release_delayed_item(struct btrfs_delayed_item *item)\n{\n\tif (item) {\n\t\t__btrfs_remove_delayed_item(item);\n\t\tif (atomic_dec_and_test(&item->refs))\n\t\t\tkfree(item);\n\t}\n}"
  },
  {
    "function_name": "__btrfs_remove_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "472-492",
    "snippet": "static void __btrfs_remove_delayed_item(struct btrfs_delayed_item *delayed_item)\n{\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = delayed_item->delayed_node->root->fs_info->delayed_root;\n\n\tBUG_ON(!delayed_root);\n\tBUG_ON(delayed_item->ins_or_del != BTRFS_DELAYED_DELETION_ITEM &&\n\t       delayed_item->ins_or_del != BTRFS_DELAYED_INSERTION_ITEM);\n\n\tif (delayed_item->ins_or_del == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_item->delayed_node->ins_root;\n\telse\n\t\troot = &delayed_item->delayed_node->del_root;\n\n\trb_erase(&delayed_item->rb_node, root);\n\tdelayed_item->delayed_node->count--;\n\n\tfinish_one_item(delayed_root);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_one_item",
          "args": [
            "delayed_root"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "finish_one_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "463-470",
          "snippet": "static void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BATCH\t\t16",
            "#define BTRFS_DELAYED_BACKGROUND\t128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&delayed_item->rb_node",
            "root"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "delayed_item->ins_or_del != BTRFS_DELAYED_DELETION_ITEM &&\n\t       delayed_item->ins_or_del != BTRFS_DELAYED_INSERTION_ITEM"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!delayed_root"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void __btrfs_remove_delayed_item(struct btrfs_delayed_item *delayed_item)\n{\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = delayed_item->delayed_node->root->fs_info->delayed_root;\n\n\tBUG_ON(!delayed_root);\n\tBUG_ON(delayed_item->ins_or_del != BTRFS_DELAYED_DELETION_ITEM &&\n\t       delayed_item->ins_or_del != BTRFS_DELAYED_INSERTION_ITEM);\n\n\tif (delayed_item->ins_or_del == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_item->delayed_node->ins_root;\n\telse\n\t\troot = &delayed_item->delayed_node->del_root;\n\n\trb_erase(&delayed_item->rb_node, root);\n\tdelayed_item->delayed_node->count--;\n\n\tfinish_one_item(delayed_root);\n}"
  },
  {
    "function_name": "finish_one_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "463-470",
    "snippet": "static void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BTRFS_DELAYED_BATCH\t\t16",
      "#define BTRFS_DELAYED_BACKGROUND\t128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&delayed_root->wait"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&delayed_root->wait"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&delayed_root->items"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&delayed_root->items_seq"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n\nstatic void finish_one_item(struct btrfs_delayed_root *delayed_root)\n{\n\tint seq = atomic_inc_return(&delayed_root->items_seq);\n\tif ((atomic_dec_return(&delayed_root->items) <\n\t    BTRFS_DELAYED_BACKGROUND || seq % BTRFS_DELAYED_BATCH == 0) &&\n\t    waitqueue_active(&delayed_root->wait))\n\t\twake_up(&delayed_root->wait);\n}"
  },
  {
    "function_name": "__btrfs_add_delayed_deletion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "456-461",
    "snippet": "static int __btrfs_add_delayed_deletion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t     struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_DELETION_ITEM);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_delayed_item",
          "args": [
            "node",
            "item",
            "BTRFS_DELAYED_DELETION_ITEM"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "401-447",
          "snippet": "static int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_deletion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t     struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_DELETION_ITEM);\n}"
  },
  {
    "function_name": "__btrfs_add_delayed_insertion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "449-454",
    "snippet": "static int __btrfs_add_delayed_insertion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t      struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_INSERTION_ITEM);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_delayed_item",
          "args": [
            "node",
            "item",
            "BTRFS_DELAYED_INSERTION_ITEM"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "401-447",
          "snippet": "static int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_insertion_item(struct btrfs_delayed_node *node,\n\t\t\t\t\t      struct btrfs_delayed_item *item)\n{\n\treturn __btrfs_add_delayed_item(node, item,\n\t\t\t\t\tBTRFS_DELAYED_INSERTION_ITEM);\n}"
  },
  {
    "function_name": "__btrfs_add_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "401-447",
    "snippet": "static int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&delayed_node->root->fs_info->delayed_root->items"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent_node",
            "p"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&item->key",
            "&ins->key"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent_node",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic int __btrfs_add_delayed_item(struct btrfs_delayed_node *delayed_node,\n\t\t\t\t    struct btrfs_delayed_item *ins,\n\t\t\t\t    int action)\n{\n\tstruct rb_node **p, *node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct rb_root *root;\n\tstruct btrfs_delayed_item *item;\n\tint cmp;\n\n\tif (action == BTRFS_DELAYED_INSERTION_ITEM)\n\t\troot = &delayed_node->ins_root;\n\telse if (action == BTRFS_DELAYED_DELETION_ITEM)\n\t\troot = &delayed_node->del_root;\n\telse\n\t\tBUG();\n\tp = &root->rb_node;\n\tnode = &ins->rb_node;\n\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\titem = rb_entry(parent_node, struct btrfs_delayed_item,\n\t\t\t\t rb_node);\n\n\t\tcmp = btrfs_comp_cpu_keys(&item->key, &ins->key);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\tins->delayed_node = delayed_node;\n\tins->ins_or_del = action;\n\n\tif (ins->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    action == BTRFS_DELAYED_INSERTION_ITEM &&\n\t    ins->key.offset >= delayed_node->index_cnt)\n\t\t\tdelayed_node->index_cnt = ins->key.offset + 1;\n\n\tdelayed_node->count++;\n\tatomic_inc(&delayed_node->root->fs_info->delayed_root->items);\n\treturn 0;\n}"
  },
  {
    "function_name": "__btrfs_lookup_delayed_insertion_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "390-399",
    "snippet": "static struct btrfs_delayed_item *__btrfs_lookup_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\titem = __btrfs_lookup_delayed_item(&delayed_node->ins_root, key,\n\t\t\t\t\t   NULL, NULL);\n\treturn item;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_lookup_delayed_item",
          "args": [
            "&delayed_node->ins_root",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_lookup_delayed_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "339-388",
          "snippet": "static struct btrfs_delayed_item *__btrfs_lookup_delayed_item(\n\t\t\t\tstruct rb_root *root,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_delayed_item **prev,\n\t\t\t\tstruct btrfs_delayed_item **next)\n{\n\tstruct rb_node *node, *prev_node = NULL;\n\tstruct btrfs_delayed_item *delayed_item = NULL;\n\tint ret = 0;\n\n\tnode = root->rb_node;\n\n\twhile (node) {\n\t\tdelayed_item = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\trb_node);\n\t\tprev_node = node;\n\t\tret = btrfs_comp_cpu_keys(&delayed_item->key, key);\n\t\tif (ret < 0)\n\t\t\tnode = node->rb_right;\n\t\telse if (ret > 0)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\treturn delayed_item;\n\t}\n\n\tif (prev) {\n\t\tif (!prev_node)\n\t\t\t*prev = NULL;\n\t\telse if (ret < 0)\n\t\t\t*prev = delayed_item;\n\t\telse if ((node = rb_prev(prev_node)) != NULL) {\n\t\t\t*prev = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*prev = NULL;\n\t}\n\n\tif (next) {\n\t\tif (!prev_node)\n\t\t\t*next = NULL;\n\t\telse if (ret > 0)\n\t\t\t*next = delayed_item;\n\t\telse if ((node = rb_next(prev_node)) != NULL) {\n\t\t\t*next = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*next = NULL;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_lookup_delayed_item(\n\t\t\t\tstruct rb_root *root,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_delayed_item **prev,\n\t\t\t\tstruct btrfs_delayed_item **next)\n{\n\tstruct rb_node *node, *prev_node = NULL;\n\tstruct btrfs_delayed_item *delayed_item = NULL;\n\tint ret = 0;\n\n\tnode = root->rb_node;\n\n\twhile (node) {\n\t\tdelayed_item = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\trb_node);\n\t\tprev_node = node;\n\t\tret = btrfs_comp_cpu_keys(&delayed_item->key, key);\n\t\tif (ret < 0)\n\t\t\tnode = node->rb_right;\n\t\telse if (ret > 0)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\treturn delayed_item;\n\t}\n\n\tif (prev) {\n\t\tif (!prev_node)\n\t\t\t*prev = NULL;\n\t\telse if (ret < 0)\n\t\t\t*prev = delayed_item;\n\t\telse if ((node = rb_prev(prev_node)) != NULL) {\n\t\t\t*prev = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*prev = NULL;\n\t}\n\n\tif (next) {\n\t\tif (!prev_node)\n\t\t\t*next = NULL;\n\t\telse if (ret > 0)\n\t\t\t*next = delayed_item;\n\t\telse if ((node = rb_next(prev_node)) != NULL) {\n\t\t\t*next = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*next = NULL;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_lookup_delayed_insertion_item(\n\t\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_delayed_item *item;\n\n\titem = __btrfs_lookup_delayed_item(&delayed_node->ins_root, key,\n\t\t\t\t\t   NULL, NULL);\n\treturn item;\n}"
  },
  {
    "function_name": "__btrfs_lookup_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "339-388",
    "snippet": "static struct btrfs_delayed_item *__btrfs_lookup_delayed_item(\n\t\t\t\tstruct rb_root *root,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_delayed_item **prev,\n\t\t\t\tstruct btrfs_delayed_item **next)\n{\n\tstruct rb_node *node, *prev_node = NULL;\n\tstruct btrfs_delayed_item *delayed_item = NULL;\n\tint ret = 0;\n\n\tnode = root->rb_node;\n\n\twhile (node) {\n\t\tdelayed_item = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\trb_node);\n\t\tprev_node = node;\n\t\tret = btrfs_comp_cpu_keys(&delayed_item->key, key);\n\t\tif (ret < 0)\n\t\t\tnode = node->rb_right;\n\t\telse if (ret > 0)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\treturn delayed_item;\n\t}\n\n\tif (prev) {\n\t\tif (!prev_node)\n\t\t\t*prev = NULL;\n\t\telse if (ret < 0)\n\t\t\t*prev = delayed_item;\n\t\telse if ((node = rb_prev(prev_node)) != NULL) {\n\t\t\t*prev = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*prev = NULL;\n\t}\n\n\tif (next) {\n\t\tif (!prev_node)\n\t\t\t*next = NULL;\n\t\telse if (ret > 0)\n\t\t\t*next = delayed_item;\n\t\telse if ((node = rb_next(prev_node)) != NULL) {\n\t\t\t*next = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*next = NULL;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev_node"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "prev_node"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&delayed_item->key",
            "key"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_item",
            "rb_node"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *__btrfs_lookup_delayed_item(\n\t\t\t\tstruct rb_root *root,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_delayed_item **prev,\n\t\t\t\tstruct btrfs_delayed_item **next)\n{\n\tstruct rb_node *node, *prev_node = NULL;\n\tstruct btrfs_delayed_item *delayed_item = NULL;\n\tint ret = 0;\n\n\tnode = root->rb_node;\n\n\twhile (node) {\n\t\tdelayed_item = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\trb_node);\n\t\tprev_node = node;\n\t\tret = btrfs_comp_cpu_keys(&delayed_item->key, key);\n\t\tif (ret < 0)\n\t\t\tnode = node->rb_right;\n\t\telse if (ret > 0)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\treturn delayed_item;\n\t}\n\n\tif (prev) {\n\t\tif (!prev_node)\n\t\t\t*prev = NULL;\n\t\telse if (ret < 0)\n\t\t\t*prev = delayed_item;\n\t\telse if ((node = rb_prev(prev_node)) != NULL) {\n\t\t\t*prev = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*prev = NULL;\n\t}\n\n\tif (next) {\n\t\tif (!prev_node)\n\t\t\t*next = NULL;\n\t\telse if (ret > 0)\n\t\t\t*next = delayed_item;\n\t\telse if ((node = rb_next(prev_node)) != NULL) {\n\t\t\t*next = rb_entry(node, struct btrfs_delayed_item,\n\t\t\t\t\t rb_node);\n\t\t} else\n\t\t\t*next = NULL;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfs_alloc_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "315-327",
    "snippet": "static struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&item->refs",
            "1"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*item) + data_len",
            "GFP_NOFS"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_item *btrfs_alloc_delayed_item(u32 data_len)\n{\n\tstruct btrfs_delayed_item *item;\n\titem = kmalloc(sizeof(*item) + data_len, GFP_NOFS);\n\tif (item) {\n\t\titem->data_len = data_len;\n\t\titem->ins_or_del = 0;\n\t\titem->bytes_reserved = 0;\n\t\titem->delayed_node = NULL;\n\t\tatomic_set(&item->refs, 1);\n\t}\n\treturn item;\n}"
  },
  {
    "function_name": "btrfs_release_prepared_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "309-313",
    "snippet": "static inline void btrfs_release_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 1);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_release_delayed_node",
          "args": [
            "node",
            "1"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "251-282",
          "snippet": "static void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 1);\n}"
  },
  {
    "function_name": "btrfs_first_prepared_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "289-307",
    "snippet": "static struct btrfs_delayed_node *btrfs_first_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->prepare_list))\n\t\tgoto out;\n\n\tp = delayed_root->prepare_list.next;\n\tlist_del_init(p);\n\tnode = list_entry(p, struct btrfs_delayed_node, p_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refs"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structbtrfs_delayed_node",
            "p_list"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&delayed_root->prepare_list"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_prepared_delayed_node(\n\t\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->prepare_list))\n\t\tgoto out;\n\n\tp = delayed_root->prepare_list.next;\n\tlist_del_init(p);\n\tnode = list_entry(p, struct btrfs_delayed_node, p_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
  },
  {
    "function_name": "btrfs_release_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "284-287",
    "snippet": "static inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_release_delayed_node",
          "args": [
            "node",
            "0"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_release_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "251-282",
          "snippet": "static void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_release_delayed_node(struct btrfs_delayed_node *node)\n{\n\t__btrfs_release_delayed_node(node, 0);\n}"
  },
  {
    "function_name": "__btrfs_release_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "251-282",
    "snippet": "static void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *delayed_node_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "delayed_node_cache",
            "delayed_node"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&root->delayed_nodes_tree",
            "delayed_node->inode_id"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_node->refs"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&delayed_node->refs"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dequeue_delayed_node",
          "args": [
            "delayed_root",
            "delayed_node"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dequeue_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "190-203",
          "snippet": "static void btrfs_dequeue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t       struct btrfs_delayed_node *node)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\troot->nodes--;\n\t\tatomic_dec(&node->refs);\t/* not in the list */\n\t\tlist_del_init(&node->n_list);\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_del_init(&node->p_list);\n\t\tclear_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_dequeue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t       struct btrfs_delayed_node *node)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\troot->nodes--;\n\t\tatomic_dec(&node->refs);\t/* not in the list */\n\t\tlist_del_init(&node->n_list);\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_del_init(&node->p_list);\n\t\tclear_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_queue_delayed_node",
          "args": [
            "delayed_root",
            "delayed_node",
            "mod"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "169-187",
          "snippet": "static void btrfs_queue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t     struct btrfs_delayed_node *node,\n\t\t\t\t     int mod)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_move_tail(&node->p_list, &root->prepare_list);\n\t\telse if (mod)\n\t\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t} else {\n\t\tlist_add_tail(&node->n_list, &root->node_list);\n\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t\tatomic_inc(&node->refs);\t/* inserted into list */\n\t\troot->nodes++;\n\t\tset_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_queue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t     struct btrfs_delayed_node *node,\n\t\t\t\t     int mod)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_move_tail(&node->p_list, &root->prepare_list);\n\t\telse if (mod)\n\t\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t} else {\n\t\tlist_add_tail(&node->n_list, &root->node_list);\n\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t\tatomic_inc(&node->refs);\t/* inserted into list */\n\t\troot->nodes++;\n\t\tset_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic void __btrfs_release_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tint mod)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tif (!delayed_node)\n\t\treturn;\n\n\tdelayed_root = delayed_node->root->fs_info->delayed_root;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (delayed_node->count)\n\t\tbtrfs_queue_delayed_node(delayed_root, delayed_node, mod);\n\telse\n\t\tbtrfs_dequeue_delayed_node(delayed_root, delayed_node);\n\tmutex_unlock(&delayed_node->mutex);\n\n\tif (atomic_dec_and_test(&delayed_node->refs)) {\n\t\tbool free = false;\n\t\tstruct btrfs_root *root = delayed_node->root;\n\t\tspin_lock(&root->inode_lock);\n\t\tif (atomic_read(&delayed_node->refs) == 0) {\n\t\t\tradix_tree_delete(&root->delayed_nodes_tree,\n\t\t\t\t\t  delayed_node->inode_id);\n\t\t\tfree = true;\n\t\t}\n\t\tspin_unlock(&root->inode_lock);\n\t\tif (free)\n\t\t\tkmem_cache_free(delayed_node_cache, delayed_node);\n\t}\n}"
  },
  {
    "function_name": "btrfs_next_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "224-249",
    "snippet": "static struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&next->refs"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structbtrfs_delayed_node",
            "n_list"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&node->n_list",
            "&delayed_root->node_list"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&delayed_root->node_list"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_IN_LIST",
            "&node->flags"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_next_delayed_node(\n\t\t\t\t\t\tstruct btrfs_delayed_node *node)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *next = NULL;\n\n\tdelayed_root = node->root->fs_info->delayed_root;\n\tspin_lock(&delayed_root->lock);\n\tif (!test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\t/* not in the list */\n\t\tif (list_empty(&delayed_root->node_list))\n\t\t\tgoto out;\n\t\tp = delayed_root->node_list.next;\n\t} else if (list_is_last(&node->n_list, &delayed_root->node_list))\n\t\tgoto out;\n\telse\n\t\tp = node->n_list.next;\n\n\tnext = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&next->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn next;\n}"
  },
  {
    "function_name": "btrfs_first_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "205-222",
    "snippet": "static struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refs"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structbtrfs_delayed_node",
            "n_list"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&delayed_root->node_list"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_root->lock"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_first_delayed_node(\n\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tstruct list_head *p;\n\tstruct btrfs_delayed_node *node = NULL;\n\n\tspin_lock(&delayed_root->lock);\n\tif (list_empty(&delayed_root->node_list))\n\t\tgoto out;\n\n\tp = delayed_root->node_list.next;\n\tnode = list_entry(p, struct btrfs_delayed_node, n_list);\n\tatomic_inc(&node->refs);\nout:\n\tspin_unlock(&delayed_root->lock);\n\n\treturn node;\n}"
  },
  {
    "function_name": "btrfs_dequeue_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "190-203",
    "snippet": "static void btrfs_dequeue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t       struct btrfs_delayed_node *node)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\troot->nodes--;\n\t\tatomic_dec(&node->refs);\t/* not in the list */\n\t\tlist_del_init(&node->n_list);\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_del_init(&node->p_list);\n\t\tclear_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->lock"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_DELAYED_NODE_IN_LIST",
            "&node->flags"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&node->p_list"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->p_list"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&node->n_list"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&node->refs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_IN_LIST",
            "&node->flags"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->lock"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_dequeue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t       struct btrfs_delayed_node *node)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\troot->nodes--;\n\t\tatomic_dec(&node->refs);\t/* not in the list */\n\t\tlist_del_init(&node->n_list);\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_del_init(&node->p_list);\n\t\tclear_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}"
  },
  {
    "function_name": "btrfs_queue_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "169-187",
    "snippet": "static void btrfs_queue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t     struct btrfs_delayed_node *node,\n\t\t\t\t     int mod)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_move_tail(&node->p_list, &root->prepare_list);\n\t\telse if (mod)\n\t\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t} else {\n\t\tlist_add_tail(&node->n_list, &root->node_list);\n\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t\tatomic_inc(&node->refs);\t/* inserted into list */\n\t\troot->nodes++;\n\t\tset_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->lock"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_DELAYED_NODE_IN_LIST",
            "&node->flags"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refs"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&node->p_list",
            "&root->prepare_list"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&node->n_list",
            "&root->node_list"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&node->p_list",
            "&root->prepare_list"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&node->p_list",
            "&root->prepare_list"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->p_list"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_DELAYED_NODE_IN_LIST",
            "&node->flags"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic void btrfs_queue_delayed_node(struct btrfs_delayed_root *root,\n\t\t\t\t     struct btrfs_delayed_node *node,\n\t\t\t\t     int mod)\n{\n\tspin_lock(&root->lock);\n\tif (test_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags)) {\n\t\tif (!list_empty(&node->p_list))\n\t\t\tlist_move_tail(&node->p_list, &root->prepare_list);\n\t\telse if (mod)\n\t\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t} else {\n\t\tlist_add_tail(&node->n_list, &root->node_list);\n\t\tlist_add_tail(&node->p_list, &root->prepare_list);\n\t\tatomic_inc(&node->refs);\t/* inserted into list */\n\t\troot->nodes++;\n\t\tset_bit(BTRFS_DELAYED_NODE_IN_LIST, &node->flags);\n\t}\n\tspin_unlock(&root->lock);\n}"
  },
  {
    "function_name": "btrfs_get_or_create_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "121-162",
    "snippet": "static struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *delayed_node_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "delayed_node_cache",
            "node"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&root->delayed_nodes_tree",
            "ino",
            "node"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "delayed_node_cache",
            "node"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS & ~__GFP_HIGHMEM"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "2",
            "&node->refs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_delayed_node",
          "args": [
            "node",
            "root",
            "ino"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "50-67",
          "snippet": "static inline void btrfs_init_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tstruct btrfs_root *root, u64 inode_id)\n{\n\tdelayed_node->root = root;\n\tdelayed_node->inode_id = inode_id;\n\tatomic_set(&delayed_node->refs, 0);\n\tdelayed_node->count = 0;\n\tdelayed_node->flags = 0;\n\tdelayed_node->ins_root = RB_ROOT;\n\tdelayed_node->del_root = RB_ROOT;\n\tmutex_init(&delayed_node->mutex);\n\tdelayed_node->index_cnt = 0;\n\tINIT_LIST_HEAD(&delayed_node->n_list);\n\tINIT_LIST_HEAD(&delayed_node->p_list);\n\tdelayed_node->bytes_reserved = 0;\n\tmemset(&delayed_node->inode_item, 0, sizeof(delayed_node->inode_item));\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_init_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tstruct btrfs_root *root, u64 inode_id)\n{\n\tdelayed_node->root = root;\n\tdelayed_node->inode_id = inode_id;\n\tatomic_set(&delayed_node->refs, 0);\n\tdelayed_node->count = 0;\n\tdelayed_node->flags = 0;\n\tdelayed_node->ins_root = RB_ROOT;\n\tdelayed_node->del_root = RB_ROOT;\n\tmutex_init(&delayed_node->mutex);\n\tdelayed_node->index_cnt = 0;\n\tINIT_LIST_HEAD(&delayed_node->n_list);\n\tINIT_LIST_HEAD(&delayed_node->p_list);\n\tdelayed_node->bytes_reserved = 0;\n\tmemset(&delayed_node->inode_item, 0, sizeof(delayed_node->inode_item));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "delayed_node_cache",
            "GFP_NOFS"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_delayed_node",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_delayed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "87-118",
          "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_delayed_dir_index_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1583-1603",
          "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nstatic struct btrfs_delayed_node *btrfs_get_or_create_delayed_node(\n\t\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct btrfs_delayed_node *node;\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tint ret;\n\nagain:\n\tnode = btrfs_get_delayed_node(inode);\n\tif (node)\n\t\treturn node;\n\n\tnode = kmem_cache_alloc(delayed_node_cache, GFP_NOFS);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbtrfs_init_delayed_node(node, root, ino);\n\n\t/* cached in the btrfs inode and can be accessed */\n\tatomic_add(2, &node->refs);\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret) {\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tret = radix_tree_insert(&root->delayed_nodes_tree, ino, node);\n\tif (ret == -EEXIST) {\n\t\tspin_unlock(&root->inode_lock);\n\t\tkmem_cache_free(delayed_node_cache, node);\n\t\tradix_tree_preload_end();\n\t\tgoto again;\n\t}\n\tbtrfs_inode->delayed_node = node;\n\tspin_unlock(&root->inode_lock);\n\tradix_tree_preload_end();\n\n\treturn node;\n}"
  },
  {
    "function_name": "btrfs_get_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "87-118",
    "snippet": "static struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "2",
            "&node->refs"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_inode->delayed_node != node"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refs"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&root->delayed_nodes_tree",
            "ino"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refs"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "btrfs_inode->delayed_node"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_delayed_dir_index_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1583-1603",
          "snippet": "int btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_inode_delayed_dir_index_count(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\n\tif (!delayed_node)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Since we have held i_mutex of this directory, it is impossible that\n\t * a new directory index is added into the delayed node and index_cnt\n\t * is updated now. So we needn't lock the delayed node.\n\t */\n\tif (!delayed_node->index_cnt) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -EINVAL;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = delayed_node->index_cnt;\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_delayed_node *btrfs_get_delayed_node(struct inode *inode)\n{\n\tstruct btrfs_inode *btrfs_inode = BTRFS_I(inode);\n\tstruct btrfs_root *root = btrfs_inode->root;\n\tu64 ino = btrfs_ino(inode);\n\tstruct btrfs_delayed_node *node;\n\n\tnode = ACCESS_ONCE(btrfs_inode->delayed_node);\n\tif (node) {\n\t\tatomic_inc(&node->refs);\n\t\treturn node;\n\t}\n\n\tspin_lock(&root->inode_lock);\n\tnode = radix_tree_lookup(&root->delayed_nodes_tree, ino);\n\tif (node) {\n\t\tif (btrfs_inode->delayed_node) {\n\t\t\tatomic_inc(&node->refs);\t/* can be accessed */\n\t\t\tBUG_ON(btrfs_inode->delayed_node != node);\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn node;\n\t\t}\n\t\tbtrfs_inode->delayed_node = node;\n\t\t/* can be accessed and cached in the inode */\n\t\tatomic_add(2, &node->refs);\n\t\tspin_unlock(&root->inode_lock);\n\t\treturn node;\n\t}\n\tspin_unlock(&root->inode_lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfs_get_delayed_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "81-85",
    "snippet": "static inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline struct btrfs_delayed_root *btrfs_get_delayed_root(\n\t\t\t\t\t\t\tstruct btrfs_root *root)\n{\n\treturn root->fs_info->delayed_root;\n}"
  },
  {
    "function_name": "btrfs_is_continuous_delayed_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "69-79",
    "snippet": "static inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline int btrfs_is_continuous_delayed_item(\n\t\t\t\t\tstruct btrfs_delayed_item *item1,\n\t\t\t\t\tstruct btrfs_delayed_item *item2)\n{\n\tif (item1->key.type == BTRFS_DIR_INDEX_KEY &&\n\t    item1->key.objectid == item2->key.objectid &&\n\t    item1->key.type == item2->key.type &&\n\t    item1->key.offset + 1 == item2->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_init_delayed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "50-67",
    "snippet": "static inline void btrfs_init_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tstruct btrfs_root *root, u64 inode_id)\n{\n\tdelayed_node->root = root;\n\tdelayed_node->inode_id = inode_id;\n\tatomic_set(&delayed_node->refs, 0);\n\tdelayed_node->count = 0;\n\tdelayed_node->flags = 0;\n\tdelayed_node->ins_root = RB_ROOT;\n\tdelayed_node->del_root = RB_ROOT;\n\tmutex_init(&delayed_node->mutex);\n\tdelayed_node->index_cnt = 0;\n\tINIT_LIST_HEAD(&delayed_node->n_list);\n\tINIT_LIST_HEAD(&delayed_node->p_list);\n\tdelayed_node->bytes_reserved = 0;\n\tmemset(&delayed_node->inode_item, 0, sizeof(delayed_node->inode_item));\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&delayed_node->inode_item",
            "0",
            "sizeof(delayed_node->inode_item)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&delayed_node->p_list"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&delayed_node->n_list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&delayed_node->mutex"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&delayed_node->refs",
            "0"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic inline void btrfs_init_delayed_node(\n\t\t\t\tstruct btrfs_delayed_node *delayed_node,\n\t\t\t\tstruct btrfs_root *root, u64 inode_id)\n{\n\tdelayed_node->root = root;\n\tdelayed_node->inode_id = inode_id;\n\tatomic_set(&delayed_node->refs, 0);\n\tdelayed_node->count = 0;\n\tdelayed_node->flags = 0;\n\tdelayed_node->ins_root = RB_ROOT;\n\tdelayed_node->del_root = RB_ROOT;\n\tmutex_init(&delayed_node->mutex);\n\tdelayed_node->index_cnt = 0;\n\tINIT_LIST_HEAD(&delayed_node->n_list);\n\tINIT_LIST_HEAD(&delayed_node->p_list);\n\tdelayed_node->bytes_reserved = 0;\n\tmemset(&delayed_node->inode_item, 0, sizeof(delayed_node->inode_item));\n}"
  },
  {
    "function_name": "btrfs_delayed_inode_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "44-48",
    "snippet": "void btrfs_delayed_inode_exit(void)\n{\n\tif (delayed_node_cache)\n\t\tkmem_cache_destroy(delayed_node_cache);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *delayed_node_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "delayed_node_cache"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nvoid btrfs_delayed_inode_exit(void)\n{\n\tif (delayed_node_cache)\n\t\tkmem_cache_destroy(delayed_node_cache);\n}"
  },
  {
    "function_name": "btrfs_delayed_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
    "lines": "32-42",
    "snippet": "int __init btrfs_delayed_inode_init(void)\n{\n\tdelayed_node_cache = kmem_cache_create(\"btrfs_delayed_node\",\n\t\t\t\t\tsizeof(struct btrfs_delayed_node),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!delayed_node_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *delayed_node_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_delayed_node\"",
            "sizeof(struct btrfs_delayed_node)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nint __init btrfs_delayed_inode_init(void)\n{\n\tdelayed_node_cache = kmem_cache_create(\"btrfs_delayed_node\",\n\t\t\t\t\tsizeof(struct btrfs_delayed_node),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!delayed_node_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]