[
  {
    "function_name": "__jbd2_journal_drop_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "619-645",
    "snippet": "void __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Dropping transaction %d, all done\\n\"",
            "transaction->t_tid"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_drop_transaction",
          "args": [
            "journal",
            "transaction"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction != transaction"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction != transaction"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "atomic_read(&transaction->t_updates) == 0"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&transaction->t_updates"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_checkpoint_io_list == NULL"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_checkpoint_list == NULL"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_shadow_list == NULL"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_forget == NULL"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_buffers == NULL"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_state == T_FINISHED"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}"
  },
  {
    "function_name": "__jbd2_journal_insert_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "587-607",
    "snippet": "void __jbd2_journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjbd2_journal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_grab_journal_head",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_grab_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2464-2475",
          "snippet": "struct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_cp_transaction == NULL"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh))"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjbd2_journal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}"
  },
  {
    "function_name": "__jbd2_journal_remove_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "527-577",
    "snippet": "int __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_free_transaction",
          "args": [
            "transaction"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_free_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "60-65",
          "snippet": "void jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *transaction_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *transaction_cache;\n\nvoid jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_drop_transaction",
          "args": [
            "journal",
            "transaction"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_drop_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "619-645",
          "snippet": "void __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd2_checkpoint_stats",
          "args": [
            "journal->j_fs_dev->bd_dev",
            "transaction->t_tid",
            "stats"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "stats->cs_chp_time",
            "jiffies"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2507-2520",
          "snippet": "void jbd2_journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__buffer_unlink",
          "args": [
            "jh"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "51-61",
          "snippet": "static inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"removing from transaction\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"not on transaction\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__jbd2_journal_clean_checkpoint_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "466-507",
    "snippet": "void __jbd2_journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\treturn;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret = journal_clean_one_cp_list(transaction->t_checkpoint_list);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn;\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret = journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list);\n\t\tif (need_resched())\n\t\t\treturn;\n\t\t/*\n\t\t * Stop scanning if we couldn't free the transaction. This\n\t\t * avoids pointless scanning of transactions which still\n\t\t * weren't checkpointed.\n\t\t */\n\t\tif (!ret)\n\t\t\treturn;\n\t} while (transaction != last_transaction);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_clean_one_cp_list",
          "args": [
            "transaction->\n\t\t\t\tt_checkpoint_io_list"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clean_one_cp_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "426-457",
          "snippet": "static int journal_clean_one_cp_list(struct journal_head *jh)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret;\n\tint freed = 0;\n\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\tret = __try_to_free_cp_buf(jh);\n\t\tif (!ret)\n\t\t\treturn freed;\n\t\tif (ret == 2)\n\t\t\treturn 1;\n\t\tfreed = 1;\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_clean_one_cp_list(struct journal_head *jh)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret;\n\tint freed = 0;\n\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\tret = __try_to_free_cp_buf(jh);\n\t\tif (!ret)\n\t\t\treturn freed;\n\t\tif (ret == 2)\n\t\t\treturn 1;\n\t\tfreed = 1;\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\treturn;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret = journal_clean_one_cp_list(transaction->t_checkpoint_list);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn;\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret = journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list);\n\t\tif (need_resched())\n\t\t\treturn;\n\t\t/*\n\t\t * Stop scanning if we couldn't free the transaction. This\n\t\t * avoids pointless scanning of transactions which still\n\t\t * weren't checkpointed.\n\t\t */\n\t\tif (!ret)\n\t\t\treturn;\n\t} while (transaction != last_transaction);\n}"
  },
  {
    "function_name": "journal_clean_one_cp_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "426-457",
    "snippet": "static int journal_clean_one_cp_list(struct journal_head *jh)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret;\n\tint freed = 0;\n\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\tret = __try_to_free_cp_buf(jh);\n\t\tif (!ret)\n\t\t\treturn freed;\n\t\tif (ret == 2)\n\t\t\treturn 1;\n\t\tfreed = 1;\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__try_to_free_cp_buf",
          "args": [
            "jh"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "__try_to_free_cp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "92-103",
          "snippet": "static int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_transaction == NULL && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __jbd2_journal_remove_checkpoint(jh) + 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_transaction == NULL && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __jbd2_journal_remove_checkpoint(jh) + 1;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_clean_one_cp_list(struct journal_head *jh)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret;\n\tint freed = 0;\n\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\tret = __try_to_free_cp_buf(jh);\n\t\tif (!ret)\n\t\t\treturn freed;\n\t\tif (ret == 2)\n\t\t\treturn 1;\n\t\tfreed = 1;\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}"
  },
  {
    "function_name": "jbd2_cleanup_journal_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "387-412",
    "snippet": "int jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jbd2_update_log_tail",
          "args": [
            "journal",
            "first_tid",
            "blocknr"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_update_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "888-916",
          "snippet": "void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "journal->j_fs_dev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "blocknr != 0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_log_tail",
          "args": [
            "journal",
            "&first_tid",
            "&blocknr"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "849-876",
          "snippet": "int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_log_do_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "208-367",
    "snippet": "int jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "387-412",
          "snippet": "int jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_abort",
          "args": [
            "journal",
            "result"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2106-2109",
          "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "527-577",
          "snippet": "int __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_write_io_error(bh)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_batch",
          "args": [
            "journal",
            "&batch_count"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "181-198",
          "snippet": "static void\n__flush_batch(journal_t *journal, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(journal->j_chkpt_bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = journal->j_chkpt_bhs[i];\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void\n__flush_batch(journal_t *journal, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(journal->j_chkpt_bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = journal->j_chkpt_bhs[i];\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__buffer_relink_io",
          "args": [
            "jh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_relink_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "68-83",
          "snippet": "static inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_jwrite(bh)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"queue\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"remove from checkpoint\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_write_io_error(bh)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "540-548",
          "snippet": "int jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\"",
            "journal->j_devname",
            "(unsigned long long) bh->b_blocknr"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "journal->j_flags & JBD2_UNMOUNT"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"cleanup_journal_tail returned %d\\n\"",
            "result"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_checkpoint",
          "args": [
            "journal",
            "result"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Start checkpoint\\n\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
  },
  {
    "function_name": "__flush_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "181-198",
    "snippet": "static void\n__flush_batch(journal_t *journal, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(journal->j_chkpt_bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = journal->j_chkpt_bhs[i];\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "journal->j_chkpt_bhs[i]",
            "WRITE_SYNC"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void\n__flush_batch(journal_t *journal, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(journal->j_chkpt_bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = journal->j_chkpt_bhs[i];\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}"
  },
  {
    "function_name": "__jbd2_log_wait_for_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "111-179",
    "snippet": "void __jbd2_log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\t/* assert_spin_locked(&journal->j_state_lock); */\n\n\tnblocks = jbd2_space_needed(journal);\n\twhile (jbd2_log_space_left(journal) < nblocks) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (journal->j_flags & JBD2_ABORT) {\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\treturn;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd2_space_needed(journal);\n\t\tspace_left = jbd2_log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tjbd2_log_do_checkpoint(journal);\n\t\t\t} else if (jbd2_cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\t/*\n\t\t\t\t * jbd2_journal_commit_transaction() may want\n\t\t\t\t * to take the checkpoint_mutex if JBD2_FLUSHED\n\t\t\t\t * is set.  So we need to temporarily drop it.\n\t\t\t\t */\n\t\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space in %s\\n\", __func__,\n\t\t\t\t       journal->j_devname);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjbd2_journal_abort(journal, 0);\n\t\t\t}\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_abort",
          "args": [
            "journal",
            "0"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2106-2109",
          "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space in %s\\n\"",
            "__func__",
            "journal->j_devname"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "387-412",
          "snippet": "int jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "208-367",
          "snippet": "int jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_space_left",
          "args": [
            "journal"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_space_needed",
          "args": [
            "journal"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_log_space_left",
          "args": [
            "journal"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_space_needed",
          "args": [
            "journal"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\t/* assert_spin_locked(&journal->j_state_lock); */\n\n\tnblocks = jbd2_space_needed(journal);\n\twhile (jbd2_log_space_left(journal) < nblocks) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (journal->j_flags & JBD2_ABORT) {\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\treturn;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd2_space_needed(journal);\n\t\tspace_left = jbd2_log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tjbd2_log_do_checkpoint(journal);\n\t\t\t} else if (jbd2_cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\t/*\n\t\t\t\t * jbd2_journal_commit_transaction() may want\n\t\t\t\t * to take the checkpoint_mutex if JBD2_FLUSHED\n\t\t\t\t * is set.  So we need to temporarily drop it.\n\t\t\t\t */\n\t\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space in %s\\n\", __func__,\n\t\t\t\t       journal->j_devname);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjbd2_journal_abort(journal, 0);\n\t\t\t}\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}"
  },
  {
    "function_name": "__try_to_free_cp_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "92-103",
    "snippet": "static int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_transaction == NULL && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __jbd2_journal_remove_checkpoint(jh) + 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jbd2_journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "527-577",
          "snippet": "int __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"remove from checkpoint list\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_transaction == NULL && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __jbd2_journal_remove_checkpoint(jh) + 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__buffer_relink_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "68-83",
    "snippet": "static inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__buffer_unlink_first",
          "args": [
            "jh"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "33-44",
          "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}"
  },
  {
    "function_name": "__buffer_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "51-61",
    "snippet": "static inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__buffer_unlink_first",
          "args": [
            "jh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "33-44",
          "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}"
  },
  {
    "function_name": "__buffer_unlink_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
    "lines": "33-44",
    "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
  }
]