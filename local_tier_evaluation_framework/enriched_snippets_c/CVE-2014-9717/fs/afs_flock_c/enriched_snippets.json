[
  {
    "function_name": "afs_fl_release_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "580-585",
    "snippet": "static void afs_fl_release_private(struct file_lock *fl)\n{\n\t_enter(\"\");\n\n\tlist_del_init(&fl->fl_u.afs.link);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic void afs_fl_release_private(struct file_lock *fl)\n{\n\t_enter(\"\");\n\n\tlist_del_init(&fl->fl_u.afs.link);\n}"
  },
  {
    "function_name": "afs_fl_copy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "569-574",
    "snippet": "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t_enter(\"\");\n\n\tlist_add(&new->fl_u.afs.link, &fl->fl_u.afs.link);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->fl_u.afs.link",
            "&fl->fl_u.afs.link"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t_enter(\"\");\n\n\tlist_add(&new->fl_u.afs.link, &fl->fl_u.afs.link);\n}"
  },
  {
    "function_name": "afs_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "539-561",
    "snippet": "int afs_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\n\t_enter(\"{%x:%u},%d,{t=%x,fl=%x}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags);\n\n\t/*\n\t * No BSD flocks over NFS allowed.\n\t * Note: we could try to fake a POSIX lock request here by\n\t * using ((u32) filp | 0x80000000) or some such as the pid.\n\t * Not sure whether that would be unique, though, or whether\n\t * that would break in other places.\n\t */\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\t/* we're simulating flock() locks using posix locks on the server */\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn afs_do_unlk(file, fl);\n\treturn afs_do_setlk(file, fl);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_do_setlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "253-436",
          "snippet": "static int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [
            "#define AFS_LOCK_PENDING\t1",
            "#define AFS_LOCK_GRANTED\t0"
          ],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);",
            "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_do_unlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_unlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "441-471",
          "snippet": "static int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [
            "#define AFS_LOCK_PENDING\t1"
          ],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);",
            "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%d,{t=%x,fl=%x}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "cmd",
            "fl->fl_type",
            "fl->fl_flags"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nint afs_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\n\t_enter(\"{%x:%u},%d,{t=%x,fl=%x}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags);\n\n\t/*\n\t * No BSD flocks over NFS allowed.\n\t * Note: we could try to fake a POSIX lock request here by\n\t * using ((u32) filp | 0x80000000) or some such as the pid.\n\t * Not sure whether that would be unique, though, or whether\n\t * that would break in other places.\n\t */\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\t/* we're simulating flock() locks using posix locks on the server */\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn afs_do_unlk(file, fl);\n\treturn afs_do_setlk(file, fl);\n}"
  },
  {
    "function_name": "afs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "516-534",
    "snippet": "int afs_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\n\t_enter(\"{%x:%u},%d,{t=%x,fl=%x,r=%Ld:%Ld}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags,\n\t       (long long) fl->fl_start, (long long) fl->fl_end);\n\n\t/* AFS doesn't support mandatory locks */\n\tif (__mandatory_lock(&vnode->vfs_inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif (IS_GETLK(cmd))\n\t\treturn afs_do_getlk(file, fl);\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn afs_do_unlk(file, fl);\n\treturn afs_do_setlk(file, fl);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_do_setlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "253-436",
          "snippet": "static int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [
            "#define AFS_LOCK_PENDING\t1",
            "#define AFS_LOCK_GRANTED\t0"
          ],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);",
            "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_do_unlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_unlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "441-471",
          "snippet": "static int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [
            "#define AFS_LOCK_PENDING\t1"
          ],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);",
            "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_do_getlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_getlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "476-511",
          "snippet": "static int afs_do_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret, lock_count;\n\n\t_enter(\"\");\n\n\tfl->fl_type = F_UNLCK;\n\n\tmutex_lock(&vnode->vfs_inode.i_mutex);\n\n\t/* check local lock records first */\n\tret = 0;\n\tposix_test_lock(file, fl);\n\tif (fl->fl_type == F_UNLCK) {\n\t\t/* no local locks; consult the server */\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tlock_count = vnode->status.lock_count;\n\t\tif (lock_count) {\n\t\t\tif (lock_count > 0)\n\t\t\t\tfl->fl_type = F_RDLCK;\n\t\t\telse\n\t\t\t\tfl->fl_type = F_WRLCK;\n\t\t\tfl->fl_start = 0;\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\t}\n\t}\n\nerror:\n\tmutex_unlock(&vnode->vfs_inode.i_mutex);\n\t_leave(\" = %d [%hd]\", ret, fl->fl_type);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic int afs_do_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret, lock_count;\n\n\t_enter(\"\");\n\n\tfl->fl_type = F_UNLCK;\n\n\tmutex_lock(&vnode->vfs_inode.i_mutex);\n\n\t/* check local lock records first */\n\tret = 0;\n\tposix_test_lock(file, fl);\n\tif (fl->fl_type == F_UNLCK) {\n\t\t/* no local locks; consult the server */\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tlock_count = vnode->status.lock_count;\n\t\tif (lock_count) {\n\t\t\tif (lock_count > 0)\n\t\t\t\tfl->fl_type = F_RDLCK;\n\t\t\telse\n\t\t\t\tfl->fl_type = F_WRLCK;\n\t\t\tfl->fl_start = 0;\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\t}\n\t}\n\nerror:\n\tmutex_unlock(&vnode->vfs_inode.i_mutex);\n\t_leave(\" = %d [%hd]\", ret, fl->fl_type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%d,{t=%x,fl=%x,r=%Ld:%Ld}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "cmd",
            "fl->fl_type",
            "fl->fl_flags",
            "(long long) fl->fl_start",
            "(long long) fl->fl_end"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nint afs_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\n\t_enter(\"{%x:%u},%d,{t=%x,fl=%x,r=%Ld:%Ld}\",\n\t       vnode->fid.vid, vnode->fid.vnode, cmd,\n\t       fl->fl_type, fl->fl_flags,\n\t       (long long) fl->fl_start, (long long) fl->fl_end);\n\n\t/* AFS doesn't support mandatory locks */\n\tif (__mandatory_lock(&vnode->vfs_inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif (IS_GETLK(cmd))\n\t\treturn afs_do_getlk(file, fl);\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn afs_do_unlk(file, fl);\n\treturn afs_do_setlk(file, fl);\n}"
  },
  {
    "function_name": "afs_do_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "476-511",
    "snippet": "static int afs_do_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret, lock_count;\n\n\t_enter(\"\");\n\n\tfl->fl_type = F_UNLCK;\n\n\tmutex_lock(&vnode->vfs_inode.i_mutex);\n\n\t/* check local lock records first */\n\tret = 0;\n\tposix_test_lock(file, fl);\n\tif (fl->fl_type == F_UNLCK) {\n\t\t/* no local locks; consult the server */\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tlock_count = vnode->status.lock_count;\n\t\tif (lock_count) {\n\t\t\tif (lock_count > 0)\n\t\t\t\tfl->fl_type = F_RDLCK;\n\t\t\telse\n\t\t\t\tfl->fl_type = F_WRLCK;\n\t\t\tfl->fl_start = 0;\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\t}\n\t}\n\nerror:\n\tmutex_unlock(&vnode->vfs_inode.i_mutex);\n\t_leave(\" = %d [%hd]\", ret, fl->fl_type);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [%hd]\"",
            "ret",
            "fl->fl_type"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vnode->vfs_inode.i_mutex"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "NULL",
            "key"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "file",
            "fl"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vnode->vfs_inode.i_mutex"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic int afs_do_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret, lock_count;\n\n\t_enter(\"\");\n\n\tfl->fl_type = F_UNLCK;\n\n\tmutex_lock(&vnode->vfs_inode.i_mutex);\n\n\t/* check local lock records first */\n\tret = 0;\n\tposix_test_lock(file, fl);\n\tif (fl->fl_type == F_UNLCK) {\n\t\t/* no local locks; consult the server */\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tlock_count = vnode->status.lock_count;\n\t\tif (lock_count) {\n\t\t\tif (lock_count > 0)\n\t\t\t\tfl->fl_type = F_RDLCK;\n\t\t\telse\n\t\t\t\tfl->fl_type = F_WRLCK;\n\t\t\tfl->fl_start = 0;\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\t}\n\t}\n\nerror:\n\tmutex_unlock(&vnode->vfs_inode.i_mutex);\n\t_leave(\" = %d [%hd]\", ret, fl->fl_type);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_do_unlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "441-471",
    "snippet": "static int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [
      "#define AFS_LOCK_PENDING\t1"
    ],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);",
      "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_defer_unlock",
          "args": [
            "vnode",
            "key"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "afs_defer_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "238-248",
          "snippet": "static void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vnode->granted_locks"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [vfs]\"",
            "ret"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "fl",
            "NULL"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%u\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "fl->fl_type"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_unlk(struct file *file, struct file_lock *fl)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file unlocks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\tspin_lock(&vnode->lock);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" = %d [vfs]\", ret);\n\t\treturn ret;\n\t}\n\n\t/* discard the server lock only if all granted locks are gone */\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_do_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "253-436",
    "snippet": "static int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [
      "#define AFS_LOCK_PENDING\t1",
      "#define AFS_LOCK_GRANTED\t0"
    ],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);",
      "static const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_defer_unlock",
          "args": [
            "vnode",
            "key"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "afs_defer_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "238-248",
          "snippet": "static void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vnode->granted_locks"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"vfs refused %d\"",
            "ret"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "NULL",
            "key"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "fl",
            "NULL"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(vnode->flags & (1 << AFS_VNODE_LOCKING))"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&fl->fl_u.afs.link",
            "&vnode->granted_locks"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_WRITELOCKED",
            "&vnode->flags"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_schedule_lock_extension",
          "args": [
            "vnode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "afs_schedule_lock_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "72-76",
          "snippet": "static void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nstatic void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_lock_may_be_available",
          "args": [
            "vnode"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "afs_lock_may_be_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "61-66",
          "snippet": "void afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"abort\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "ret",
            "==,-ERESTARTSYS"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "fl->fl_u.afs.state <= AFS_LOCK_GRANTED"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fl->fl_u.afs.link",
            "&vnode->pending_locks"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->pending_locks.next",
            "==,&fl->fl_u.afs.link"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&vnode->granted_locks)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_LOCKING",
            "&vnode->flags"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_set_lock",
          "args": [
            "vnode",
            "key",
            "type"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_set_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "915-949",
          "snippet": "int afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fl->fl_u.afs.link",
            "&vnode->pending_locks"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED))",
            "==,0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(&vnode->granted_locks)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED))",
            "==,0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_init_lock_manager",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "afs_init_lock_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "31-47",
          "snippet": "static int afs_init_lock_manager(void)\n{\n\tint ret;\n\n\tret = 0;\n\tif (!afs_lock_manager) {\n\t\tmutex_lock(&afs_lock_manager_mutex);\n\t\tif (!afs_lock_manager) {\n\t\t\tafs_lock_manager =\n\t\t\t\tcreate_singlethread_workqueue(\"kafs_lockd\");\n\t\t\tif (!afs_lock_manager)\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tmutex_unlock(&afs_lock_manager_mutex);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;",
            "static DEFINE_MUTEX(afs_lock_manager_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\nstatic DEFINE_MUTEX(afs_lock_manager_mutex);\n\nstatic int afs_init_lock_manager(void)\n{\n\tint ret;\n\n\tret = 0;\n\tif (!afs_lock_manager) {\n\t\tmutex_lock(&afs_lock_manager_mutex);\n\t\tif (!afs_lock_manager) {\n\t\t\tafs_lock_manager =\n\t\t\t\tcreate_singlethread_workqueue(\"kafs_lockd\");\n\t\t\tif (!afs_lock_manager)\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tmutex_unlock(&afs_lock_manager_mutex);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%u\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "fl->fl_type"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_PENDING\t1\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic const struct file_lock_operations afs_lock_ops = {\n\t.fl_copy_lock\t\t= afs_fl_copy_lock,\n\t.fl_release_private\t= afs_fl_release_private,\n};\n\nstatic int afs_do_setlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_lock_type_t type;\n\tstruct key *key = file->private_data;\n\tint ret;\n\n\t_enter(\"{%x:%u},%u\", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\n\n\t/* only whole-file locks are supported */\n\tif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\n\t\treturn -EINVAL;\n\n\tret = afs_init_lock_manager();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfl->fl_ops = &afs_lock_ops;\n\tINIT_LIST_HEAD(&fl->fl_u.afs.link);\n\tfl->fl_u.afs.state = AFS_LOCK_PENDING;\n\n\ttype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\n\n\tspin_lock(&inode->i_lock);\n\n\t/* make sure we've got a callback on this file and that our view of the\n\t * data version is up to date */\n\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&vnode->lock);\n\n\t/* if we've already got a readlock on the server then we can instantly\n\t * grant another readlock, irrespective of whether there are any\n\t * pending writelocks */\n\tif (type == AFS_LOCK_READ &&\n\t    vnode->flags & (1 << AFS_VNODE_READLOCKED)) {\n\t\t_debug(\"instant readlock\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tASSERT(!list_empty(&vnode->granted_locks));\n\t\tgoto sharing_existing_lock;\n\t}\n\n\t/* if there's no-one else with a lock on this vnode, then we need to\n\t * ask the server for a lock */\n\tif (list_empty(&vnode->pending_locks) &&\n\t    list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"not locked\");\n\t\tASSERTCMP(vnode->flags &\n\t\t\t  ((1 << AFS_VNODE_LOCKING) |\n\t\t\t   (1 << AFS_VNODE_READLOCKED) |\n\t\t\t   (1 << AFS_VNODE_WRITELOCKED)), ==, 0);\n\t\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\n\t\tset_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tgoto acquired_server_lock;\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"would block\");\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tASSERT(list_empty(&vnode->granted_locks));\n\t\t\tASSERTCMP(vnode->pending_locks.next, ==,\n\t\t\t\t  &fl->fl_u.afs.link);\n\t\t\tgoto wait;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* otherwise, we need to wait for a local lock to become available */\n\t_debug(\"wait local\");\n\tlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\nwait:\n\tif (!(fl->fl_flags & FL_SLEEP)) {\n\t\t_debug(\"noblock\");\n\t\tret = -EAGAIN;\n\t\tgoto abort_attempt;\n\t}\n\tspin_unlock(&vnode->lock);\n\n\t/* now we need to sleep and wait for the lock manager thread to get the\n\t * lock from the server */\n\t_debug(\"sleep\");\n\tret = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t       fl->fl_u.afs.state <= AFS_LOCK_GRANTED);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vnode->lock);\n\t\tgoto given_lock;\n\t}\n\n\t/* we were interrupted, but someone may still be in the throes of\n\t * giving us the lock */\n\t_debug(\"intr\");\n\tASSERTCMP(ret, ==, -ERESTARTSYS);\n\n\tspin_lock(&vnode->lock);\n\tif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\n\t\tret = fl->fl_u.afs.state;\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto given_lock;\n\t}\n\nabort_attempt:\n\t/* we aren't going to get the lock, either because we're unwilling to\n\t * wait, or because some signal happened */\n\t_debug(\"abort\");\n\tif (list_empty(&vnode->granted_locks) &&\n\t    vnode->pending_locks.next == &fl->fl_u.afs.link) {\n\t\tif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\n\t\t\t/* kick the next pending lock into having a go */\n\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\tafs_lock_may_be_available(vnode);\n\t\t}\n\t} else {\n\t\tlist_del_init(&fl->fl_u.afs.link);\n\t}\n\tspin_unlock(&vnode->lock);\n\tgoto error;\n\nacquired_server_lock:\n\t/* we've acquired a server lock, but it needs to be renewed after 5\n\t * mins */\n\tspin_lock(&vnode->lock);\n\tafs_schedule_lock_extension(vnode);\n\tif (type == AFS_LOCK_READ)\n\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\telse\n\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\nsharing_existing_lock:\n\t/* the lock has been granted as far as we're concerned... */\n\tfl->fl_u.afs.state = AFS_LOCK_GRANTED;\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\ngiven_lock:\n\t/* ... but we do still need to get the VFS's blessing */\n\tASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\n\tASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\n\t\t\t\t(1 << AFS_VNODE_WRITELOCKED))) != 0);\n\tret = posix_lock_file(file, fl, NULL);\n\tif (ret < 0)\n\t\tgoto vfs_rejected_lock;\n\tspin_unlock(&vnode->lock);\n\n\t/* again, make sure we've got a callback on this file and, again, make\n\t * sure that our view of the data version is up to date (we ignore\n\t * errors incurred here and deal with the consequences elsewhere) */\n\tafs_vnode_fetch_status(vnode, NULL, key);\n\nerror:\n\tspin_unlock(&inode->i_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nvfs_rejected_lock:\n\t/* the VFS rejected the lock we just obtained, so we have to discard\n\t * what we just got */\n\t_debug(\"vfs refused %d\", ret);\n\tlist_del_init(&fl->fl_u.afs.link);\n\tif (list_empty(&vnode->granted_locks))\n\t\tafs_defer_unlock(vnode, key);\n\tgoto abort_attempt;\n}"
  },
  {
    "function_name": "afs_defer_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "238-248",
    "snippet": "static void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_lock_may_be_available",
          "args": [
            "vnode"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "afs_lock_may_be_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "61-66",
          "snippet": "void afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "key"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "AFS_VNODE_UNLOCKING",
            "&vnode->flags"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AFS_VNODE_WRITELOCKED",
            "&vnode->flags"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&vnode->lock_work"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\n{\n\tcancel_delayed_work(&vnode->lock_work);\n\tif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\n\t    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\n\t\tBUG();\n\tif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\n\t\tBUG();\n\tvnode->unlock_key = key_get(key);\n\tafs_lock_may_be_available(vnode);\n}"
  },
  {
    "function_name": "afs_lock_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "106-230",
    "snippet": "void afs_lock_work(struct work_struct *work)\n{\n\tstruct afs_vnode *vnode =\n\t\tcontainer_of(work, struct afs_vnode, lock_work.work);\n\tstruct file_lock *fl;\n\tafs_lock_type_t type;\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tspin_lock(&vnode->lock);\n\n\tif (test_bit(AFS_VNODE_UNLOCKING, &vnode->flags)) {\n\t\t_debug(\"unlock\");\n\t\tspin_unlock(&vnode->lock);\n\n\t\t/* attempt to release the server lock; if it fails, we just\n\t\t * wait 5 minutes and it'll time out anyway */\n\t\tret = afs_vnode_release_lock(vnode, vnode->unlock_key);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to release lock on {%x:%x} error %d\\n\",\n\t\t\t       vnode->fid.vid, vnode->fid.vnode, ret);\n\n\t\tspin_lock(&vnode->lock);\n\t\tkey_put(vnode->unlock_key);\n\t\tvnode->unlock_key = NULL;\n\t\tclear_bit(AFS_VNODE_UNLOCKING, &vnode->flags);\n\t}\n\n\t/* if we've got a lock, then it must be time to extend that lock as AFS\n\t * locks time out after 5 minutes */\n\tif (!list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"extend\");\n\n\t\tif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\n\t\t\tBUG();\n\t\tfl = list_entry(vnode->granted_locks.next,\n\t\t\t\tstruct file_lock, fl_u.afs.link);\n\t\tkey = key_get(fl->fl_file->private_data);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_extend_lock(vnode, key);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tkey_put(key);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tafs_schedule_lock_extension(vnode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ummm... we failed to extend the lock - retry\n\t\t\t * extension shortly */\n\t\t\tprintk(KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to extend lock on {%x:%x} error %d\\n\",\n\t\t\t       vnode->fid.vid, vnode->fid.vnode, ret);\n\t\t\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t\t\t   HZ * 10);\n\t\t\tbreak;\n\t\t}\n\t\t_leave(\" [extend]\");\n\t\treturn;\n\t}\n\n\t/* if we don't have a granted lock, then we must've been called back by\n\t * the server, and so if might be possible to get a lock we're\n\t * currently waiting for */\n\tif (!list_empty(&vnode->pending_locks)) {\n\t\t_debug(\"get\");\n\n\t\tif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\n\t\t\tBUG();\n\t\tfl = list_entry(vnode->pending_locks.next,\n\t\t\t\tstruct file_lock, fl_u.afs.link);\n\t\tkey = key_get(fl->fl_file->private_data);\n\t\ttype = (fl->fl_type == F_RDLCK) ?\n\t\t\tAFS_LOCK_READ : AFS_LOCK_WRITE;\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"blocked\");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tif (type == AFS_LOCK_READ)\n\t\t\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\t\t\telse\n\t\t\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\n\t\t\tret = AFS_LOCK_GRANTED;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\t/* the pending lock may have been withdrawn due to a\n\t\t\t * signal */\n\t\t\tif (list_entry(vnode->pending_locks.next,\n\t\t\t\t       struct file_lock, fl_u.afs.link) == fl) {\n\t\t\t\tfl->fl_u.afs.state = ret;\n\t\t\t\tif (ret == AFS_LOCK_GRANTED)\n\t\t\t\t\tafs_grant_locks(vnode, fl);\n\t\t\t\telse\n\t\t\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\t\twake_up(&fl->fl_wait);\n\t\t\t\tspin_unlock(&vnode->lock);\n\t\t\t} else {\n\t\t\t\t_debug(\"withdrawn\");\n\t\t\t\tclear_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\t\t\t\tclear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\n\t\t\t\tspin_unlock(&vnode->lock);\n\t\t\t\tafs_vnode_release_lock(vnode, key);\n\t\t\t\tif (!list_empty(&vnode->pending_locks))\n\t\t\t\t\tafs_lock_may_be_available(vnode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tkey_put(key);\n\t\t_leave(\" [pend]\");\n\t\treturn;\n\t}\n\n\t/* looks like the lock request was withdrawn on a signal */\n\tspin_unlock(&vnode->lock);\n\t_leave(\" [no locks]\");\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [
      "#define AFS_LOCK_GRANTED\t0"
    ],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);",
      "static struct workqueue_struct *afs_lock_manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [no locks]\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_lock_may_be_available",
          "args": [
            "vnode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "afs_lock_may_be_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "61-66",
          "snippet": "void afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vnode->pending_locks"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_release_lock",
          "args": [
            "vnode",
            "key"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_release_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "992-1025",
          "snippet": "int afs_vnode_release_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_release_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_release_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_release_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_WRITELOCKED",
            "&vnode->flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"withdrawn\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fl->fl_wait"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.afs.link"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_grant_locks",
          "args": [
            "vnode",
            "fl"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "afs_grant_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "83-99",
          "snippet": "static void afs_grant_locks(struct afs_vnode *vnode, struct file_lock *fl)\n{\n\tstruct file_lock *p, *_p;\n\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\tif (fl->fl_type == F_RDLCK) {\n\t\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks,\n\t\t\t\t\t fl_u.afs.link) {\n\t\t\tif (p->fl_type == F_RDLCK) {\n\t\t\t\tp->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\t\tlist_move_tail(&p->fl_u.afs.link,\n\t\t\t\t\t       &vnode->granted_locks);\n\t\t\t\twake_up(&p->fl_wait);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [
            "#define AFS_LOCK_GRANTED\t0"
          ],
          "globals_used": [
            "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
            "static void afs_fl_release_private(struct file_lock *fl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic void afs_grant_locks(struct afs_vnode *vnode, struct file_lock *fl)\n{\n\tstruct file_lock *p, *_p;\n\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\tif (fl->fl_type == F_RDLCK) {\n\t\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks,\n\t\t\t\t\t fl_u.afs.link) {\n\t\t\tif (p->fl_type == F_RDLCK) {\n\t\t\t\tp->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\t\tlist_move_tail(&p->fl_u.afs.link,\n\t\t\t\t\t       &vnode->granted_locks);\n\t\t\t\twake_up(&p->fl_wait);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "vnode->pending_locks.next",
            "structfile_lock",
            "fl_u.afs.link"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_WRITELOCKED",
            "&vnode->flags"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_set_lock",
          "args": [
            "vnode",
            "key",
            "type"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_set_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "915-949",
          "snippet": "int afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "fl->fl_file->private_data"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "vnode->pending_locks.next",
            "structfile_lock",
            "fl_u.afs.link"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "AFS_VNODE_LOCKING",
            "&vnode->flags"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_lock_manager",
            "&vnode->lock_work",
            "HZ * 10"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to extend lock on {%x:%x} error %d\\n\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "ret"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_schedule_lock_extension",
          "args": [
            "vnode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "afs_schedule_lock_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "72-76",
          "snippet": "static void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nstatic void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_extend_lock",
          "args": [
            "vnode",
            "key"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_extend_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "954-987",
          "snippet": "int afs_vnode_extend_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_extend_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_extend_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_extend_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "fl->fl_file->private_data"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "vnode->granted_locks.next",
            "structfile_lock",
            "fl_u.afs.link"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_UNLOCKING",
            "&vnode->flags"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_vnode",
            "lock_work.work"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid afs_lock_work(struct work_struct *work)\n{\n\tstruct afs_vnode *vnode =\n\t\tcontainer_of(work, struct afs_vnode, lock_work.work);\n\tstruct file_lock *fl;\n\tafs_lock_type_t type;\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tspin_lock(&vnode->lock);\n\n\tif (test_bit(AFS_VNODE_UNLOCKING, &vnode->flags)) {\n\t\t_debug(\"unlock\");\n\t\tspin_unlock(&vnode->lock);\n\n\t\t/* attempt to release the server lock; if it fails, we just\n\t\t * wait 5 minutes and it'll time out anyway */\n\t\tret = afs_vnode_release_lock(vnode, vnode->unlock_key);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to release lock on {%x:%x} error %d\\n\",\n\t\t\t       vnode->fid.vid, vnode->fid.vnode, ret);\n\n\t\tspin_lock(&vnode->lock);\n\t\tkey_put(vnode->unlock_key);\n\t\tvnode->unlock_key = NULL;\n\t\tclear_bit(AFS_VNODE_UNLOCKING, &vnode->flags);\n\t}\n\n\t/* if we've got a lock, then it must be time to extend that lock as AFS\n\t * locks time out after 5 minutes */\n\tif (!list_empty(&vnode->granted_locks)) {\n\t\t_debug(\"extend\");\n\n\t\tif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\n\t\t\tBUG();\n\t\tfl = list_entry(vnode->granted_locks.next,\n\t\t\t\tstruct file_lock, fl_u.afs.link);\n\t\tkey = key_get(fl->fl_file->private_data);\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_extend_lock(vnode, key);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tkey_put(key);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tafs_schedule_lock_extension(vnode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ummm... we failed to extend the lock - retry\n\t\t\t * extension shortly */\n\t\t\tprintk(KERN_WARNING \"AFS:\"\n\t\t\t       \" Failed to extend lock on {%x:%x} error %d\\n\",\n\t\t\t       vnode->fid.vid, vnode->fid.vnode, ret);\n\t\t\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t\t\t   HZ * 10);\n\t\t\tbreak;\n\t\t}\n\t\t_leave(\" [extend]\");\n\t\treturn;\n\t}\n\n\t/* if we don't have a granted lock, then we must've been called back by\n\t * the server, and so if might be possible to get a lock we're\n\t * currently waiting for */\n\tif (!list_empty(&vnode->pending_locks)) {\n\t\t_debug(\"get\");\n\n\t\tif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\n\t\t\tBUG();\n\t\tfl = list_entry(vnode->pending_locks.next,\n\t\t\t\tstruct file_lock, fl_u.afs.link);\n\t\tkey = key_get(fl->fl_file->private_data);\n\t\ttype = (fl->fl_type == F_RDLCK) ?\n\t\t\tAFS_LOCK_READ : AFS_LOCK_WRITE;\n\t\tspin_unlock(&vnode->lock);\n\n\t\tret = afs_vnode_set_lock(vnode, key, type);\n\t\tclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\n\t\tswitch (ret) {\n\t\tcase -EWOULDBLOCK:\n\t\t\t_debug(\"blocked\");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t_debug(\"acquired\");\n\t\t\tif (type == AFS_LOCK_READ)\n\t\t\t\tset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\t\t\telse\n\t\t\t\tset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\n\t\t\tret = AFS_LOCK_GRANTED;\n\t\tdefault:\n\t\t\tspin_lock(&vnode->lock);\n\t\t\t/* the pending lock may have been withdrawn due to a\n\t\t\t * signal */\n\t\t\tif (list_entry(vnode->pending_locks.next,\n\t\t\t\t       struct file_lock, fl_u.afs.link) == fl) {\n\t\t\t\tfl->fl_u.afs.state = ret;\n\t\t\t\tif (ret == AFS_LOCK_GRANTED)\n\t\t\t\t\tafs_grant_locks(vnode, fl);\n\t\t\t\telse\n\t\t\t\t\tlist_del_init(&fl->fl_u.afs.link);\n\t\t\t\twake_up(&fl->fl_wait);\n\t\t\t\tspin_unlock(&vnode->lock);\n\t\t\t} else {\n\t\t\t\t_debug(\"withdrawn\");\n\t\t\t\tclear_bit(AFS_VNODE_READLOCKED, &vnode->flags);\n\t\t\t\tclear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\n\t\t\t\tspin_unlock(&vnode->lock);\n\t\t\t\tafs_vnode_release_lock(vnode, key);\n\t\t\t\tif (!list_empty(&vnode->pending_locks))\n\t\t\t\t\tafs_lock_may_be_available(vnode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tkey_put(key);\n\t\t_leave(\" [pend]\");\n\t\treturn;\n\t}\n\n\t/* looks like the lock request was withdrawn on a signal */\n\tspin_unlock(&vnode->lock);\n\t_leave(\" [no locks]\");\n}"
  },
  {
    "function_name": "afs_grant_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "83-99",
    "snippet": "static void afs_grant_locks(struct afs_vnode *vnode, struct file_lock *fl)\n{\n\tstruct file_lock *p, *_p;\n\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\tif (fl->fl_type == F_RDLCK) {\n\t\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks,\n\t\t\t\t\t fl_u.afs.link) {\n\t\t\tif (p->fl_type == F_RDLCK) {\n\t\t\t\tp->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\t\tlist_move_tail(&p->fl_u.afs.link,\n\t\t\t\t\t       &vnode->granted_locks);\n\t\t\t\twake_up(&p->fl_wait);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [
      "#define AFS_LOCK_GRANTED\t0"
    ],
    "globals_used": [
      "static void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);",
      "static void afs_fl_release_private(struct file_lock *fl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&p->fl_wait"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&p->fl_u.afs.link",
            "&vnode->granted_locks"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "_p",
            "&vnode->pending_locks",
            "fl_u.afs.link"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&fl->fl_u.afs.link",
            "&vnode->granted_locks"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\n#define AFS_LOCK_GRANTED\t0\n\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl);\nstatic void afs_fl_release_private(struct file_lock *fl);\n\nstatic void afs_grant_locks(struct afs_vnode *vnode, struct file_lock *fl)\n{\n\tstruct file_lock *p, *_p;\n\n\tlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\n\tif (fl->fl_type == F_RDLCK) {\n\t\tlist_for_each_entry_safe(p, _p, &vnode->pending_locks,\n\t\t\t\t\t fl_u.afs.link) {\n\t\t\tif (p->fl_type == F_RDLCK) {\n\t\t\t\tp->fl_u.afs.state = AFS_LOCK_GRANTED;\n\t\t\t\tlist_move_tail(&p->fl_u.afs.link,\n\t\t\t\t\t       &vnode->granted_locks);\n\t\t\t\twake_up(&p->fl_wait);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "afs_schedule_lock_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "72-76",
    "snippet": "static void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_lock_manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_lock_manager",
            "&vnode->lock_work",
            "AFS_LOCKWAIT * HZ / 2"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nstatic void afs_schedule_lock_extension(struct afs_vnode *vnode)\n{\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\n\t\t\t   AFS_LOCKWAIT * HZ / 2);\n}"
  },
  {
    "function_name": "afs_lock_may_be_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "61-66",
    "snippet": "void afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_lock_manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_lock_manager",
            "&vnode->lock_work",
            "0"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\n{\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\n}"
  },
  {
    "function_name": "afs_kill_lock_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "52-56",
    "snippet": "void __exit afs_kill_lock_manager(void)\n{\n\tif (afs_lock_manager)\n\t\tdestroy_workqueue(afs_lock_manager);\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_lock_manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_lock_manager"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid __exit afs_kill_lock_manager(void)\n{\n\tif (afs_lock_manager)\n\t\tdestroy_workqueue(afs_lock_manager);\n}"
  },
  {
    "function_name": "afs_init_lock_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
    "lines": "31-47",
    "snippet": "static int afs_init_lock_manager(void)\n{\n\tint ret;\n\n\tret = 0;\n\tif (!afs_lock_manager) {\n\t\tmutex_lock(&afs_lock_manager_mutex);\n\t\tif (!afs_lock_manager) {\n\t\t\tafs_lock_manager =\n\t\t\t\tcreate_singlethread_workqueue(\"kafs_lockd\");\n\t\t\tif (!afs_lock_manager)\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tmutex_unlock(&afs_lock_manager_mutex);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_lock_manager;",
      "static DEFINE_MUTEX(afs_lock_manager_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&afs_lock_manager_mutex"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"kafs_lockd\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&afs_lock_manager_mutex"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\nstatic DEFINE_MUTEX(afs_lock_manager_mutex);\n\nstatic int afs_init_lock_manager(void)\n{\n\tint ret;\n\n\tret = 0;\n\tif (!afs_lock_manager) {\n\t\tmutex_lock(&afs_lock_manager_mutex);\n\t\tif (!afs_lock_manager) {\n\t\t\tafs_lock_manager =\n\t\t\t\tcreate_singlethread_workqueue(\"kafs_lockd\");\n\t\t\tif (!afs_lock_manager)\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tmutex_unlock(&afs_lock_manager_mutex);\n\t}\n\treturn ret;\n}"
  }
]