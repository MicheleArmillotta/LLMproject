[
  {
    "function_name": "nilfs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/file.c",
    "lines": "133-138",
    "snippet": "static int nilfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tvma->vm_ops = &nilfs_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct nilfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= nilfs_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic const struct vm_operations_struct nilfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= nilfs_page_mkwrite,\n};\n\nstatic int nilfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tvma->vm_ops = &nilfs_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/file.c",
    "lines": "59-125",
    "snippet": "static int nilfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct nilfs_transaction_info ti;\n\tint ret = 0;\n\n\tif (unlikely(nilfs_near_disk_full(inode->i_sb->s_fs_info)))\n\t\treturn VM_FAULT_SIGBUS; /* -ENOSPC */\n\n\tsb_start_pagefault(inode->i_sb);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping ||\n\t    page_offset(page) >= i_size_read(inode) || !PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tret = -EFAULT;\t/* make the VM retry the fault */\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check to see if the page is mapped already (no holes)\n\t */\n\tif (PageMappedToDisk(page))\n\t\tgoto mapped;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\t\tint fully_mapped = 1;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tfully_mapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (fully_mapped) {\n\t\t\tSetPageMappedToDisk(page);\n\t\t\tgoto mapped;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\t/*\n\t * fill hole blocks\n\t */\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t/* never returns -ENOMEM, but may return -ENOSPC */\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tfile_update_time(vma->vm_file);\n\tret = __block_page_mkwrite(vma, vmf, nilfs_get_block);\n\tif (ret) {\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t\tgoto out;\n\t}\n\tnilfs_set_file_dirty(inode, 1 << (PAGE_SHIFT - inode->i_blkbits));\n\tnilfs_transaction_commit(inode->i_sb);\n\n mapped:\n\twait_for_stable_page(page);\n out:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(ret);\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "ret"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_file_dirty",
          "args": [
            "inode",
            "1 << (PAGE_SHIFT - inode->i_blkbits)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_file_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "927-957",
          "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_page_mkwrite",
          "args": [
            "vma",
            "vmf",
            "nilfs_get_block"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__block_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2402-2438",
          "snippet": "int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "1"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nilfs_near_disk_full(inode->i_sb->s_fs_info)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_near_disk_full",
          "args": [
            "inode->i_sb->s_fs_info"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_near_disk_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "708-717",
          "snippet": "int nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int nilfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct nilfs_transaction_info ti;\n\tint ret = 0;\n\n\tif (unlikely(nilfs_near_disk_full(inode->i_sb->s_fs_info)))\n\t\treturn VM_FAULT_SIGBUS; /* -ENOSPC */\n\n\tsb_start_pagefault(inode->i_sb);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping ||\n\t    page_offset(page) >= i_size_read(inode) || !PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tret = -EFAULT;\t/* make the VM retry the fault */\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check to see if the page is mapped already (no holes)\n\t */\n\tif (PageMappedToDisk(page))\n\t\tgoto mapped;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\t\tint fully_mapped = 1;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tfully_mapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (fully_mapped) {\n\t\t\tSetPageMappedToDisk(page);\n\t\t\tgoto mapped;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\t/*\n\t * fill hole blocks\n\t */\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t/* never returns -ENOMEM, but may return -ENOSPC */\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tfile_update_time(vma->vm_file);\n\tret = __block_page_mkwrite(vma, vmf, nilfs_get_block);\n\tif (ret) {\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t\tgoto out;\n\t}\n\tnilfs_set_file_dirty(inode, 1 << (PAGE_SHIFT - inode->i_blkbits));\n\tnilfs_transaction_commit(inode->i_sb);\n\n mapped:\n\twait_for_stable_page(page);\n out:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(ret);\n}"
  },
  {
    "function_name": "nilfs_sync_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/file.c",
    "lines": "30-57",
    "snippet": "int nilfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\t/*\n\t * Called from fsync() system call\n\t * This is the only entry point that can catch write and synch\n\t * timing for both data blocks and intermediate blocks.\n\t *\n\t * This function should be implemented when the writeback function\n\t * will be implemented.\n\t */\n\tstruct the_nilfs *nilfs;\n\tstruct inode *inode = file->f_mapping->host;\n\tint err = 0;\n\n\tif (nilfs_inode_dirty(inode)) {\n\t\tif (datasync)\n\t\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t\t    start, end);\n\t\telse\n\t\t\terr = nilfs_construct_segment(inode->i_sb);\n\t}\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_flush_device",
          "args": [
            "nilfs"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_flush_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "376-394",
          "snippet": "static inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "inode->i_sb"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_construct_dsync_segment",
          "args": [
            "inode->i_sb",
            "inode",
            "start",
            "end"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_dsync_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2205-2247",
          "snippet": "int nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "912-925",
          "snippet": "int nilfs_inode_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tint ret = 0;\n\n\tif (!list_empty(&ii->i_dirty)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tret = test_bit(NILFS_I_DIRTY, &ii->i_state) ||\n\t\t\ttest_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_inode_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tint ret = 0;\n\n\tif (!list_empty(&ii->i_dirty)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tret = test_bit(NILFS_I_DIRTY, &ii->i_state) ||\n\t\t\ttest_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint nilfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\t/*\n\t * Called from fsync() system call\n\t * This is the only entry point that can catch write and synch\n\t * timing for both data blocks and intermediate blocks.\n\t *\n\t * This function should be implemented when the writeback function\n\t * will be implemented.\n\t */\n\tstruct the_nilfs *nilfs;\n\tstruct inode *inode = file->f_mapping->host;\n\tint err = 0;\n\n\tif (nilfs_inode_dirty(inode)) {\n\t\tif (datasync)\n\t\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t\t    start, end);\n\t\telse\n\t\t\terr = nilfs_construct_segment(inode->i_sb);\n\t}\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}"
  }
]