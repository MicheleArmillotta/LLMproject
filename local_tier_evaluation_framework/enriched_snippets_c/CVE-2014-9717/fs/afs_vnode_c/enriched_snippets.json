[
  {
    "function_name": "afs_vnode_release_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "992-1025",
    "snippet": "int afs_vnode_release_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_release_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_release_lock",
          "args": [
            "server",
            "key",
            "vnode",
            "&afs_sync_call"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_release_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1884-1911",
          "snippet": "int afs_fs_release_lock(struct afs_server *server,\n\t\t\tstruct key *key,\n\t\t\tstruct afs_vnode *vnode,\n\t\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSReleaseLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRELEASELOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSReleaseLock = {\n\t.name\t\t= \"FS.ReleaseLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSReleaseLock = {\n\t.name\t\t= \"FS.ReleaseLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_release_lock(struct afs_server *server,\n\t\t\tstruct key *key,\n\t\t\tstruct afs_vnode *vnode,\n\t\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSReleaseLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRELEASELOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_release_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_release_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_extend_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "954-987",
    "snippet": "int afs_vnode_extend_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_extend_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_extend_lock",
          "args": [
            "server",
            "key",
            "vnode",
            "&afs_sync_call"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_extend_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1852-1879",
          "snippet": "int afs_fs_extend_lock(struct afs_server *server,\n\t\t       struct key *key,\n\t\t       struct afs_vnode *vnode,\n\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSExtendLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSEXTENDLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSExtendLock = {\n\t.name\t\t= \"FS.ExtendLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSExtendLock = {\n\t.name\t\t= \"FS.ExtendLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_extend_lock(struct afs_server *server,\n\t\t       struct key *key,\n\t\t       struct afs_vnode *vnode,\n\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSExtendLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSEXTENDLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_extend_lock(struct afs_vnode *vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_extend_lock(server, key, vnode, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_set_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "915-949",
    "snippet": "int afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_set_lock",
          "args": [
            "server",
            "key",
            "vnode",
            "type",
            "&afs_sync_call"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_set_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1818-1847",
          "snippet": "int afs_fs_set_lock(struct afs_server *server,\n\t\t    struct key *key,\n\t\t    struct afs_vnode *vnode,\n\t\t    afs_lock_type_t type,\n\t\t    const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSetLock, 5 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSETLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(type);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSSetLock = {\n\t.name\t\t= \"FS.SetLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSSetLock = {\n\t.name\t\t= \"FS.SetLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_set_lock(struct afs_server *server,\n\t\t    struct key *key,\n\t\t    struct afs_vnode *vnode,\n\t\t    afs_lock_type_t type,\n\t\t    const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSetLock, 5 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSETLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(type);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,%u\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)",
            "type"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\n\t\t       afs_lock_type_t type)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%u\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key), type);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_get_volume_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "876-910",
    "snippet": "int afs_vnode_get_volume_status(struct afs_vnode *vnode, struct key *key,\n\t\t\t\tstruct afs_volume_status *vs)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_get_volume_status(server, key, vnode, vs, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_get_volume_status",
          "args": [
            "server",
            "key",
            "vnode",
            "vs",
            "&afs_sync_call"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_get_volume_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1723-1758",
          "snippet": "int afs_fs_get_volume_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volume_status *vs,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tvoid *tmpbuf;\n\n\t_enter(\"\");\n\n\ttmpbuf = kmalloc(AFSOPAQUEMAX, GFP_KERNEL);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGetVolumeStatus, 2 * 4, 12 * 4);\n\tif (!call) {\n\t\tkfree(tmpbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = vs;\n\tcall->reply3 = tmpbuf;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSGETVOLUMESTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSGetVolumeStatus = {\n\t.name\t\t= \"FS.GetVolumeStatus\",\n\t.deliver\t= afs_deliver_fs_get_volume_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_get_volume_status_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSGetVolumeStatus = {\n\t.name\t\t= \"FS.GetVolumeStatus\",\n\t.deliver\t= afs_deliver_fs_get_volume_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_get_volume_status_call_destructor,\n};\n\nint afs_fs_get_volume_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volume_status *vs,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tvoid *tmpbuf;\n\n\t_enter(\"\");\n\n\ttmpbuf = kmalloc(AFSOPAQUEMAX, GFP_KERNEL);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGetVolumeStatus, 2 * 4, 12 * 4);\n\tif (!call) {\n\t\tkfree(tmpbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = vs;\n\tcall->reply3 = tmpbuf;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSGETVOLUMESTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_get_volume_status(struct afs_vnode *vnode, struct key *key,\n\t\t\t\tstruct afs_volume_status *vs)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_get_volume_status(server, key, vnode, vs, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0)\n\t\tafs_put_server(server);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "824-871",
    "snippet": "int afs_vnode_setattr(struct afs_vnode *vnode, struct key *key,\n\t\t      struct iattr *attr)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_setattr(server, key, vnode, attr, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_setattr",
          "args": [
            "server",
            "key",
            "vnode",
            "attr",
            "&afs_sync_call"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1447-1483",
          "snippet": "int afs_fs_setattr(struct afs_server *server, struct key *key,\n\t\t   struct afs_vnode *vnode, struct iattr *attr,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn afs_fs_setattr_size(server, key, vnode, attr,\n\t\t\t\t\t   wait_mode);\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreStatus,\n\t\t\t\t   (4 + 6) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSSTORESTATUS;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTORESTATUS);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSStoreStatus = {\n\t.name\t\t= \"FS.StoreStatus\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreStatus = {\n\t.name\t\t= \"FS.StoreStatus\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_setattr(struct afs_server *server, struct key *key,\n\t\t   struct afs_vnode *vnode, struct iattr *attr,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn afs_fs_setattr_size(server, key, vnode, attr,\n\t\t\t\t\t   wait_mode);\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreStatus,\n\t\t\t\t   (4 + 6) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSSTORESTATUS;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTORESTATUS);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_setattr(struct afs_vnode *vnode, struct key *key,\n\t\t      struct iattr *attr)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_setattr(server, key, vnode, attr, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_store_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "769-819",
    "snippet": "int afs_vnode_store_data(struct afs_writeback *wb, pgoff_t first, pgoff_t last,\n\t\t\t unsigned offset, unsigned to)\n{\n\tstruct afs_server *server;\n\tstruct afs_vnode *vnode = wb->vnode;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%lx,%lx,%x,%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(wb->key),\n\t       first, last, offset, to);\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_store_data(server, wb, first, last, offset, to,\n\t\t\t\t\t&afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_store_data",
          "args": [
            "server",
            "wb",
            "first",
            "last",
            "offset",
            "to",
            "&afs_sync_call"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_store_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1215-1284",
          "snippet": "int afs_fs_store_data(struct afs_server *server, struct afs_writeback *wb,\n\t\t      pgoff_t first, pgoff_t last,\n\t\t      unsigned offset, unsigned to,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\tloff_t size, pos, i_size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tsize = to - offset;\n\tif (first != last)\n\t\tsize += (loff_t)(last - first) << PAGE_SHIFT;\n\tpos = (loff_t)first << PAGE_SHIFT;\n\tpos += offset;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + size > i_size)\n\t\ti_size = size + pos;\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long) size, (unsigned long long) pos,\n\t       (unsigned long long) i_size);\n\n\tif (pos >> 32 || i_size >> 32 || size >> 32 || (pos + size) >> 32)\n\t\treturn afs_fs_store_data64(server, wb, first, last, offset, to,\n\t\t\t\t\t   size, pos, i_size, wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos);\n\t*bp++ = htonl(size);\n\t*bp++ = htonl(i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSStoreData = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_store_data(struct afs_server *server, struct afs_writeback *wb,\n\t\t      pgoff_t first, pgoff_t last,\n\t\t      unsigned offset, unsigned to,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\tloff_t size, pos, i_size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tsize = to - offset;\n\tif (first != last)\n\t\tsize += (loff_t)(last - first) << PAGE_SHIFT;\n\tpos = (loff_t)first << PAGE_SHIFT;\n\tpos += offset;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + size > i_size)\n\t\ti_size = size + pos;\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long) size, (unsigned long long) pos,\n\t       (unsigned long long) i_size);\n\n\tif (pos >> 32 || i_size >> 32 || size >> 32 || (pos + size) >> 32)\n\t\treturn afs_fs_store_data64(server, wb, first, last, offset, to,\n\t\t\t\t\t   size, pos, i_size, wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos);\n\t*bp++ = htonl(size);\n\t*bp++ = htonl(i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,%lx,%lx,%x,%x\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(wb->key)",
            "first",
            "last",
            "offset",
            "to"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "wb->key"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_store_data(struct afs_writeback *wb, pgoff_t first, pgoff_t last,\n\t\t\t unsigned offset, unsigned to)\n{\n\tstruct afs_server *server;\n\tstruct afs_vnode *vnode = wb->vnode;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%lx,%lx,%x,%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(wb->key),\n\t       first, last, offset, to);\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_store_data(server, wb, first, last, offset, to,\n\t\t\t\t\t&afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "690-764",
    "snippet": "int afs_vnode_rename(struct afs_vnode *orig_dvnode,\n\t\t     struct afs_vnode *new_dvnode,\n\t\t     struct key *key,\n\t\t     const char *orig_name,\n\t\t     const char *new_name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s\",\n\t       orig_dvnode->volume->vlocation->vldb.name,\n\t       orig_dvnode->fid.vid,\n\t       orig_dvnode->fid.vnode,\n\t       orig_dvnode->fid.unique,\n\t       new_dvnode->volume->vlocation->vldb.name,\n\t       new_dvnode->fid.vid,\n\t       new_dvnode->fid.vnode,\n\t       new_dvnode->fid.unique,\n\t       key_serial(key),\n\t       orig_name,\n\t       new_name);\n\n\t/* this op will fetch the status on both the directories we're dealing\n\t * with */\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt++;\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt++;\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(orig_dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_rename(server, key, orig_dvnode, orig_name,\n\t\t\t\t    new_dvnode, new_name, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(orig_dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(orig_dvnode, server);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_finalise_status_update(new_dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(orig_dvnode, ret);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_status_update_failed(new_dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, orig_dvnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt--;\n\tASSERTCMP(orig_dvnode->update_cnt, >=, 0);\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt--;\n\t\tASSERTCMP(new_dvnode->update_cnt, >=, 0);\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), orig_dvnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "orig_dvnode->update_cnt"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&new_dvnode->lock"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "new_dvnode->update_cnt",
            ">=,0"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&new_dvnode->lock"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "orig_dvnode->update_cnt",
            ">=,0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "new_dvnode",
            "ret"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "new_dvnode",
            "server"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "orig_dvnode",
            "server",
            "ret"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_rename",
          "args": [
            "server",
            "key",
            "orig_dvnode",
            "orig_name",
            "new_dvnode",
            "new_name",
            "&afs_sync_call"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1037-1098",
          "snippet": "int afs_fs_rename(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *orig_dvnode,\n\t\t  const char *orig_name,\n\t\t  struct afs_vnode *new_dvnode,\n\t\t  const char *new_name,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\to_namesz = strlen(orig_name);\n\to_padsz = (4 - (o_namesz & 3)) & 3;\n\n\tn_namesz = strlen(new_name);\n\tn_padsz = (4 - (n_namesz & 3)) & 3;\n\n\treqsz = (4 * 4) +\n\t\t4 + o_namesz + o_padsz +\n\t\t(3 * 4) +\n\t\t4 + n_namesz + n_padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = orig_dvnode;\n\tcall->reply2 = new_dvnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRENAME);\n\t*bp++ = htonl(orig_dvnode->fid.vid);\n\t*bp++ = htonl(orig_dvnode->fid.vnode);\n\t*bp++ = htonl(orig_dvnode->fid.unique);\n\t*bp++ = htonl(o_namesz);\n\tmemcpy(bp, orig_name, o_namesz);\n\tbp = (void *) bp + o_namesz;\n\tif (o_padsz > 0) {\n\t\tmemset(bp, 0, o_padsz);\n\t\tbp = (void *) bp + o_padsz;\n\t}\n\n\t*bp++ = htonl(new_dvnode->fid.vid);\n\t*bp++ = htonl(new_dvnode->fid.vnode);\n\t*bp++ = htonl(new_dvnode->fid.unique);\n\t*bp++ = htonl(n_namesz);\n\tmemcpy(bp, new_name, n_namesz);\n\tbp = (void *) bp + n_namesz;\n\tif (n_padsz > 0) {\n\t\tmemset(bp, 0, n_padsz);\n\t\tbp = (void *) bp + n_padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.deliver\t= afs_deliver_fs_rename,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.deliver\t= afs_deliver_fs_rename,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_rename(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *orig_dvnode,\n\t\t  const char *orig_name,\n\t\t  struct afs_vnode *new_dvnode,\n\t\t  const char *new_name,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\to_namesz = strlen(orig_name);\n\to_padsz = (4 - (o_namesz & 3)) & 3;\n\n\tn_namesz = strlen(new_name);\n\tn_padsz = (4 - (n_namesz & 3)) & 3;\n\n\treqsz = (4 * 4) +\n\t\t4 + o_namesz + o_padsz +\n\t\t(3 * 4) +\n\t\t4 + n_namesz + n_padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = orig_dvnode;\n\tcall->reply2 = new_dvnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRENAME);\n\t*bp++ = htonl(orig_dvnode->fid.vid);\n\t*bp++ = htonl(orig_dvnode->fid.vnode);\n\t*bp++ = htonl(orig_dvnode->fid.unique);\n\t*bp++ = htonl(o_namesz);\n\tmemcpy(bp, orig_name, o_namesz);\n\tbp = (void *) bp + o_namesz;\n\tif (o_padsz > 0) {\n\t\tmemset(bp, 0, o_padsz);\n\t\tbp = (void *) bp + o_padsz;\n\t}\n\n\t*bp++ = htonl(new_dvnode->fid.vid);\n\t*bp++ = htonl(new_dvnode->fid.vnode);\n\t*bp++ = htonl(new_dvnode->fid.unique);\n\t*bp++ = htonl(n_namesz);\n\tmemcpy(bp, new_name, n_namesz);\n\tbp = (void *) bp + n_namesz;\n\tif (n_padsz > 0) {\n\t\tmemset(bp, 0, n_padsz);\n\t\tbp = (void *) bp + n_padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "orig_dvnode"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s\"",
            "orig_dvnode->volume->vlocation->vldb.name",
            "orig_dvnode->fid.vid",
            "orig_dvnode->fid.vnode",
            "orig_dvnode->fid.unique",
            "new_dvnode->volume->vlocation->vldb.name",
            "new_dvnode->fid.vid",
            "new_dvnode->fid.vnode",
            "new_dvnode->fid.unique",
            "key_serial(key)",
            "orig_name",
            "new_name"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_rename(struct afs_vnode *orig_dvnode,\n\t\t     struct afs_vnode *new_dvnode,\n\t\t     struct key *key,\n\t\t     const char *orig_name,\n\t\t     const char *new_name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s\",\n\t       orig_dvnode->volume->vlocation->vldb.name,\n\t       orig_dvnode->fid.vid,\n\t       orig_dvnode->fid.vnode,\n\t       orig_dvnode->fid.unique,\n\t       new_dvnode->volume->vlocation->vldb.name,\n\t       new_dvnode->fid.vid,\n\t       new_dvnode->fid.vnode,\n\t       new_dvnode->fid.unique,\n\t       key_serial(key),\n\t       orig_name,\n\t       new_name);\n\n\t/* this op will fetch the status on both the directories we're dealing\n\t * with */\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt++;\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt++;\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(orig_dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_rename(server, key, orig_dvnode, orig_name,\n\t\t\t\t    new_dvnode, new_name, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(orig_dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(orig_dvnode, server);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_finalise_status_update(new_dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(orig_dvnode, ret);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_status_update_failed(new_dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, orig_dvnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt--;\n\tASSERTCMP(orig_dvnode->update_cnt, >=, 0);\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt--;\n\t\tASSERTCMP(new_dvnode->update_cnt, >=, 0);\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), orig_dvnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "631-685",
    "snippet": "int afs_vnode_symlink(struct afs_vnode *vnode, struct key *key,\n\t\t      const char *name, const char *content,\n\t\t      struct afs_fid *newfid,\n\t\t      struct afs_file_status *newstatus,\n\t\t      struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,%s,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name, content);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_symlink(server, key, vnode, name, content,\n\t\t\t\t     newfid, newstatus, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "vnode->update_cnt"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_symlink",
          "args": [
            "server",
            "key",
            "vnode",
            "name",
            "content",
            "newfid",
            "newstatus",
            "&afs_sync_call"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "929-992",
          "snippet": "int afs_fs_symlink(struct afs_server *server,\n\t\t   struct key *key,\n\t\t   struct afs_vnode *vnode,\n\t\t   const char *name,\n\t\t   const char *contents,\n\t\t   struct afs_fid *newfid,\n\t\t   struct afs_file_status *newstatus,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\n\tc_namesz = strlen(contents);\n\tc_padsz = (4 - (c_namesz & 3)) & 3;\n\n\treqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSymlink, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSYMLINK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(c_namesz);\n\tmemcpy(bp, contents, c_namesz);\n\tbp = (void *) bp + c_namesz;\n\tif (c_padsz > 0) {\n\t\tmemset(bp, 0, c_padsz);\n\t\tbp = (void *) bp + c_padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(S_IRWXUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSSymlink = {\n\t.name\t\t= \"FS.Symlink\",\n\t.deliver\t= afs_deliver_fs_symlink,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSSymlink = {\n\t.name\t\t= \"FS.Symlink\",\n\t.deliver\t= afs_deliver_fs_symlink,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_symlink(struct afs_server *server,\n\t\t   struct key *key,\n\t\t   struct afs_vnode *vnode,\n\t\t   const char *name,\n\t\t   const char *contents,\n\t\t   struct afs_fid *newfid,\n\t\t   struct afs_file_status *newstatus,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\n\tc_namesz = strlen(contents);\n\tc_padsz = (4 - (c_namesz & 3)) & 3;\n\n\treqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSymlink, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSYMLINK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(c_namesz);\n\tmemcpy(bp, contents, c_namesz);\n\tbp = (void *) bp + c_namesz;\n\tif (c_padsz > 0) {\n\t\tmemset(bp, 0, c_padsz);\n\t\tbp = (void *) bp + c_padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(S_IRWXUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,%s,%s,,,\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)",
            "name",
            "content"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_symlink(struct afs_vnode *vnode, struct key *key,\n\t\t      const char *name, const char *content,\n\t\t      struct afs_fid *newfid,\n\t\t      struct afs_file_status *newstatus,\n\t\t      struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,%s,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name, content);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_symlink(server, key, vnode, name, content,\n\t\t\t\t     newfid, newstatus, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "563-626",
    "snippet": "int afs_vnode_link(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t  struct key *key, const char *name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%x:%u.%u},%x,%s\",\n\t       dvnode->volume->vlocation->vldb.name,\n\t       dvnode->fid.vid,\n\t       dvnode->fid.vnode,\n\t       dvnode->fid.unique,\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt++;\n\tspin_unlock(&dvnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_link(server, key, dvnode, vnode, name,\n\t\t\t\t  &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_vnode_finalise_status_update(dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\tafs_vnode_status_update_failed(dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt--;\n\tASSERTCMP(dvnode->update_cnt, >=, 0);\n\tspin_unlock(&dvnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "vnode->update_cnt"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dvnode->lock"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "dvnode->update_cnt",
            ">=,0"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dvnode->lock"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "dvnode",
            "ret"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "dvnode",
            "server"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "dvnode",
            "server",
            "ret"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_link",
          "args": [
            "server",
            "key",
            "dvnode",
            "vnode",
            "name",
            "&afs_sync_call"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "840-885",
          "snippet": "int afs_fs_link(struct afs_server *server,\n\t\tstruct key *key,\n\t\tstruct afs_vnode *dvnode,\n\t\tstruct afs_vnode *vnode,\n\t\tconst char *name,\n\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (3 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = dvnode;\n\tcall->reply2 = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSLINK);\n\t*bp++ = htonl(dvnode->fid.vid);\n\t*bp++ = htonl(dvnode->fid.vnode);\n\t*bp++ = htonl(dvnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSLink = {\n\t.name\t\t= \"FS.Link\",\n\t.deliver\t= afs_deliver_fs_link,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSLink = {\n\t.name\t\t= \"FS.Link\",\n\t.deliver\t= afs_deliver_fs_link,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_link(struct afs_server *server,\n\t\tstruct key *key,\n\t\tstruct afs_vnode *dvnode,\n\t\tstruct afs_vnode *vnode,\n\t\tconst char *name,\n\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (3 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = dvnode;\n\tcall->reply2 = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSLINK);\n\t*bp++ = htonl(dvnode->fid.vid);\n\t*bp++ = htonl(dvnode->fid.vnode);\n\t*bp++ = htonl(dvnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "dvnode"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%s{%x:%u.%u},%x,%s\"",
            "dvnode->volume->vlocation->vldb.name",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dvnode->fid.unique",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)",
            "name"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_link(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t  struct key *key, const char *name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%x:%u.%u},%x,%s\",\n\t       dvnode->volume->vlocation->vldb.name,\n\t       dvnode->fid.vid,\n\t       dvnode->fid.vnode,\n\t       dvnode->fid.unique,\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt++;\n\tspin_unlock(&dvnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_link(server, key, dvnode, vnode, name,\n\t\t\t\t  &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_vnode_finalise_status_update(dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\tafs_vnode_status_update_failed(dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt--;\n\tASSERTCMP(dvnode->update_cnt, >=, 0);\n\tspin_unlock(&dvnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "508-558",
    "snippet": "int afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "vnode->update_cnt"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_remove",
          "args": [
            "server",
            "key",
            "vnode",
            "name",
            "isdir",
            "&afs_sync_call"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "756-797",
          "snippet": "int afs_fs_remove(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  bool isdir,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRemoveXXXX, reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(isdir ? FSREMOVEDIR : FSREMOVEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSRemoveXXXX = {\n\t.name\t\t= \"FS.RemoveXXXX\",\n\t.deliver\t= afs_deliver_fs_remove,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSRemoveXXXX = {\n\t.name\t\t= \"FS.RemoveXXXX\",\n\t.deliver\t= afs_deliver_fs_remove,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_remove(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  bool isdir,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRemoveXXXX, reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(isdir ? FSREMOVEDIR : FSREMOVEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,%s\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)",
            "name"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "450-503",
    "snippet": "int afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "vnode->update_cnt"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_create",
          "args": [
            "server",
            "key",
            "vnode",
            "name",
            "mode",
            "newfid",
            "newstatus",
            "newcb",
            "&afs_sync_call"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "660-714",
          "snippet": "int afs_fs_create(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  umode_t mode,\n\t\t  struct afs_fid *newfid,\n\t\t  struct afs_file_status *newstatus,\n\t\t  struct afs_callback *newcb,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSCreateXXXX, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->reply4 = newcb;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(mode & S_IALLUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSCreateXXXX = {\n\t.name\t\t= \"FS.CreateXXXX\",\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSCreateXXXX = {\n\t.name\t\t= \"FS.CreateXXXX\",\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_create(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  umode_t mode,\n\t\t  struct afs_fid *newfid,\n\t\t  struct afs_file_status *newstatus,\n\t\t  struct afs_callback *newcb,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSCreateXXXX, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->reply4 = newcb;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(mode & S_IALLUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,%s,,\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)",
            "name"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_fetch_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "395-445",
    "snippet": "int afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_fetch_data",
          "args": [
            "server",
            "key",
            "vnode",
            "offset",
            "length",
            "page",
            "&afs_sync_call"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_fetch_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "492-530",
          "snippet": "int afs_fs_fetch_data(struct afs_server *server,\n\t\t      struct key *key,\n\t\t      struct afs_vnode *vnode,\n\t\t      off_t offset, size_t length,\n\t\t      struct page *buffer,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (upper_32_bits(offset) || upper_32_bits(offset + length))\n\t\treturn afs_fs_fetch_data64(server, key, vnode, offset, length,\n\t\t\t\t\t   buffer, wait_mode);\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(offset);\n\tbp[5] = htonl(length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSFetchData = {\n\t.name\t\t= \"FS.FetchData\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchData = {\n\t.name\t\t= \"FS.FetchData\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_fetch_data(struct afs_server *server,\n\t\t      struct key *key,\n\t\t      struct afs_vnode *vnode,\n\t\t      off_t offset, size_t length,\n\t\t      struct page *buffer,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (upper_32_bits(offset) || upper_32_bits(offset + length))\n\t\treturn afs_fs_fetch_data64(server, key, vnode, offset, length,\n\t\t\t\t\t   buffer, wait_mode);\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(offset);\n\tbp[5] = htonl(length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %08x\\n\"",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s{%x:%u.%u},%x,,,\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "key_serial(key)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_fetch_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "264-389",
    "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld [cnt %d]\"",
            "PTR_ERR(server)",
            "vnode->update_cnt"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_status_update_failed",
          "args": [
            "vnode",
            "ret"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_status_update_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "235-255",
          "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"failed [%d]\"",
            "ret"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_cache_permit",
          "args": [
            "vnode",
            "key",
            "acl_order"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cache_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "129-210",
          "snippet": "void afs_cache_permit(struct afs_vnode *vnode, struct key *key, long acl_order)\n{\n\tstruct afs_permits *permits, *xpermits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tint count, loop;\n\n\t_enter(\"{%x:%u},%x,%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key), acl_order);\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t_leave(\" [get error %ld]\", PTR_ERR(auth_vnode));\n\t\treturn;\n\t}\n\n\tmutex_lock(&auth_vnode->permits_lock);\n\n\t/* guard against a rename being detected whilst we waited for the\n\t * lock */\n\tif (memcmp(&auth_vnode->fid, &vnode->status.parent,\n\t\t   sizeof(struct afs_fid)) != 0) {\n\t\t_debug(\"renamed\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* have to be careful as the directory's callback may be broken between\n\t * us receiving the status we're trying to cache and us getting the\n\t * lock to update the cache for the status */\n\tif (auth_vnode->acl_order - acl_order > 0) {\n\t\t_debug(\"ACL changed?\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* always update the anonymous mask */\n\t_debug(\"anon access %x\", vnode->status.anon_access);\n\tauth_vnode->status.anon_access = vnode->status.anon_access;\n\tif (key == vnode->volume->cell->anonymous_key)\n\t\tgoto out_unlock;\n\n\txpermits = auth_vnode->permits;\n\tcount = 0;\n\tif (xpermits) {\n\t\t/* see if the permit is already in the list\n\t\t * - if it is then we just amend the list\n\t\t */\n\t\tcount = xpermits->count;\n\t\tpermit = xpermits->permits;\n\t\tfor (loop = count; loop > 0; loop--) {\n\t\t\tif (permit->key == key) {\n\t\t\t\tpermit->access_mask =\n\t\t\t\t\tvnode->status.caller_access;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tpermit++;\n\t\t}\n\t}\n\n\tpermits = kmalloc(sizeof(*permits) + sizeof(*permit) * (count + 1),\n\t\t\t  GFP_NOFS);\n\tif (!permits)\n\t\tgoto out_unlock;\n\n\tif (xpermits)\n\t\tmemcpy(permits->permits, xpermits->permits,\n\t\t\tcount * sizeof(struct afs_permit));\n\n\t_debug(\"key %x access %x\",\n\t       key_serial(key), vnode->status.caller_access);\n\tpermits->permits[count].access_mask = vnode->status.caller_access;\n\tpermits->permits[count].key = key_get(key);\n\tpermits->count = count + 1;\n\n\trcu_assign_pointer(auth_vnode->permits, permits);\n\tif (xpermits)\n\t\tcall_rcu(&xpermits->rcu, afs_dispose_of_permits);\n\nout_unlock:\n\tmutex_unlock(&auth_vnode->permits_lock);\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nvoid afs_cache_permit(struct afs_vnode *vnode, struct key *key, long acl_order)\n{\n\tstruct afs_permits *permits, *xpermits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tint count, loop;\n\n\t_enter(\"{%x:%u},%x,%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key), acl_order);\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t_leave(\" [get error %ld]\", PTR_ERR(auth_vnode));\n\t\treturn;\n\t}\n\n\tmutex_lock(&auth_vnode->permits_lock);\n\n\t/* guard against a rename being detected whilst we waited for the\n\t * lock */\n\tif (memcmp(&auth_vnode->fid, &vnode->status.parent,\n\t\t   sizeof(struct afs_fid)) != 0) {\n\t\t_debug(\"renamed\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* have to be careful as the directory's callback may be broken between\n\t * us receiving the status we're trying to cache and us getting the\n\t * lock to update the cache for the status */\n\tif (auth_vnode->acl_order - acl_order > 0) {\n\t\t_debug(\"ACL changed?\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* always update the anonymous mask */\n\t_debug(\"anon access %x\", vnode->status.anon_access);\n\tauth_vnode->status.anon_access = vnode->status.anon_access;\n\tif (key == vnode->volume->cell->anonymous_key)\n\t\tgoto out_unlock;\n\n\txpermits = auth_vnode->permits;\n\tcount = 0;\n\tif (xpermits) {\n\t\t/* see if the permit is already in the list\n\t\t * - if it is then we just amend the list\n\t\t */\n\t\tcount = xpermits->count;\n\t\tpermit = xpermits->permits;\n\t\tfor (loop = count; loop > 0; loop--) {\n\t\t\tif (permit->key == key) {\n\t\t\t\tpermit->access_mask =\n\t\t\t\t\tvnode->status.caller_access;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tpermit++;\n\t\t}\n\t}\n\n\tpermits = kmalloc(sizeof(*permits) + sizeof(*permit) * (count + 1),\n\t\t\t  GFP_NOFS);\n\tif (!permits)\n\t\tgoto out_unlock;\n\n\tif (xpermits)\n\t\tmemcpy(permits->permits, xpermits->permits,\n\t\t\tcount * sizeof(struct afs_permit));\n\n\t_debug(\"key %x access %x\",\n\t       key_serial(key), vnode->status.caller_access);\n\tpermits->permits[count].access_mask = vnode->status.caller_access;\n\tpermits->permits[count].key = key_get(key);\n\tpermits->count = count + 1;\n\n\trcu_assign_pointer(auth_vnode->permits, permits);\n\tif (xpermits)\n\t\tcall_rcu(&xpermits->rcu, afs_dispose_of_permits);\n\nout_unlock:\n\tmutex_unlock(&auth_vnode->permits_lock);\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"adjust\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_volume_release_fileserver",
          "args": [
            "vnode",
            "server",
            "ret"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_release_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "306-401",
          "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_fetch_file_status",
          "args": [
            "server",
            "key",
            "vnode",
            "NULL",
            "&afs_sync_call"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_fetch_file_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "277-307",
          "snippet": "int afs_fs_fetch_file_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volsync *volsync,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchStatus, 16, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = volsync;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHSTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSFetchStatus = {\n\t.name\t\t= \"FS.FetchStatus\",\n\t.deliver\t= afs_deliver_fs_fetch_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchStatus = {\n\t.name\t\t= \"FS.FetchStatus\",\n\t.deliver\t= afs_deliver_fs_fetch_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_fetch_file_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volsync *volsync,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchStatus, 16, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = volsync;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHSTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"USING SERVER: %p{%08x}\"",
            "server",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_volume_pick_fileserver",
          "args": [
            "vnode"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "afs_volume_pick_fileserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
          "lines": "219-297",
          "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&vnode->update_waitq",
            "&myself"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&vnode->update_waitq",
            "&myself"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&vnode->update_waitq",
            "&myself"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "myself.func != NULL"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [unchanged]\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s,{%x:%u.%u}\"",
            "vnode->volume->vlocation->vldb.name",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->fid.unique"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "myself",
            "current"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
  },
  {
    "function_name": "afs_vnode_status_update_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "235-255",
    "snippet": "static void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&vnode->update_waitq"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_deleted_remotely",
          "args": [
            "vnode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_deleted_remotely",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "174-205",
          "snippet": "static void afs_vnode_deleted_remotely(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server;\n\n\t_enter(\"{%p}\", vnode->server);\n\n\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\n\tserver = vnode->server;\n\tif (server) {\n\t\tif (vnode->cb_promised) {\n\t\t\tspin_lock(&server->cb_lock);\n\t\t\tif (vnode->cb_promised) {\n\t\t\t\trb_erase(&vnode->cb_promise,\n\t\t\t\t\t &server->cb_promises);\n\t\t\t\tvnode->cb_promised = false;\n\t\t\t}\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t}\n\n\t\tspin_lock(&server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &server->fs_vnodes);\n\t\tspin_unlock(&server->fs_lock);\n\n\t\tvnode->server = NULL;\n\t\tafs_put_server(server);\n\t} else {\n\t\tASSERT(!vnode->cb_promised);\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_deleted_remotely(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server;\n\n\t_enter(\"{%p}\", vnode->server);\n\n\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\n\tserver = vnode->server;\n\tif (server) {\n\t\tif (vnode->cb_promised) {\n\t\t\tspin_lock(&server->cb_lock);\n\t\t\tif (vnode->cb_promised) {\n\t\t\t\trb_erase(&vnode->cb_promise,\n\t\t\t\t\t &server->cb_promises);\n\t\t\t\tvnode->cb_promised = false;\n\t\t\t}\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t}\n\n\t\tspin_lock(&server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &server->fs_vnodes);\n\t\tspin_unlock(&server->fs_lock);\n\n\t\tvnode->server = NULL;\n\t\tafs_put_server(server);\n\t} else {\n\t\tASSERT(!vnode->cb_promised);\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"got NOENT from server - marking file deleted\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%d\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "ret"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\n{\n\t_enter(\"{%x:%u},%d\", vnode->fid.vid, vnode->fid.vnode, ret);\n\n\tspin_lock(&vnode->lock);\n\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\n\tif (ret == -ENOENT) {\n\t\t/* the file was deleted on the server */\n\t\t_debug(\"got NOENT from server - marking file deleted\");\n\t\tafs_vnode_deleted_remotely(vnode);\n\t}\n\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_vnode_finalise_status_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "213-230",
    "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "oldserver"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&vnode->update_waitq"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vnode->update_cnt",
            ">=,0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vnode_note_promise",
          "args": [
            "vnode",
            "server"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_note_promise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "113-169",
          "snippet": "static void afs_vnode_note_promise(struct afs_vnode *vnode,\n\t\t\t\t   struct afs_server *server)\n{\n\tstruct afs_server *old_server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tASSERT(server != NULL);\n\n\told_server = vnode->server;\n\tif (vnode->cb_promised) {\n\t\tif (server == old_server &&\n\t\t    vnode->cb_expires == vnode->cb_expires_at) {\n\t\t\t_leave(\" [no change]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&old_server->cb_lock);\n\t\tif (vnode->cb_promised) {\n\t\t\t_debug(\"delete\");\n\t\t\trb_erase(&vnode->cb_promise, &old_server->cb_promises);\n\t\t\tvnode->cb_promised = false;\n\t\t}\n\t\tspin_unlock(&old_server->cb_lock);\n\t}\n\n\tif (vnode->server != server)\n\t\tafs_install_vnode(vnode, server);\n\n\tvnode->cb_expires_at = vnode->cb_expires;\n\t_debug(\"PROMISE on %p {%lu}\",\n\t       vnode, (unsigned long) vnode->cb_expires_at);\n\n\t/* abuse an RB-tree to hold the expiration order (we may have multiple\n\t * items with the same expiration time) */\n\tspin_lock(&server->cb_lock);\n\n\tparent = NULL;\n\tp = &server->cb_promises.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, cb_promise);\n\t\tif (vnode->cb_expires_at < xvnode->cb_expires_at)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&vnode->cb_promise, parent, p);\n\trb_insert_color(&vnode->cb_promise, &server->cb_promises);\n\tvnode->cb_promised = true;\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_note_promise(struct afs_vnode *vnode,\n\t\t\t\t   struct afs_server *server)\n{\n\tstruct afs_server *old_server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tASSERT(server != NULL);\n\n\told_server = vnode->server;\n\tif (vnode->cb_promised) {\n\t\tif (server == old_server &&\n\t\t    vnode->cb_expires == vnode->cb_expires_at) {\n\t\t\t_leave(\" [no change]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&old_server->cb_lock);\n\t\tif (vnode->cb_promised) {\n\t\t\t_debug(\"delete\");\n\t\t\trb_erase(&vnode->cb_promise, &old_server->cb_promises);\n\t\t\tvnode->cb_promised = false;\n\t\t}\n\t\tspin_unlock(&old_server->cb_lock);\n\t}\n\n\tif (vnode->server != server)\n\t\tafs_install_vnode(vnode, server);\n\n\tvnode->cb_expires_at = vnode->cb_expires;\n\t_debug(\"PROMISE on %p {%lu}\",\n\t       vnode, (unsigned long) vnode->cb_expires_at);\n\n\t/* abuse an RB-tree to hold the expiration order (we may have multiple\n\t * items with the same expiration time) */\n\tspin_lock(&server->cb_lock);\n\n\tparent = NULL;\n\tp = &server->cb_promises.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, cb_promise);\n\t\tif (vnode->cb_expires_at < xvnode->cb_expires_at)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&vnode->cb_promise, parent, p);\n\trb_insert_color(&vnode->cb_promise, &server->cb_promises);\n\tvnode->cb_promised = true;\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p\"",
            "vnode",
            "server"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_vnode_deleted_remotely",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "174-205",
    "snippet": "static void afs_vnode_deleted_remotely(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server;\n\n\t_enter(\"{%p}\", vnode->server);\n\n\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\n\tserver = vnode->server;\n\tif (server) {\n\t\tif (vnode->cb_promised) {\n\t\t\tspin_lock(&server->cb_lock);\n\t\t\tif (vnode->cb_promised) {\n\t\t\t\trb_erase(&vnode->cb_promise,\n\t\t\t\t\t &server->cb_promises);\n\t\t\t\tvnode->cb_promised = false;\n\t\t\t}\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t}\n\n\t\tspin_lock(&server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &server->fs_vnodes);\n\t\tspin_unlock(&server->fs_lock);\n\n\t\tvnode->server = NULL;\n\t\tafs_put_server(server);\n\t} else {\n\t\tASSERT(!vnode->cb_promised);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!vnode->cb_promised"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&vnode->server_rb",
            "&server->fs_vnodes"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&vnode->cb_promise",
            "&server->cb_promises"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%p}\"",
            "vnode->server"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_deleted_remotely(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server;\n\n\t_enter(\"{%p}\", vnode->server);\n\n\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\n\tserver = vnode->server;\n\tif (server) {\n\t\tif (vnode->cb_promised) {\n\t\t\tspin_lock(&server->cb_lock);\n\t\t\tif (vnode->cb_promised) {\n\t\t\t\trb_erase(&vnode->cb_promise,\n\t\t\t\t\t &server->cb_promises);\n\t\t\t\tvnode->cb_promised = false;\n\t\t\t}\n\t\t\tspin_unlock(&server->cb_lock);\n\t\t}\n\n\t\tspin_lock(&server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &server->fs_vnodes);\n\t\tspin_unlock(&server->fs_lock);\n\n\t\tvnode->server = NULL;\n\t\tafs_put_server(server);\n\t} else {\n\t\tASSERT(!vnode->cb_promised);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_vnode_note_promise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "113-169",
    "snippet": "static void afs_vnode_note_promise(struct afs_vnode *vnode,\n\t\t\t\t   struct afs_server *server)\n{\n\tstruct afs_server *old_server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tASSERT(server != NULL);\n\n\told_server = vnode->server;\n\tif (vnode->cb_promised) {\n\t\tif (server == old_server &&\n\t\t    vnode->cb_expires == vnode->cb_expires_at) {\n\t\t\t_leave(\" [no change]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&old_server->cb_lock);\n\t\tif (vnode->cb_promised) {\n\t\t\t_debug(\"delete\");\n\t\t\trb_erase(&vnode->cb_promise, &old_server->cb_promises);\n\t\t\tvnode->cb_promised = false;\n\t\t}\n\t\tspin_unlock(&old_server->cb_lock);\n\t}\n\n\tif (vnode->server != server)\n\t\tafs_install_vnode(vnode, server);\n\n\tvnode->cb_expires_at = vnode->cb_expires;\n\t_debug(\"PROMISE on %p {%lu}\",\n\t       vnode, (unsigned long) vnode->cb_expires_at);\n\n\t/* abuse an RB-tree to hold the expiration order (we may have multiple\n\t * items with the same expiration time) */\n\tspin_lock(&server->cb_lock);\n\n\tparent = NULL;\n\tp = &server->cb_promises.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, cb_promise);\n\t\tif (vnode->cb_expires_at < xvnode->cb_expires_at)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&vnode->cb_promise, parent, p);\n\trb_insert_color(&vnode->cb_promise, &server->cb_promises);\n\tvnode->cb_promised = true;\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->cb_lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&vnode->cb_promise",
            "&server->cb_promises"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&vnode->cb_promise",
            "parent",
            "p"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structafs_vnode",
            "cb_promise"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->cb_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"PROMISE on %p {%lu}\"",
            "vnode",
            "(unsigned long) vnode->cb_expires_at"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_install_vnode",
          "args": [
            "vnode",
            "server"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "afs_install_vnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "59-107",
          "snippet": "static void afs_install_vnode(struct afs_vnode *vnode,\n\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *old_server = vnode->server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tif (old_server) {\n\t\tspin_lock(&old_server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &old_server->fs_vnodes);\n\t\tspin_unlock(&old_server->fs_lock);\n\t}\n\n\tafs_get_server(server);\n\tvnode->server = server;\n\tafs_put_server(old_server);\n\n\t/* insert into the server's vnode tree in FID order */\n\tspin_lock(&server->fs_lock);\n\n\tparent = NULL;\n\tp = &server->fs_vnodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, server_rb);\n\t\tif (vnode->fid.vid < xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vid > xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.vnode < xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vnode > xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.unique < xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.unique > xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG(); /* can't happen unless afs_iget() malfunctions */\n\t}\n\n\trb_link_node(&vnode->server_rb, parent, p);\n\trb_insert_color(&vnode->server_rb, &server->fs_vnodes);\n\n\tspin_unlock(&server->fs_lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_install_vnode(struct afs_vnode *vnode,\n\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *old_server = vnode->server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tif (old_server) {\n\t\tspin_lock(&old_server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &old_server->fs_vnodes);\n\t\tspin_unlock(&old_server->fs_lock);\n\t}\n\n\tafs_get_server(server);\n\tvnode->server = server;\n\tafs_put_server(old_server);\n\n\t/* insert into the server's vnode tree in FID order */\n\tspin_lock(&server->fs_lock);\n\n\tparent = NULL;\n\tp = &server->fs_vnodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, server_rb);\n\t\tif (vnode->fid.vid < xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vid > xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.vnode < xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vnode > xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.unique < xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.unique > xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG(); /* can't happen unless afs_iget() malfunctions */\n\t}\n\n\trb_link_node(&vnode->server_rb, parent, p);\n\trb_insert_color(&vnode->server_rb, &server->fs_vnodes);\n\n\tspin_unlock(&server->fs_lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&vnode->cb_promise",
            "&old_server->cb_promises"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"delete\""
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "server != NULL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p\"",
            "vnode",
            "server"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vnode_note_promise(struct afs_vnode *vnode,\n\t\t\t\t   struct afs_server *server)\n{\n\tstruct afs_server *old_server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tASSERT(server != NULL);\n\n\told_server = vnode->server;\n\tif (vnode->cb_promised) {\n\t\tif (server == old_server &&\n\t\t    vnode->cb_expires == vnode->cb_expires_at) {\n\t\t\t_leave(\" [no change]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&old_server->cb_lock);\n\t\tif (vnode->cb_promised) {\n\t\t\t_debug(\"delete\");\n\t\t\trb_erase(&vnode->cb_promise, &old_server->cb_promises);\n\t\t\tvnode->cb_promised = false;\n\t\t}\n\t\tspin_unlock(&old_server->cb_lock);\n\t}\n\n\tif (vnode->server != server)\n\t\tafs_install_vnode(vnode, server);\n\n\tvnode->cb_expires_at = vnode->cb_expires;\n\t_debug(\"PROMISE on %p {%lu}\",\n\t       vnode, (unsigned long) vnode->cb_expires_at);\n\n\t/* abuse an RB-tree to hold the expiration order (we may have multiple\n\t * items with the same expiration time) */\n\tspin_lock(&server->cb_lock);\n\n\tparent = NULL;\n\tp = &server->cb_promises.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, cb_promise);\n\t\tif (vnode->cb_expires_at < xvnode->cb_expires_at)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&vnode->cb_promise, parent, p);\n\trb_insert_color(&vnode->cb_promise, &server->cb_promises);\n\tvnode->cb_promised = true;\n\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_install_vnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "59-107",
    "snippet": "static void afs_install_vnode(struct afs_vnode *vnode,\n\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *old_server = vnode->server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tif (old_server) {\n\t\tspin_lock(&old_server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &old_server->fs_vnodes);\n\t\tspin_unlock(&old_server->fs_lock);\n\t}\n\n\tafs_get_server(server);\n\tvnode->server = server;\n\tafs_put_server(old_server);\n\n\t/* insert into the server's vnode tree in FID order */\n\tspin_lock(&server->fs_lock);\n\n\tparent = NULL;\n\tp = &server->fs_vnodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, server_rb);\n\t\tif (vnode->fid.vid < xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vid > xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.vnode < xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vnode > xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.unique < xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.unique > xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG(); /* can't happen unless afs_iget() malfunctions */\n\t}\n\n\trb_link_node(&vnode->server_rb, parent, p);\n\trb_insert_color(&vnode->server_rb, &server->fs_vnodes);\n\n\tspin_unlock(&server->fs_lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&vnode->server_rb",
            "&server->fs_vnodes"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&vnode->server_rb",
            "parent",
            "p"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structafs_vnode",
            "server_rb"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "old_server"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_get_server",
          "args": [
            "server"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&vnode->server_rb",
            "&old_server->fs_vnodes"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p\"",
            "vnode",
            "server"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_install_vnode(struct afs_vnode *vnode,\n\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *old_server = vnode->server;\n\tstruct afs_vnode *xvnode;\n\tstruct rb_node *parent, **p;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tif (old_server) {\n\t\tspin_lock(&old_server->fs_lock);\n\t\trb_erase(&vnode->server_rb, &old_server->fs_vnodes);\n\t\tspin_unlock(&old_server->fs_lock);\n\t}\n\n\tafs_get_server(server);\n\tvnode->server = server;\n\tafs_put_server(old_server);\n\n\t/* insert into the server's vnode tree in FID order */\n\tspin_lock(&server->fs_lock);\n\n\tparent = NULL;\n\tp = &server->fs_vnodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txvnode = rb_entry(parent, struct afs_vnode, server_rb);\n\t\tif (vnode->fid.vid < xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vid > xvnode->fid.vid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.vnode < xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.vnode > xvnode->fid.vnode)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (vnode->fid.unique < xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (vnode->fid.unique > xvnode->fid.unique)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG(); /* can't happen unless afs_iget() malfunctions */\n\t}\n\n\trb_link_node(&vnode->server_rb, parent, p);\n\trb_insert_color(&vnode->server_rb, &server->fs_vnodes);\n\n\tspin_unlock(&server->fs_lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "dump_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "48-53",
    "snippet": "static noinline void dump_tree(const char *name, struct afs_server *server)\n{\n\t_enter(\"%s\", name);\n\tif (dump_tree_aux(server->cb_promises.rb_node, NULL, 0, '-'))\n\t\tBUG();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_tree_aux",
          "args": [
            "server->cb_promises.rb_node",
            "NULL",
            "0",
            "'-'"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "dump_tree_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "20-46",
          "snippet": "static noinline bool dump_tree_aux(struct rb_node *node, struct rb_node *parent,\n\t\t\t\t   int depth, char lr)\n{\n\tstruct afs_vnode *vnode;\n\tbool bad = false;\n\n\tif (!node)\n\t\treturn false;\n\n\tif (node->rb_left)\n\t\tbad = dump_tree_aux(node->rb_left, node, depth + 2, '/');\n\n\tvnode = rb_entry(node, struct afs_vnode, cb_promise);\n\t_debug(\"%c %*.*s%c%p {%d}\",\n\t       rb_is_red(node) ? 'R' : 'B',\n\t       depth, depth, \"\", lr,\n\t       vnode, vnode->cb_expires_at);\n\tif (rb_parent(node) != parent) {\n\t\tprintk(\"BAD: %p != %p\\n\", rb_parent(node), parent);\n\t\tbad = true;\n\t}\n\n\tif (node->rb_right)\n\t\tbad |= dump_tree_aux(node->rb_right, node, depth + 2, '\\\\');\n\n\treturn bad;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic noinline bool dump_tree_aux(struct rb_node *node, struct rb_node *parent,\n\t\t\t\t   int depth, char lr)\n{\n\tstruct afs_vnode *vnode;\n\tbool bad = false;\n\n\tif (!node)\n\t\treturn false;\n\n\tif (node->rb_left)\n\t\tbad = dump_tree_aux(node->rb_left, node, depth + 2, '/');\n\n\tvnode = rb_entry(node, struct afs_vnode, cb_promise);\n\t_debug(\"%c %*.*s%c%p {%d}\",\n\t       rb_is_red(node) ? 'R' : 'B',\n\t       depth, depth, \"\", lr,\n\t       vnode, vnode->cb_expires_at);\n\tif (rb_parent(node) != parent) {\n\t\tprintk(\"BAD: %p != %p\\n\", rb_parent(node), parent);\n\t\tbad = true;\n\t}\n\n\tif (node->rb_right)\n\t\tbad |= dump_tree_aux(node->rb_right, node, depth + 2, '\\\\');\n\n\treturn bad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s\"",
            "name"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic noinline void dump_tree(const char *name, struct afs_server *server)\n{\n\t_enter(\"%s\", name);\n\tif (dump_tree_aux(server->cb_promises.rb_node, NULL, 0, '-'))\n\t\tBUG();\n}"
  },
  {
    "function_name": "dump_tree_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
    "lines": "20-46",
    "snippet": "static noinline bool dump_tree_aux(struct rb_node *node, struct rb_node *parent,\n\t\t\t\t   int depth, char lr)\n{\n\tstruct afs_vnode *vnode;\n\tbool bad = false;\n\n\tif (!node)\n\t\treturn false;\n\n\tif (node->rb_left)\n\t\tbad = dump_tree_aux(node->rb_left, node, depth + 2, '/');\n\n\tvnode = rb_entry(node, struct afs_vnode, cb_promise);\n\t_debug(\"%c %*.*s%c%p {%d}\",\n\t       rb_is_red(node) ? 'R' : 'B',\n\t       depth, depth, \"\", lr,\n\t       vnode, vnode->cb_expires_at);\n\tif (rb_parent(node) != parent) {\n\t\tprintk(\"BAD: %p != %p\\n\", rb_parent(node), parent);\n\t\tbad = true;\n\t}\n\n\tif (node->rb_right)\n\t\tbad |= dump_tree_aux(node->rb_right, node, depth + 2, '\\\\');\n\n\treturn bad;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_tree_aux",
          "args": [
            "node->rb_right",
            "node",
            "depth + 2",
            "'\\\\'"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "dump_tree_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "20-46",
          "snippet": "static noinline bool dump_tree_aux(struct rb_node *node, struct rb_node *parent,\n\t\t\t\t   int depth, char lr)\n{\n\tstruct afs_vnode *vnode;\n\tbool bad = false;\n\n\tif (!node)\n\t\treturn false;\n\n\tif (node->rb_left)\n\t\tbad = dump_tree_aux(node->rb_left, node, depth + 2, '/');\n\n\tvnode = rb_entry(node, struct afs_vnode, cb_promise);\n\t_debug(\"%c %*.*s%c%p {%d}\",\n\t       rb_is_red(node) ? 'R' : 'B',\n\t       depth, depth, \"\", lr,\n\t       vnode, vnode->cb_expires_at);\n\tif (rb_parent(node) != parent) {\n\t\tprintk(\"BAD: %p != %p\\n\", rb_parent(node), parent);\n\t\tbad = true;\n\t}\n\n\tif (node->rb_right)\n\t\tbad |= dump_tree_aux(node->rb_right, node, depth + 2, '\\\\');\n\n\treturn bad;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"BAD: %p != %p\\n\"",
            "rb_parent(node)",
            "parent"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "node"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "node"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"%c %*.*s%c%p {%d}\"",
            "rb_is_red(node) ? 'R' : 'B'",
            "depth",
            "depth",
            "\"\"",
            "lr",
            "vnode",
            "vnode->cb_expires_at"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_is_red",
          "args": [
            "node"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structafs_vnode",
            "cb_promise"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic noinline bool dump_tree_aux(struct rb_node *node, struct rb_node *parent,\n\t\t\t\t   int depth, char lr)\n{\n\tstruct afs_vnode *vnode;\n\tbool bad = false;\n\n\tif (!node)\n\t\treturn false;\n\n\tif (node->rb_left)\n\t\tbad = dump_tree_aux(node->rb_left, node, depth + 2, '/');\n\n\tvnode = rb_entry(node, struct afs_vnode, cb_promise);\n\t_debug(\"%c %*.*s%c%p {%d}\",\n\t       rb_is_red(node) ? 'R' : 'B',\n\t       depth, depth, \"\", lr,\n\t       vnode, vnode->cb_expires_at);\n\tif (rb_parent(node) != parent) {\n\t\tprintk(\"BAD: %p != %p\\n\", rb_parent(node), parent);\n\t\tbad = true;\n\t}\n\n\tif (node->rb_right)\n\t\tbad |= dump_tree_aux(node->rb_right, node, depth + 2, '\\\\');\n\n\treturn bad;\n}"
  }
]