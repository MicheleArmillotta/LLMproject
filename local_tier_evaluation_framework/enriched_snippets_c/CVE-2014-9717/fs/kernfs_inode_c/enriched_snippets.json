[
  {
    "function_name": "kernfs_iop_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "356-370",
    "snippet": "int kernfs_iop_permission(struct inode *inode, int mask)\n{\n\tstruct kernfs_node *kn;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tkn = inode->i_private;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_refresh_inode(kn, inode);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn generic_permission(inode, mask);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_refresh_inode",
          "args": [
            "kn",
            "inode"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "251-268",
          "snippet": "static void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_iop_permission(struct inode *inode, int mask)\n{\n\tstruct kernfs_node *kn;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tkn = inode->i_private;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_refresh_inode(kn, inode);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn generic_permission(inode, mask);\n}"
  },
  {
    "function_name": "kernfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "347-354",
    "snippet": "void kernfs_evict_inode(struct inode *inode)\n{\n\tstruct kernfs_node *kn = inode->i_private;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tkernfs_put(kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nvoid kernfs_evict_inode(struct inode *inode)\n{\n\tstruct kernfs_node *kn = inode->i_private;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tkernfs_put(kn);\n}"
  },
  {
    "function_name": "kernfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "329-338",
    "snippet": "struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_init_inode",
          "args": [
            "kn",
            "inode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "284-312",
          "snippet": "static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tkernfs_get(kn);\n\tinode->i_private = kn;\n\tinode->i_mapping->a_ops = &kernfs_aops;\n\tinode->i_op = &kernfs_iops;\n\n\tset_default_inode_attr(inode, kn->mode);\n\tkernfs_refresh_inode(kn, inode);\n\n\t/* initialize inode according to type */\n\tswitch (kernfs_type(kn)) {\n\tcase KERNFS_DIR:\n\t\tinode->i_op = &kernfs_dir_iops;\n\t\tinode->i_fop = &kernfs_dir_fops;\n\t\tbreak;\n\tcase KERNFS_FILE:\n\t\tinode->i_size = kn->attr.size;\n\t\tinode->i_fop = &kernfs_file_fops;\n\t\tbreak;\n\tcase KERNFS_LINK:\n\t\tinode->i_op = &kernfs_symlink_iops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tunlock_new_inode(inode);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations kernfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};",
            "static const struct inode_operations kernfs_iops = {\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.setxattr\t= kernfs_iop_setxattr,\n\t.removexattr\t= kernfs_iop_removexattr,\n\t.getxattr\t= kernfs_iop_getxattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic const struct address_space_operations kernfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};\nstatic const struct inode_operations kernfs_iops = {\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.setxattr\t= kernfs_iop_setxattr,\n\t.removexattr\t= kernfs_iop_removexattr,\n\t.getxattr\t= kernfs_iop_getxattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n};\n\nstatic void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tkernfs_get(kn);\n\tinode->i_private = kn;\n\tinode->i_mapping->a_ops = &kernfs_aops;\n\tinode->i_op = &kernfs_iops;\n\n\tset_default_inode_attr(inode, kn->mode);\n\tkernfs_refresh_inode(kn, inode);\n\n\t/* initialize inode according to type */\n\tswitch (kernfs_type(kn)) {\n\tcase KERNFS_DIR:\n\t\tinode->i_op = &kernfs_dir_iops;\n\t\tinode->i_fop = &kernfs_dir_fops;\n\t\tbreak;\n\tcase KERNFS_FILE:\n\t\tinode->i_size = kn->attr.size;\n\t\tinode->i_fop = &kernfs_file_fops;\n\t\tbreak;\n\tcase KERNFS_LINK:\n\t\tinode->i_op = &kernfs_symlink_iops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tunlock_new_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "kn->ino"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstruct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "kernfs_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "284-312",
    "snippet": "static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tkernfs_get(kn);\n\tinode->i_private = kn;\n\tinode->i_mapping->a_ops = &kernfs_aops;\n\tinode->i_op = &kernfs_iops;\n\n\tset_default_inode_attr(inode, kn->mode);\n\tkernfs_refresh_inode(kn, inode);\n\n\t/* initialize inode according to type */\n\tswitch (kernfs_type(kn)) {\n\tcase KERNFS_DIR:\n\t\tinode->i_op = &kernfs_dir_iops;\n\t\tinode->i_fop = &kernfs_dir_fops;\n\t\tbreak;\n\tcase KERNFS_FILE:\n\t\tinode->i_size = kn->attr.size;\n\t\tinode->i_fop = &kernfs_file_fops;\n\t\tbreak;\n\tcase KERNFS_LINK:\n\t\tinode->i_op = &kernfs_symlink_iops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tunlock_new_inode(inode);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations kernfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};",
      "static const struct inode_operations kernfs_iops = {\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.setxattr\t= kernfs_iop_setxattr,\n\t.removexattr\t= kernfs_iop_removexattr,\n\t.getxattr\t= kernfs_iop_getxattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_refresh_inode",
          "args": [
            "kn",
            "inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "251-268",
          "snippet": "static void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_default_inode_attr",
          "args": [
            "inode",
            "kn->mode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "set_default_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "236-240",
          "snippet": "static inline void set_default_inode_attr(struct inode *inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_default_inode_attr(struct inode *inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic const struct address_space_operations kernfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};\nstatic const struct inode_operations kernfs_iops = {\n\t.permission\t= kernfs_iop_permission,\n\t.setattr\t= kernfs_iop_setattr,\n\t.getattr\t= kernfs_iop_getattr,\n\t.setxattr\t= kernfs_iop_setxattr,\n\t.removexattr\t= kernfs_iop_removexattr,\n\t.getxattr\t= kernfs_iop_getxattr,\n\t.listxattr\t= kernfs_iop_listxattr,\n};\n\nstatic void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tkernfs_get(kn);\n\tinode->i_private = kn;\n\tinode->i_mapping->a_ops = &kernfs_aops;\n\tinode->i_op = &kernfs_iops;\n\n\tset_default_inode_attr(inode, kn->mode);\n\tkernfs_refresh_inode(kn, inode);\n\n\t/* initialize inode according to type */\n\tswitch (kernfs_type(kn)) {\n\tcase KERNFS_DIR:\n\t\tinode->i_op = &kernfs_dir_iops;\n\t\tinode->i_fop = &kernfs_dir_fops;\n\t\tbreak;\n\tcase KERNFS_FILE:\n\t\tinode->i_size = kn->attr.size;\n\t\tinode->i_fop = &kernfs_file_fops;\n\t\tbreak;\n\tcase KERNFS_LINK:\n\t\tinode->i_op = &kernfs_symlink_iops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tunlock_new_inode(inode);\n}"
  },
  {
    "function_name": "kernfs_iop_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "270-282",
    "snippet": "int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t   struct kstat *stat)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct inode *inode = dentry->d_inode;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_refresh_inode(kn, inode);\n\tmutex_unlock(&kernfs_mutex);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_refresh_inode",
          "args": [
            "kn",
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "251-268",
          "snippet": "static void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t   struct kstat *stat)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct inode *inode = dentry->d_inode;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_refresh_inode(kn, inode);\n\tmutex_unlock(&kernfs_mutex);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_refresh_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "251-268",
    "snippet": "static void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "kn->dir.subdirs + 2"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_notifysecctx",
          "args": [
            "inode",
            "attrs->ia_secdata",
            "attrs->ia_secdata_len"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_attr",
          "args": [
            "inode",
            "&attrs->ia_iattr"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "242-249",
          "snippet": "static inline void set_inode_attr(struct inode *inode, struct iattr *iattr)\n{\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_inode_attr(struct inode *inode, struct iattr *iattr)\n{\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic void kernfs_refresh_inode(struct kernfs_node *kn, struct inode *inode)\n{\n\tstruct kernfs_iattrs *attrs = kn->iattr;\n\n\tinode->i_mode = kn->mode;\n\tif (attrs) {\n\t\t/*\n\t\t * kernfs_node has non-default attributes get them from\n\t\t * persistent copy in kernfs_node.\n\t\t */\n\t\tset_inode_attr(inode, &attrs->ia_iattr);\n\t\tsecurity_inode_notifysecctx(inode, attrs->ia_secdata,\n\t\t\t\t\t    attrs->ia_secdata_len);\n\t}\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tset_nlink(inode, kn->dir.subdirs + 2);\n}"
  },
  {
    "function_name": "set_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "242-249",
    "snippet": "static inline void set_inode_attr(struct inode *inode, struct iattr *iattr)\n{\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_inode_attr(struct inode *inode, struct iattr *iattr)\n{\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}"
  },
  {
    "function_name": "set_default_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "236-240",
    "snippet": "static inline void set_default_inode_attr(struct inode *inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_default_inode_attr(struct inode *inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}"
  },
  {
    "function_name": "kernfs_iop_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "224-234",
    "snippet": "ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_list(&attrs->xattrs, buf, size);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_xattr_list",
          "args": [
            "&attrs->xattrs",
            "buf",
            "size"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "932-961",
          "snippet": "ssize_t simple_xattr_list(struct simple_xattrs *xattrs, char *buffer,\n\t\t\t  size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tsize_t used = 0;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tsize_t len;\n\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\tlen = strlen(xattr->name) + 1;\n\t\tused += len;\n\t\tif (buffer) {\n\t\t\tif (size < used) {\n\t\t\t\tused = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buffer, xattr->name, len);\n\t\t\tbuffer += len;\n\t\t}\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn used;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t simple_xattr_list(struct simple_xattrs *xattrs, char *buffer,\n\t\t\t  size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tsize_t used = 0;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tsize_t len;\n\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\tlen = strlen(xattr->name) + 1;\n\t\tused += len;\n\t\tif (buffer) {\n\t\t\tif (size < used) {\n\t\t\t\tused = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buffer, xattr->name, len);\n\t\t\tbuffer += len;\n\t\t}\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_list(&attrs->xattrs, buf, size);\n}"
  },
  {
    "function_name": "kernfs_iop_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "211-222",
    "snippet": "ssize_t kernfs_iop_getxattr(struct dentry *dentry, const char *name, void *buf,\n\t\t\t    size_t size)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_get(&attrs->xattrs, name, buf, size);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_xattr_get",
          "args": [
            "&attrs->xattrs",
            "name",
            "buf",
            "size"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "819-841",
          "snippet": "int simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nssize_t kernfs_iop_getxattr(struct dentry *dentry, const char *name, void *buf,\n\t\t\t    size_t size)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_get(&attrs->xattrs, name, buf, size);\n}"
  },
  {
    "function_name": "kernfs_iop_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "199-209",
    "snippet": "int kernfs_iop_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_remove(&attrs->xattrs, name);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_xattr_remove",
          "args": [
            "&attrs->xattrs",
            "name"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "919-922",
          "snippet": "int simple_xattr_remove(struct simple_xattrs *xattrs, const char *name)\n{\n\treturn __simple_xattr_set(xattrs, name, NULL, 0, XATTR_REPLACE);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_remove(struct simple_xattrs *xattrs, const char *name)\n{\n\treturn __simple_xattr_set(xattrs, name, NULL, 0, XATTR_REPLACE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_iop_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\treturn simple_xattr_remove(&attrs->xattrs, name);\n}"
  },
  {
    "function_name": "kernfs_iop_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "160-197",
    "snippet": "int kernfs_iop_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\tvoid *secdata;\n\tint error;\n\tu32 secdata_len = 0;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(dentry->d_inode, suffix,\n\t\t\t\t\t\tvalue, size, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&secdata, &secdata_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\terror = kernfs_node_setsecdata(kn, &secdata, &secdata_len);\n\t\tmutex_unlock(&kernfs_mutex);\n\n\t\tif (secdata)\n\t\t\tsecurity_release_secctx(secdata, secdata_len);\n\t\treturn error;\n\t} else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\treturn simple_xattr_set(&attrs->xattrs, name, value, size,\n\t\t\t\t\tflags);\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_xattr_set",
          "args": [
            "&attrs->xattrs",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "908-914",
          "snippet": "int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tif (size == 0)\n\t\tvalue = \"\"; /* empty EA, do not remove */\n\treturn __simple_xattr_set(xattrs, name, value, size, flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tif (size == 0)\n\t\tvalue = \"\"; /* empty EA, do not remove */\n\treturn __simple_xattr_set(xattrs, name, value, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "secdata",
            "secdata_len"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_node_setsecdata",
          "args": [
            "kn",
            "&secdata",
            "&secdata_len"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_node_setsecdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "138-158",
          "snippet": "static int kernfs_node_setsecdata(struct kernfs_node *kn, void **secdata,\n\t\t\t\t  u32 *secdata_len)\n{\n\tstruct kernfs_iattrs *attrs;\n\tvoid *old_secdata;\n\tsize_t old_secdata_len;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\told_secdata = attrs->ia_secdata;\n\told_secdata_len = attrs->ia_secdata_len;\n\n\tattrs->ia_secdata = *secdata;\n\tattrs->ia_secdata_len = *secdata_len;\n\n\t*secdata = old_secdata;\n\t*secdata_len = old_secdata_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic int kernfs_node_setsecdata(struct kernfs_node *kn, void **secdata,\n\t\t\t\t  u32 *secdata_len)\n{\n\tstruct kernfs_iattrs *attrs;\n\tvoid *old_secdata;\n\tsize_t old_secdata_len;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\told_secdata = attrs->ia_secdata;\n\told_secdata_len = attrs->ia_secdata_len;\n\n\tattrs->ia_secdata = *secdata;\n\tattrs->ia_secdata_len = *secdata_len;\n\n\t*secdata = old_secdata;\n\t*secdata_len = old_secdata_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecctx",
          "args": [
            "dentry->d_inode",
            "&secdata",
            "&secdata_len"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_setsecurity",
          "args": [
            "dentry->d_inode",
            "suffix",
            "value",
            "size",
            "flags"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_iop_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_iattrs *attrs;\n\tvoid *secdata;\n\tint error;\n\tu32 secdata_len = 0;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(dentry->d_inode, suffix,\n\t\t\t\t\t\tvalue, size, flags);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = security_inode_getsecctx(dentry->d_inode,\n\t\t\t\t\t\t&secdata, &secdata_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\terror = kernfs_node_setsecdata(kn, &secdata, &secdata_len);\n\t\tmutex_unlock(&kernfs_mutex);\n\n\t\tif (secdata)\n\t\t\tsecurity_release_secctx(secdata, secdata_len);\n\t\treturn error;\n\t} else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\treturn simple_xattr_set(&attrs->xattrs, name, value, size,\n\t\t\t\t\tflags);\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "kernfs_node_setsecdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "138-158",
    "snippet": "static int kernfs_node_setsecdata(struct kernfs_node *kn, void **secdata,\n\t\t\t\t  u32 *secdata_len)\n{\n\tstruct kernfs_iattrs *attrs;\n\tvoid *old_secdata;\n\tsize_t old_secdata_len;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\told_secdata = attrs->ia_secdata;\n\told_secdata_len = attrs->ia_secdata_len;\n\n\tattrs->ia_secdata = *secdata;\n\tattrs->ia_secdata_len = *secdata_len;\n\n\t*secdata = old_secdata;\n\t*secdata_len = old_secdata_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic int kernfs_node_setsecdata(struct kernfs_node *kn, void **secdata,\n\t\t\t\t  u32 *secdata_len)\n{\n\tstruct kernfs_iattrs *attrs;\n\tvoid *old_secdata;\n\tsize_t old_secdata_len;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\told_secdata = attrs->ia_secdata;\n\told_secdata_len = attrs->ia_secdata_len;\n\n\tattrs->ia_secdata = *secdata;\n\tattrs->ia_secdata_len = *secdata_len;\n\n\t*secdata = old_secdata;\n\t*secdata_len = old_secdata_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_iop_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "112-136",
    "snippet": "int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tint error;\n\n\tif (!kn)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\tgoto out;\n\n\terror = __kernfs_setattr(kn, iattr);\n\tif (error)\n\t\tgoto out;\n\n\t/* this ignores size changes */\n\tsetattr_copy(inode, iattr);\n\nout:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kernfs_setattr",
          "args": [
            "kn",
            "iattr"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "66-93",
          "snippet": "static int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tint error;\n\n\tif (!kn)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\tgoto out;\n\n\terror = __kernfs_setattr(kn, iattr);\n\tif (error)\n\t\tgoto out;\n\n\t/* this ignores size changes */\n\tsetattr_copy(inode, iattr);\n\nout:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "kernfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "102-110",
    "snippet": "int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tret = __kernfs_setattr(kn, iattr);\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_setattr",
          "args": [
            "kn",
            "iattr"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "66-93",
          "snippet": "static int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nint kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tret = __kernfs_setattr(kn, iattr);\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__kernfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "66-93",
    "snippet": "static int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_iattrs",
          "args": [
            "kn"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_iattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "37-64",
          "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr)\n{\n\tstruct kernfs_iattrs *attrs;\n\tstruct iattr *iattrs;\n\tunsigned int ia_valid = iattr->ia_valid;\n\n\tattrs = kernfs_iattrs(kn);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tiattrs = &attrs->ia_iattr;\n\n\tif (ia_valid & ATTR_UID)\n\t\tiattrs->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tiattrs->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tiattrs->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tiattrs->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tiattrs->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\t\tiattrs->ia_mode = kn->mode = mode;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_iattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
    "lines": "37-64",
    "snippet": "static struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&iattr_mutex"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_xattrs_init",
          "args": [
            "&kn->iattr->xattrs"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kernfs_iattrs)",
            "GFP_KERNEL"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&iattr_mutex"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstatic struct kernfs_iattrs *kernfs_iattrs(struct kernfs_node *kn)\n{\n\tstatic DEFINE_MUTEX(iattr_mutex);\n\tstruct kernfs_iattrs *ret;\n\tstruct iattr *iattrs;\n\n\tmutex_lock(&iattr_mutex);\n\n\tif (kn->iattr)\n\t\tgoto out_unlock;\n\n\tkn->iattr = kzalloc(sizeof(struct kernfs_iattrs), GFP_KERNEL);\n\tif (!kn->iattr)\n\t\tgoto out_unlock;\n\tiattrs = &kn->iattr->ia_iattr;\n\n\t/* assign default attributes */\n\tiattrs->ia_mode = kn->mode;\n\tiattrs->ia_uid = GLOBAL_ROOT_UID;\n\tiattrs->ia_gid = GLOBAL_ROOT_GID;\n\tiattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;\n\n\tsimple_xattrs_init(&kn->iattr->xattrs);\nout_unlock:\n\tret = kn->iattr;\n\tmutex_unlock(&iattr_mutex);\n\treturn ret;\n}"
  }
]