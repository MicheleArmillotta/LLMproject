[
  {
    "function_name": "CIFSSMBNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "6458-6524",
    "snippet": "int CIFSSMBNotify(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const int notify_subdirs, const __u16 netfid,\n\t\t  __u32 filter, struct file *pfile, int multishot,\n\t\t  const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tstruct smb_com_transaction_change_notify_req *pSMB = NULL;\n\tstruct smb_com_ntransaction_change_notify_rsp *pSMBr = NULL;\n\tstruct dir_notify_req *dnotify_req;\n\tint bytes_returned;\n\n\tcifs_dbg(FYI, \"In CIFSSMBNotify for file handle %d\\n\", (int)netfid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4; /* single byte does not need le conversion */\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_NOTIFY_CHANGE);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (notify_subdirs)\n\t\tpSMB->WatchTree = 1; /* one byte - no le conversion needed */\n\tpSMB->Reserved2 = 0;\n\tpSMB->CompletionFilter = cpu_to_le32(filter);\n\tpSMB->Fid = netfid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *)pSMBr, &bytes_returned,\n\t\t\t CIFS_ASYNC_OP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Notify = %d\\n\", rc);\n\t} else {\n\t\t/* Add file to outstanding requests */\n\t\t/* BB change to kmem cache alloc */\n\t\tdnotify_req = kmalloc(\n\t\t\t\t\t\tsizeof(struct dir_notify_req),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (dnotify_req) {\n\t\t\tdnotify_req->Pid = pSMB->hdr.Pid;\n\t\t\tdnotify_req->PidHigh = pSMB->hdr.PidHigh;\n\t\t\tdnotify_req->Mid = pSMB->hdr.Mid;\n\t\t\tdnotify_req->Tid = pSMB->hdr.Tid;\n\t\t\tdnotify_req->Uid = pSMB->hdr.Uid;\n\t\t\tdnotify_req->netfid = netfid;\n\t\t\tdnotify_req->pfile = pfile;\n\t\t\tdnotify_req->filter = filter;\n\t\t\tdnotify_req->multishot = multishot;\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tlist_add_tail(&dnotify_req->lhead,\n\t\t\t\t\t&GlobalDnotifyReqList);\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t} else\n\t\t\trc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 6522
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 6518
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dnotify_req->lhead",
            "&GlobalDnotifyReqList"
          ],
          "line": 6516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 6515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct dir_notify_req)",
            "GFP_KERNEL"
          ],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in Notify = %d\\n\"",
            "rc"
          ],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *)pSMBr",
            "&bytes_returned",
            "CIFS_ASYNC_OP"
          ],
          "line": 6494
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "filter"
          ],
          "line": 6490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NT_TRANSACT_NOTIFY_CHANGE"
          ],
          "line": 6485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CIFSMaxBufSize & 0xFFFFFF00"
          ],
          "line": 6478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2"
          ],
          "line": 6477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_TRANSACT",
            "23",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 6470
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBNotify for file handle %d\\n\"",
            "(int)netfid"
          ],
          "line": 6469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint CIFSSMBNotify(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const int notify_subdirs, const __u16 netfid,\n\t\t  __u32 filter, struct file *pfile, int multishot,\n\t\t  const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tstruct smb_com_transaction_change_notify_req *pSMB = NULL;\n\tstruct smb_com_ntransaction_change_notify_rsp *pSMBr = NULL;\n\tstruct dir_notify_req *dnotify_req;\n\tint bytes_returned;\n\n\tcifs_dbg(FYI, \"In CIFSSMBNotify for file handle %d\\n\", (int)netfid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4; /* single byte does not need le conversion */\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_NOTIFY_CHANGE);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (notify_subdirs)\n\t\tpSMB->WatchTree = 1; /* one byte - no le conversion needed */\n\tpSMB->Reserved2 = 0;\n\tpSMB->CompletionFilter = cpu_to_le32(filter);\n\tpSMB->Fid = netfid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *)pSMBr, &bytes_returned,\n\t\t\t CIFS_ASYNC_OP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Notify = %d\\n\", rc);\n\t} else {\n\t\t/* Add file to outstanding requests */\n\t\t/* BB change to kmem cache alloc */\n\t\tdnotify_req = kmalloc(\n\t\t\t\t\t\tsizeof(struct dir_notify_req),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (dnotify_req) {\n\t\t\tdnotify_req->Pid = pSMB->hdr.Pid;\n\t\t\tdnotify_req->PidHigh = pSMB->hdr.PidHigh;\n\t\t\tdnotify_req->Mid = pSMB->hdr.Mid;\n\t\t\tdnotify_req->Tid = pSMB->hdr.Tid;\n\t\t\tdnotify_req->Uid = pSMB->hdr.Uid;\n\t\t\tdnotify_req->netfid = netfid;\n\t\t\tdnotify_req->pfile = pfile;\n\t\t\tdnotify_req->filter = filter;\n\t\t\tdnotify_req->multishot = multishot;\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tlist_add_tail(&dnotify_req->lhead,\n\t\t\t\t\t&GlobalDnotifyReqList);\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t} else\n\t\t\trc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetEA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "6330-6434",
    "snippet": "int\nCIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,\n\t     const char *fileName, const char *ea_name, const void *ea_value,\n\t     const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t     int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct fealist *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, byte_count, offset, count;\n\n\tcifs_dbg(FYI, \"In SetEA\\n\");\nSetEARetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\n\t/* done calculating parms using name_len of file name,\n\tnow use name_len to calculate length of ea name\n\twe are going to create in the inode xattrs */\n\tif (ea_name == NULL)\n\t\tname_len = 0;\n\telse\n\t\tname_len = strnlen(ea_name, 255);\n\n\tcount = sizeof(*parm_data) + ea_value_len + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_EA);\n\n\tparm_data =\n\t\t(struct fealist *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tparm_data->list_len = cpu_to_le32(count);\n\tparm_data->list[0].EA_flags = 0;\n\t/* we checked above that name len is less than 255 */\n\tparm_data->list[0].name_len = (__u8)name_len;\n\t/* EA names are always ASCII */\n\tif (ea_name)\n\t\tstrncpy(parm_data->list[0].name, ea_name, name_len);\n\tparm_data->list[0].name[name_len] = 0;\n\tparm_data->list[0].value_len = cpu_to_le16(ea_value_len);\n\t/* caller ensures that ea_value_len is less than 64K but\n\twe need to ensure that it fits within the smb */\n\n\t/*BB add length check to see if it would fit in\n\t     negotiated SMB buffer size BB */\n\t/* if (ea_value_len > buffer_size - 512 (enough for header)) */\n\tif (ea_value_len)\n\t\tmemcpy(parm_data->list[0].name+name_len+1,\n\t\t       ea_value, ea_value_len);\n\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (EA) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEARetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetPathInfo (EA) returned %d\\n\"",
            "rc"
          ],
          "line": 6426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 6423
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 6422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 6421
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 6418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "parm_data->list[0].name+name_len+1",
            "ea_value",
            "ea_value_len"
          ],
          "line": 6414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ea_value_len"
          ],
          "line": 6406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "parm_data->list[0].name",
            "ea_name",
            "name_len"
          ],
          "line": 6404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "count"
          ],
          "line": 6398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 6397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 6395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 6392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 6391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_EA"
          ],
          "line": 6386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 6376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 6374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "ea_name",
            "255"
          ],
          "line": 6371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "fileName",
            "name_len"
          ],
          "line": 6360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "fileName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 6353
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 6346
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetEA\\n\""
          ],
          "line": 6344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,\n\t     const char *fileName, const char *ea_name, const void *ea_value,\n\t     const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t     int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct fealist *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, byte_count, offset, count;\n\n\tcifs_dbg(FYI, \"In SetEA\\n\");\nSetEARetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\n\t/* done calculating parms using name_len of file name,\n\tnow use name_len to calculate length of ea name\n\twe are going to create in the inode xattrs */\n\tif (ea_name == NULL)\n\t\tname_len = 0;\n\telse\n\t\tname_len = strnlen(ea_name, 255);\n\n\tcount = sizeof(*parm_data) + ea_value_len + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_EA);\n\n\tparm_data =\n\t\t(struct fealist *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tparm_data->list_len = cpu_to_le32(count);\n\tparm_data->list[0].EA_flags = 0;\n\t/* we checked above that name len is less than 255 */\n\tparm_data->list[0].name_len = (__u8)name_len;\n\t/* EA names are always ASCII */\n\tif (ea_name)\n\t\tstrncpy(parm_data->list[0].name, ea_name, name_len);\n\tparm_data->list[0].name[name_len] = 0;\n\tparm_data->list[0].value_len = cpu_to_le16(ea_value_len);\n\t/* caller ensures that ea_value_len is less than 64K but\n\twe need to ensure that it fits within the smb */\n\n\t/*BB add length check to see if it would fit in\n\t     negotiated SMB buffer size BB */\n\t/* if (ea_value_len > buffer_size - 512 (enough for header)) */\n\tif (ea_value_len)\n\t\tmemcpy(parm_data->list[0].name+name_len+1,\n\t\t       ea_value, ea_value_len);\n\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (EA) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEARetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQAllEAs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "6144-6328",
    "snippet": "ssize_t\nCIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst unsigned char *searchName, const unsigned char *ea_name,\n\t\tchar *EAData, size_t buf_size,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\t\t/* BB assumes one setup word */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint list_len;\n\tstruct fealist *ea_response_data;\n\tstruct fea *temp_fea;\n\tchar *temp_ptr;\n\tchar *end_of_smb;\n\t__u16 params, byte_count, data_offset;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\n\tcifs_dbg(FYI, \"In Query All EAs path %s\\n\", searchName);\nQAllEAsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tlist_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tlist_len++;\t/* trailing null */\n\t\tlist_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tlist_len = strnlen(searchName, PATH_MAX);\n\t\tlist_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, list_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + list_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryAllEAs = %d\\n\", rc);\n\t\tgoto QAllEAsOut;\n\t}\n\n\n\t/* BB also check enough total bytes returned */\n\t/* BB we need to improve the validity checking\n\tof these trans2 responses */\n\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc || get_bcc(&pSMBr->hdr) < 4) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* check that length of list is not more than bcc */\n\t/* check that each entry does not go beyond length\n\t   of list */\n\t/* check that each element of each entry does not\n\t   go beyond end of list */\n\t/* validate_trans2_offsets() */\n\t/* BB check if start of smb + data_offset > &bcc+ bcc */\n\n\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\tea_response_data = (struct fealist *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\n\tlist_len = le32_to_cpu(ea_response_data->list_len);\n\tcifs_dbg(FYI, \"ea length %d\\n\", list_len);\n\tif (list_len <= 8) {\n\t\tcifs_dbg(FYI, \"empty EA list returned from server\\n\");\n\t\t/* didn't find the named attribute */\n\t\tif (ea_name)\n\t\t\trc = -ENODATA;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* make sure list_len doesn't go past end of SMB */\n\tend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\n\tif ((char *)ea_response_data + list_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"EA list appears to go beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* account for ea list len */\n\tlist_len -= 4;\n\ttemp_fea = ea_response_data->list;\n\ttemp_ptr = (char *)temp_fea;\n\twhile (list_len > 0) {\n\t\tunsigned int name_len;\n\t\t__u16 value_len;\n\n\t\tlist_len -= 4;\n\t\ttemp_ptr += 4;\n\t\t/* make sure we can read name_len and value_len */\n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tname_len = temp_fea->name_len;\n\t\tvalue_len = le16_to_cpu(temp_fea->value_len);\n\t\tlist_len -= name_len + 1 + value_len;\n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    memcmp(ea_name, temp_ptr, name_len) == 0) {\n\t\t\t\ttemp_ptr += name_len + 1;\n\t\t\t\trc = value_len;\n\t\t\t\tif (buf_size == 0)\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\tif ((size_t)value_len > buf_size) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\t}\n\t\t\t\tmemcpy(EAData, temp_ptr, value_len);\n\t\t\t\tgoto QAllEAsOut;\n\t\t\t}\n\t\t} else {\n\t\t\t/* account for prefix user. and trailing null */\n\t\t\trc += (5 + 1 + name_len);\n\t\t\tif (rc < (int) buf_size) {\n\t\t\t\tmemcpy(EAData, \"user.\", 5);\n\t\t\t\tEAData += 5;\n\t\t\t\tmemcpy(EAData, temp_ptr, name_len);\n\t\t\t\tEAData += name_len;\n\t\t\t\t/* null terminate name */\n\t\t\t\t*EAData = 0;\n\t\t\t\t++EAData;\n\t\t\t} else if (buf_size == 0) {\n\t\t\t\t/* skip copy - calc size only */\n\t\t\t} else {\n\t\t\t\t/* stop before overrun buffer */\n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttemp_ptr += name_len + 1 + value_len;\n\t\ttemp_fea = (struct fea *)temp_ptr;\n\t}\n\n\t/* didn't find the named attribute */\n\tif (ea_name)\n\t\trc = -ENODATA;\n\nQAllEAsOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QAllEAsRetry;\n\n\treturn (ssize_t)rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 6323
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "EAData",
            "temp_ptr",
            "name_len"
          ],
          "line": 6301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "EAData",
            "\"user.\"",
            "5"
          ],
          "line": 6299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "EAData",
            "temp_ptr",
            "value_len"
          ],
          "line": 6292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ea_name",
            "temp_ptr",
            "name_len"
          ],
          "line": 6283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"EA entry goes beyond length of list\\n\""
          ],
          "line": 6276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "temp_fea->value_len"
          ],
          "line": 6273
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"EA entry goes beyond length of list\\n\""
          ],
          "line": 6267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"EA list appears to go beyond SMB\\n\""
          ],
          "line": 6250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 6248
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pByteArea",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 6248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"empty EA list returned from server\\n\""
          ],
          "line": 6240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ea length %d\\n\"",
            "list_len"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ea_response_data->list_len"
          ],
          "line": 6237
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 6219
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QueryAllEAs = %d\\n\"",
            "rc"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 6205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 6204
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_INFO_QUERY_ALL_EAS"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 6200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 6198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4"
          ],
          "line": 6192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize"
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 6184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "searchName",
            "list_len"
          ],
          "line": 6179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "searchName",
            "PATH_MAX"
          ],
          "line": 6177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "searchName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 6172
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 6165
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In Query All EAs path %s\\n\"",
            "searchName"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ea_name"
          ],
          "line": 6161
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nssize_t\nCIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst unsigned char *searchName, const unsigned char *ea_name,\n\t\tchar *EAData, size_t buf_size,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\t\t/* BB assumes one setup word */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint list_len;\n\tstruct fealist *ea_response_data;\n\tstruct fea *temp_fea;\n\tchar *temp_ptr;\n\tchar *end_of_smb;\n\t__u16 params, byte_count, data_offset;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\n\tcifs_dbg(FYI, \"In Query All EAs path %s\\n\", searchName);\nQAllEAsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tlist_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tlist_len++;\t/* trailing null */\n\t\tlist_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tlist_len = strnlen(searchName, PATH_MAX);\n\t\tlist_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, list_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + list_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryAllEAs = %d\\n\", rc);\n\t\tgoto QAllEAsOut;\n\t}\n\n\n\t/* BB also check enough total bytes returned */\n\t/* BB we need to improve the validity checking\n\tof these trans2 responses */\n\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc || get_bcc(&pSMBr->hdr) < 4) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* check that length of list is not more than bcc */\n\t/* check that each entry does not go beyond length\n\t   of list */\n\t/* check that each element of each entry does not\n\t   go beyond end of list */\n\t/* validate_trans2_offsets() */\n\t/* BB check if start of smb + data_offset > &bcc+ bcc */\n\n\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\tea_response_data = (struct fealist *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\n\tlist_len = le32_to_cpu(ea_response_data->list_len);\n\tcifs_dbg(FYI, \"ea length %d\\n\", list_len);\n\tif (list_len <= 8) {\n\t\tcifs_dbg(FYI, \"empty EA list returned from server\\n\");\n\t\t/* didn't find the named attribute */\n\t\tif (ea_name)\n\t\t\trc = -ENODATA;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* make sure list_len doesn't go past end of SMB */\n\tend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\n\tif ((char *)ea_response_data + list_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"EA list appears to go beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* account for ea list len */\n\tlist_len -= 4;\n\ttemp_fea = ea_response_data->list;\n\ttemp_ptr = (char *)temp_fea;\n\twhile (list_len > 0) {\n\t\tunsigned int name_len;\n\t\t__u16 value_len;\n\n\t\tlist_len -= 4;\n\t\ttemp_ptr += 4;\n\t\t/* make sure we can read name_len and value_len */\n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tname_len = temp_fea->name_len;\n\t\tvalue_len = le16_to_cpu(temp_fea->value_len);\n\t\tlist_len -= name_len + 1 + value_len;\n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    memcmp(ea_name, temp_ptr, name_len) == 0) {\n\t\t\t\ttemp_ptr += name_len + 1;\n\t\t\t\trc = value_len;\n\t\t\t\tif (buf_size == 0)\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\tif ((size_t)value_len > buf_size) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\t}\n\t\t\t\tmemcpy(EAData, temp_ptr, value_len);\n\t\t\t\tgoto QAllEAsOut;\n\t\t\t}\n\t\t} else {\n\t\t\t/* account for prefix user. and trailing null */\n\t\t\trc += (5 + 1 + name_len);\n\t\t\tif (rc < (int) buf_size) {\n\t\t\t\tmemcpy(EAData, \"user.\", 5);\n\t\t\t\tEAData += 5;\n\t\t\t\tmemcpy(EAData, temp_ptr, name_len);\n\t\t\t\tEAData += name_len;\n\t\t\t\t/* null terminate name */\n\t\t\t\t*EAData = 0;\n\t\t\t\t++EAData;\n\t\t\t} else if (buf_size == 0) {\n\t\t\t\t/* skip copy - calc size only */\n\t\t\t} else {\n\t\t\t\t/* stop before overrun buffer */\n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttemp_ptr += name_len + 1 + value_len;\n\t\ttemp_fea = (struct fea *)temp_ptr;\n\t}\n\n\t/* didn't find the named attribute */\n\tif (ea_name)\n\t\trc = -ENODATA;\n\nQAllEAsOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QAllEAsRetry;\n\n\treturn (ssize_t)rc;\n}"
  },
  {
    "function_name": "CIFSSMBUnixSetPathInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "6056-6132",
    "snippet": "int\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 6128
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetPathInfo (perms) returned %d\\n\"",
            "rc"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 6123
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 6122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_unix_set_info",
          "args": [
            "data_offset",
            "args"
          ],
          "line": 6120
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_unix_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5944-5989",
          "snippet": "static void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 6118
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_UNIX_BASIC"
          ],
          "line": 6116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 6112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data_offset",
            "0",
            "count"
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 6093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 6091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "file_name",
            "name_len"
          ],
          "line": 6086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "file_name",
            "PATH_MAX"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "file_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 6079
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 6072
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetUID/GID/Mode\\n\""
          ],
          "line": 6070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBUnixSetFileInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5991-6054",
    "snippet": "int\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Set Time (SetFileInfo) = %d\\n\"",
            "rc"
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 6045
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_unix_set_info",
          "args": [
            "(FILE_UNIX_BASIC_INFO *)data_offset",
            "args"
          ],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_unix_set_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5944-5989",
          "snippet": "static void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 6040
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_UNIX_BASIC"
          ],
          "line": 6038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 6035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 6032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 6031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 6029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 6026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid_of_opener >> 16)"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid_of_opener >> 16"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid_of_opener"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 6002
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set Unix Info (via SetFileInfo)\\n\""
          ],
          "line": 6001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_fill_unix_set_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5944-5989",
    "snippet": "static void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_SOCKET"
          ],
          "line": 5988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_FIFO"
          ],
          "line": 5986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 5985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_BLOCKDEV"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_CHARDEV"
          ],
          "line": 5982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_SYMLINK"
          ],
          "line": 5980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_DIR"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 5977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "UNIX_FILE"
          ],
          "line": 5976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "mode"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MINOR(args->device)"
          ],
          "line": 5972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "args->device"
          ],
          "line": 5972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MAJOR(args->device)"
          ],
          "line": 5971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "args->device"
          ],
          "line": 5971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "gid"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "uid"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "args->mtime"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "args->atime"
          ],
          "line": 5966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "args->ctime"
          ],
          "line": 5965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "NO_CHANGE_64"
          ],
          "line": 5964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "NO_CHANGE_64"
          ],
          "line": 5963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "args->gid"
          ],
          "line": 5954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "args->gid"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "args->uid"
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "args->uid"
          ],
          "line": 5951
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}"
  },
  {
    "function_name": "CIFSSMBSetAttrLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5897-5941",
    "snippet": "int\nCIFSSMBSetAttrLegacy(unsigned int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t__u16 dos_attrs, const struct nls_table *nls_codepage)\n{\n\tSETATTR_REQ *pSMB = NULL;\n\tSETATTR_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SetAttrLegacy\\n\");\n\nSetAttrLgcyRetry:\n\trc = smb_init(SMB_COM_SETATTR, 8, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tConvertToUTF16((__le16 *) pSMB->fileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->attr = cpu_to_le16(dos_attrs);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in LegacySetAttr = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetAttrLgcyRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5935
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in LegacySetAttr = %d\\n\"",
            "rc"
          ],
          "line": 5933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5930
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len + 1"
          ],
          "line": 5929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "name_len + 1"
          ],
          "line": 5928
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "dos_attrs"
          ],
          "line": 5926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->fileName",
            "fileName",
            "name_len"
          ],
          "line": 5924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->fileName",
            "fileName",
            "PATH_MAX",
            "nls_codepage"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_SETATTR",
            "8",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5910
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetAttrLegacy\\n\""
          ],
          "line": 5907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetAttrLegacy(unsigned int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t__u16 dos_attrs, const struct nls_table *nls_codepage)\n{\n\tSETATTR_REQ *pSMB = NULL;\n\tSETATTR_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SetAttrLegacy\\n\");\n\nSetAttrLgcyRetry:\n\trc = smb_init(SMB_COM_SETATTR, 8, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tConvertToUTF16((__le16 *) pSMB->fileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->attr = cpu_to_le16(dos_attrs);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in LegacySetAttr = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetAttrLgcyRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetPathInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5813-5890",
    "snippet": "int\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetPathInfo (times) returned %d\\n\"",
            "rc"
          ],
          "line": 5882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5879
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_offset",
            "data",
            "sizeof(FILE_BASIC_INFO)"
          ],
          "line": 5877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5876
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_BASIC_INFO"
          ],
          "line": 5874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_BASIC_INFO2"
          ],
          "line": 5872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 5867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 5864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "fileName",
            "name_len"
          ],
          "line": 5843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 5841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "fileName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 5836
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5829
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetTimes\\n\""
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetFileDisposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5757-5811",
    "snippet": "int\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set File Disposition (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetFileDisposition = %d\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in SetFileDisposition = %d\\n\"",
            "rc"
          ],
          "line": 5808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 5806
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5803
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_DISPOSITION_INFO"
          ],
          "line": 5801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid_of_opener >> 16)"
          ],
          "line": 5773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid_of_opener >> 16"
          ],
          "line": 5773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid_of_opener"
          ],
          "line": 5772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 5767
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set File Disposition (via SetFileInfo)\\n\""
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set File Disposition (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetFileDisposition = %d\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetFileInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5693-5755",
    "snippet": "int\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Set Time (SetFileInfo) = %d\\n\"",
            "rc"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 5746
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_offset",
            "data",
            "sizeof(FILE_BASIC_INFO)"
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5743
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_BASIC_INFO"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_BASIC_INFO2"
          ],
          "line": 5739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 5731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid_of_opener >> 16)"
          ],
          "line": 5709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid_of_opener >> 16"
          ],
          "line": 5709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid_of_opener"
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set Times (via SetFileInfo)\\n\""
          ],
          "line": 5702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetFileSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5610-5685",
    "snippet": "int\nCIFSSMBSetFileSize(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_allocation)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"SetFileSize (via SetFileInfo) %lld\\n\",\n\t\t (long long)size);\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)cfile->pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(cfile->pid >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data =\n\t\t(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol)\n\t\t\t\t+ offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->Fid = cfile->fid.netfid;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in SetFileInfo (SetFileSize) = %d\\n\",\n\t\t\t rc);\n\t}\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in SetFileInfo (SetFileSize) = %d\\n\"",
            "rc"
          ],
          "line": 5677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5673
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_END_OF_FILE_INFO"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_END_OF_FILE_INFO2"
          ],
          "line": 5667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_ALLOCATION_INFO"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_ALLOCATION_INFO2"
          ],
          "line": 5660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "size"
          ],
          "line": 5655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 5646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(cfile->pid >> 16)"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cfile->pid >> 16"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)cfile->pid"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 5621
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetFileSize (via SetFileInfo) %lld\\n\"",
            "(long long)size"
          ],
          "line": 5619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileSize(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_allocation)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"SetFileSize (via SetFileInfo) %lld\\n\",\n\t\t (long long)size);\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)cfile->pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(cfile->pid >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data =\n\t\t(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol)\n\t\t\t\t+ offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->Fid = cfile->fid.netfid;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in SetFileInfo (SetFileSize) = %d\\n\",\n\t\t\t rc);\n\t}\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetEOF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5519-5608",
    "snippet": "int\nCIFSSMBSetEOF(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *file_name, __u64 size, struct cifs_sb_info *cifs_sb,\n\t      bool set_allocation)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint remap = cifs_remap(cifs_sb);\n\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetEOF\\n\");\nSetEOFRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\tparams = 6 + name_len;\n\tdata_count = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(4100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\n\tparm_data =\n\t    (struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (file size) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEOFRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5602
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetPathInfo (file size) returned %d\\n\"",
            "rc"
          ],
          "line": 5600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5597
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "size"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5594
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "data_count"
          ],
          "line": 5589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 5587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_END_OF_FILE_INFO"
          ],
          "line": 5577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_END_OF_FILE_INFO2"
          ],
          "line": 5574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_ALLOCATION_INFO"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_ALLOCATION_INFO2"
          ],
          "line": 5567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4100"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "file_name",
            "name_len"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "file_name",
            "PATH_MAX"
          ],
          "line": 5548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "file_name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetEOF\\n\""
          ],
          "line": 5534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetEOF(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *file_name, __u64 size, struct cifs_sb_info *cifs_sb,\n\t      bool set_allocation)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint remap = cifs_remap(cifs_sb);\n\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetEOF\\n\");\nSetEOFRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\tparams = 6 + name_len;\n\tdata_count = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(4100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\n\tparm_data =\n\t    (struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (file size) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEOFRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFSPosixInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5426-5510",
    "snippet": "int\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSPosixInfo\\n\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5504
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "response_data->FreeFileNodes"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "-1"
          ],
          "line": 5499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "-1"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "-1"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "response_data->BlockSize"
          ],
          "line": 5485
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5476
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5474
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QFSUnixInfo = %d\\n\"",
            "rc"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_POSIX_FS_INFO"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "100"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5440
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QFSPosixInfo\\n\""
          ],
          "line": 5438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSPosixInfo\\n\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetFSUnixInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5352-5422",
    "snippet": "int\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In SETFSUnixInfo\\n\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SETFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5416
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5412
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in SETFSUnixInfo = %d\\n\"",
            "rc"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5407
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5404
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cap"
          ],
          "line": 5402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_UNIX_MINOR_VERSION"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_UNIX_MAJOR_VERSION"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_CIFS_UNIX_INFO"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 5393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 5392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "12"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FS_INFORMATION"
          ],
          "line": 5385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "100"
          ],
          "line": 5382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init_no_reconnect",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_no_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "324-332",
          "snippet": "static int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SETFSUnixInfo\\n\""
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In SETFSUnixInfo\\n\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SETFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFSUnixInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5282-5350",
    "snippet": "int\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSUnixInfo\\n\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5343
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcon->fsUnixInfo",
            "response_data",
            "sizeof(FILE_SYSTEM_UNIX_INFO)"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 5334
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5331
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5329
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in QFSUnixInfo = %d\\n\"",
            "rc"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_CIFS_UNIX_INFO"
          ],
          "line": 5320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "100"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init_no_reconnect",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_no_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "324-332",
          "snippet": "static int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QFSUnixInfo\\n\""
          ],
          "line": 5293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSUnixInfo\\n\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFSDeviceInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5211-5280",
    "snippet": "int\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5274
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcon->fsDevInfo",
            "response_data",
            "sizeof(FILE_SYSTEM_DEVICE_INFO)"
          ],
          "line": 5270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5261
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5259
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QFSDeviceInfo = %d\\n\"",
            "rc"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5254
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5251
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FS_DEVICE_INFO"
          ],
          "line": 5250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QFSDeviceInfo\\n\""
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFSAttributeInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5141-5209",
    "snippet": "int\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSAttributeInfo\\n\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSAttributeInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5203
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tcon->fsAttrInfo",
            "response_data",
            "sizeof(FILE_SYSTEM_ATTRIBUTE_INFO)"
          ],
          "line": 5199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5190
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5188
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in QFSAttributeInfo = %d\\n\"",
            "rc"
          ],
          "line": 5186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5183
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FS_ATTRIBUTE_INFO"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5154
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QFSAttributeInfo\\n\""
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSAttributeInfo\\n\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSAttributeInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFSInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "5061-5139",
    "snippet": "int\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSInfo\\n\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5133
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Blocks: %lld  Free: %lld Block size %ld\\n\"",
            "(unsigned long long)FSData->f_blocks",
            "(unsigned long long)FSData->f_bfree",
            "FSData->f_bsize"
          ],
          "line": 5127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "response_data->FreeAllocationUnits"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "response_data->\n\t\t\t\t\tSectorsPerAllocationUnit"
          ],
          "line": 5121
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 5113
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5108
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QFSInfo = %d\\n\"",
            "rc"
          ],
          "line": 5106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5103
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5100
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FS_SIZE_INFO"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 5075
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QFSInfo\\n\""
          ],
          "line": 5073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSInfo\\n\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMBOldQFSInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4981-5059",
    "snippet": "int\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"OldQFSInfo\\n\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcifs_dbg(FYI, \"qfsinf resp BCC: %d  Offset %d\\n\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Blocks: %lld  Free: %lld Block size %ld\\n\"",
            "(unsigned long long)FSData->f_blocks",
            "(unsigned long long)FSData->f_bfree",
            "FSData->f_bsize"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "response_data->FreeAllocationUnits"
          ],
          "line": 5046
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "response_data->BytesPerSector"
          ],
          "line": 5040
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"qfsinf resp BCC: %d  Offset %d\\n\"",
            "get_bcc(&pSMBr->hdr)",
            "data_offset"
          ],
          "line": 5034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 5035
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QFSInfo = %d\\n\"",
            "rc"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 5023
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 5020
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_INFO_ALLOCATION"
          ],
          "line": 5019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FS_INFORMATION"
          ],
          "line": 5018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 5003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4995
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"OldQFSInfo\\n\""
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"OldQFSInfo\\n\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcifs_dbg(FYI, \"qfsinf resp BCC: %d  Offset %d\\n\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSGetDFSRefer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4871-4978",
    "snippet": "int\nCIFSGetDFSRefer(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst char *search_name, struct dfs_info3_param **target_nodes,\n\t\tunsigned int *num_of_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n/* TRANS2_GET_DFS_REFERRAL */\n\tTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\n\tTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\t*num_of_nodes = 0;\n\t*target_nodes = NULL;\n\n\tcifs_dbg(FYI, \"In GetDFSRefer the path %s\\n\", search_name);\n\tif (ses == NULL)\n\t\treturn -ENODEV;\ngetDFSRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, NULL, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* server pointer checked in called function,\n\tbut should never be null here anyway */\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\tpSMB->hdr.Tid = ses->ipc_tid;\n\tpSMB->hdr.Uid = ses->Suid;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\tif (ses->capabilities & CAP_DFS)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_DFS;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->RequestFileName,\n\t\t\t\t       search_name, PATH_MAX, nls_codepage,\n\t\t\t\t       remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->RequestFileName, search_name, name_len);\n\t}\n\n\tif (ses->server && ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tparams = 2 /* level */  + name_len /*includes null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = 0;\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\n\tbyte_count = params + 3 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->MaxReferralLevel = cpu_to_le16(3);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in GetDFSRefer = %d\\n\", rc);\n\t\tgoto GetDFSRefExit;\n\t}\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t/* BB Also check if enough total bytes returned? */\n\tif (rc || get_bcc(&pSMBr->hdr) < 17) {\n\t\trc = -EIO;      /* bad smb */\n\t\tgoto GetDFSRefExit;\n\t}\n\n\tcifs_dbg(FYI, \"Decoding GetDFSRefer response BCC: %d  Offset %d\\n\",\n\t\t get_bcc(&pSMBr->hdr), le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t/* parse returned result into more usable form */\n\trc = parse_DFS_referrals(pSMBr, num_of_nodes,\n\t\t\t\t target_nodes, nls_codepage, remap,\n\t\t\t\t search_name);\n\nGetDFSRefExit:\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto getDFSRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4972
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_DFS_referrals",
          "args": [
            "pSMBr",
            "num_of_nodes",
            "target_nodes",
            "nls_codepage",
            "remap",
            "search_name"
          ],
          "line": 4967
        },
        "resolved": true,
        "details": {
          "function_name": "parse_DFS_referrals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4766-4869",
          "snippet": "static int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcifs_dbg(VFS, \"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\",\n\t\t\t *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcifs_dbg(VFS, \"Referrals of V%d version are not supported, should be V3\\n\",\n\t\t\t le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcifs_dbg(FYI, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t *num_of_nodes, le32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\n\t\t\t\tGFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUTF16((__le16 *) tmp, searchName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_utf16_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->node_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\tref++;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcifs_dbg(VFS, \"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\",\n\t\t\t *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcifs_dbg(VFS, \"Referrals of V%d version are not supported, should be V3\\n\",\n\t\t\t le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcifs_dbg(FYI, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t *num_of_nodes, le32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\n\t\t\t\tGFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUTF16((__le16 *) tmp, searchName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_utf16_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->node_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\tref++;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Decoding GetDFSRefer response BCC: %d  Offset %d\\n\"",
            "get_bcc(&pSMBr->hdr)",
            "le16_to_cpu(pSMBr->t2.DataOffset)"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in GetDFSRefer = %d\\n\"",
            "rc"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "3"
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_GET_DFS_REFERRAL"
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->RequestFileName",
            "search_name",
            "name_len"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "search_name",
            "PATH_MAX"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->RequestFileName",
            "search_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "ses->server"
          ],
          "line": 4898
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "NULL",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4891
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In GetDFSRefer the path %s\\n\"",
            "search_name"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSGetDFSRefer(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst char *search_name, struct dfs_info3_param **target_nodes,\n\t\tunsigned int *num_of_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n/* TRANS2_GET_DFS_REFERRAL */\n\tTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\n\tTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\t*num_of_nodes = 0;\n\t*target_nodes = NULL;\n\n\tcifs_dbg(FYI, \"In GetDFSRefer the path %s\\n\", search_name);\n\tif (ses == NULL)\n\t\treturn -ENODEV;\ngetDFSRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, NULL, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* server pointer checked in called function,\n\tbut should never be null here anyway */\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\tpSMB->hdr.Tid = ses->ipc_tid;\n\tpSMB->hdr.Uid = ses->Suid;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\tif (ses->capabilities & CAP_DFS)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_DFS;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->RequestFileName,\n\t\t\t\t       search_name, PATH_MAX, nls_codepage,\n\t\t\t\t       remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->RequestFileName, search_name, name_len);\n\t}\n\n\tif (ses->server && ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tparams = 2 /* level */  + name_len /*includes null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = 0;\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\n\tbyte_count = params + 3 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->MaxReferralLevel = cpu_to_le16(3);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in GetDFSRefer = %d\\n\", rc);\n\t\tgoto GetDFSRefExit;\n\t}\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t/* BB Also check if enough total bytes returned? */\n\tif (rc || get_bcc(&pSMBr->hdr) < 17) {\n\t\trc = -EIO;      /* bad smb */\n\t\tgoto GetDFSRefExit;\n\t}\n\n\tcifs_dbg(FYI, \"Decoding GetDFSRefer response BCC: %d  Offset %d\\n\",\n\t\t get_bcc(&pSMBr->hdr), le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t/* parse returned result into more usable form */\n\trc = parse_DFS_referrals(pSMBr, num_of_nodes,\n\t\t\t\t target_nodes, nls_codepage, remap,\n\t\t\t\t search_name);\n\nGetDFSRefExit:\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto getDFSRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_DFS_referrals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4766-4869",
    "snippet": "static int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcifs_dbg(VFS, \"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\",\n\t\t\t *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcifs_dbg(VFS, \"Referrals of V%d version are not supported, should be V3\\n\",\n\t\t\t le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcifs_dbg(FYI, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t *num_of_nodes, le32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\n\t\t\t\tGFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUTF16((__le16 *) tmp, searchName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_utf16_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->node_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\tref++;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_dfs_info_array",
          "args": [
            "*target_nodes",
            "*num_of_nodes"
          ],
          "line": 4864
        },
        "resolved": true,
        "details": {
          "function_name": "free_dfs_info_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1387-1398",
          "snippet": "static inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "temp",
            "max_len",
            "is_unicode",
            "nls_codepage"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ref->NetworkAddressOffset"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_utf16_bytes",
          "args": [
            "tmp",
            "le16_to_cpu(pSMBr->PathConsumed)",
            "nls_codepage"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_utf16_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "40-63",
          "snippet": "int\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\tcharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) tmp",
            "searchName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4827
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "strlen(searchName)*2 + 2",
            "GFP_KERNEL"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "searchName"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->DFSFlags"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "*num_of_nodes",
            "sizeof(struct dfs_info3_param)",
            "GFP_KERNEL"
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"num_referrals: %d dfs flags: 0x%x ...\\n\"",
            "*num_of_nodes",
            "le32_to_cpu(pSMBr->DFSFlags)"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Referrals of V%d version are not supported, should be V3\\n\"",
            "le16_to_cpu(ref->VersionNumber)"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "3"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\"",
            "*num_of_nodes"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcifs_dbg(VFS, \"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\",\n\t\t\t *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcifs_dbg(VFS, \"Referrals of V%d version are not supported, should be V3\\n\",\n\t\t\t le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcifs_dbg(FYI, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t *num_of_nodes, le32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\n\t\t\t\tGFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUTF16((__le16 *) tmp, searchName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_utf16_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->node_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\tref++;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSGetSrvInodeNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4667-4758",
    "snippet": "int\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *search_name, __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetSrvInodeNum for %s\\n\", search_name);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in QueryInternalInfo\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in QryIntrnlInf\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4754
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "pfinfo->UniqueId"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Illegal size ret in QryIntrnlInf\\n\""
          ],
          "line": 4744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataCount"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4734
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4732
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"error %d in QueryInternalInfo\\n\"",
            "rc"
          ],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_INTERNAL_INFO"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "search_name",
            "name_len"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "search_name",
            "PATH_MAX"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "search_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In GetSrvInodeNum for %s\\n\"",
            "search_name"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *search_name, __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetSrvInodeNum for %s\\n\", search_name);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in QueryInternalInfo\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in QryIntrnlInf\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSFindClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4635-4665",
    "snippet": "int\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcifs_dbg(FYI, \"In CIFSSMBFindClose\\n\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in FindClose = %d\\n\", rc);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_fclose"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in FindClose = %d\\n\"",
            "rc"
          ],
          "line": 4656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_FIND_CLOSE2",
            "1",
            "tcon",
            "(void **)&pSMB"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBFindClose\\n\""
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcifs_dbg(FYI, \"In CIFSSMBFindClose\\n\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in FindClose = %d\\n\", rc);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSFindNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4500-4633",
    "snippet": "int CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, __u16 search_flags,\n\t\t struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In FindNext\\n\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcifs_dbg(FYI, \"FindNext returned = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cifs_dbg(FYI, \"fnxt2 entries in buf %d index_of_last %d\\n\",\n    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ignoring corrupt resume name\\n\""
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "parms->LastNameOffset"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "psrch_inf->ntwrk_buf_start"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"FindNext returned = %d\\n\"",
            "rc"
          ],
          "line": 4574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_fnext"
          ],
          "line": 4567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pSMB->ResumeFileName",
            "psrch_inf->presume_name",
            "name_len"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "search_flags"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "psrch_inf->info_level"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize / sizeof(FILE_UNIX_INFO)"
          ],
          "line": 4542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_FIND_NEXT"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize & 0xFFFFFF00"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In FindNext\\n\""
          ],
          "line": 4513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, __u16 search_flags,\n\t\t struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In FindNext\\n\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcifs_dbg(FYI, \"FindNext returned = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cifs_dbg(FYI, \"fnxt2 entries in buf %d index_of_last %d\\n\",\n    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSFindFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4345-4498",
    "snippet": "int\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ignoring corrupt resume name\\n\""
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "parms->LastNameOffset"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in FindFirst = %d\\n\"",
            "rc"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_ffirst"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4437
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4434
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "psrch_inf->info_level"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "search_flags"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize/sizeof(FILE_UNIX_INFO)"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_FIND_FIRST"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize & 0xFFFFFF00"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "10"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_DIR_SEP",
          "args": [
            "cifs_sb"
          ],
          "line": 4398
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_DIR_SEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1177-1183",
          "snippet": "static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "searchName",
            "name_len"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "searchName",
            "PATH_MAX"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "searchName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In FindFirst for %s\\n\"",
            "searchName"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBUnixQPathInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4261-4342",
    "snippet": "int\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QPathInfo (Unix) the path %s\\n\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) pFindData",
            "(char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset",
            "sizeof(FILE_UNIX_BASIC_INFO)"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\""
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in UnixQPathInfo = %d\"",
            "rc"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_UNIX_BASIC"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "searchName",
            "name_len"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "searchName",
            "PATH_MAX"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "searchName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4284
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QPathInfo (Unix) the path %s\\n\"",
            "searchName"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QPathInfo (Unix) the path %s\\n\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBUnixQFileInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4193-4259",
    "snippet": "int\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) pFindData",
            "(char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset",
            "sizeof(FILE_UNIX_BASIC_INFO)"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\""
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4242
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in UnixQFileInfo = %d\"",
            "rc"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4232
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_UNIX_BASIC"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FILE_INFORMATION"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQPathInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4092-4191",
    "snippet": "int\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) data",
            "(char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset",
            "size"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 4169
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4158
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QPathInfo = %d\\n\"",
            "rc"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_ALL_INFO"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_INFO_STANDARD"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "search_name",
            "name_len"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "search_name",
            "PATH_MAX"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "search_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4108
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQFileInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "4024-4090",
    "snippet": "int\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) pFindData",
            "(char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset",
            "sizeof(FILE_ALL_INFO)"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QFileInfo = %d\"",
            "rc"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_ALL_INFO"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FILE_INFORMATION"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SMBQueryInformation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3956-4022",
    "snippet": "int\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le16_to_cpu(pSMBr->attr)"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->attr"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "le32_to_cpu(pSMBr->size)"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->size"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cifs_UnixTimeToNT(ts)"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_UnixTimeToNT",
          "args": [
            "ts"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_UnixTimeToNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "951-956",
          "snippet": "u64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\n#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)\n\nu64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "sizeof(FILE_ALL_INFO)"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QueryInfo = %d\\n\"",
            "rc"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "(__u16)name_len"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "search_name",
            "name_len"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "search_name",
            "PATH_MAX"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "search_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 3976
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_QUERY_INFORMATION",
            "0",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SMBQPath path %s\\n\"",
            "search_name"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetCIFSACL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3890-3950",
    "snippet": "int\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tvoid *pSMBr;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(aclflag);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset, pntsd, acllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcifs_dbg(FYI, \"SetCIFSACL bytes_returned: %d, rc: %d\\n\",\n\t\t bytes_returned, rc);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set CIFS ACL returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set CIFS ACL returned %d\\n\"",
            "rc"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetCIFSACL bytes_returned: %d, rc: %d\\n\"",
            "bytes_returned",
            "rc"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset",
            "pntsd",
            "acllen"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "aclflag"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count+data_count"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NT_TRANSACT_SET_SECURITY_DESC"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "data_offset"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "param_offset"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "param_count"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "16384"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "4"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "data_count"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_TRANSACT",
            "19",
            "tcon",
            "(void **) &pSMB",
            "&pSMBr"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tvoid *pSMBr;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(aclflag);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset, pntsd, acllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcifs_dbg(FYI, \"SetCIFSACL bytes_returned: %d, rc: %d\\n\",\n\t\t bytes_returned, rc);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set CIFS ACL returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "CIFSSMBGetCIFSACL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3801-3888",
    "snippet": "int\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "buf_type",
            "iov[0].iov_base"
          ],
          "line": 3885
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "pdata",
            "*pbuflen",
            "GFP_KERNEL"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad acl length %d\\n\"",
            "*pbuflen"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"acl length %d does not match %d\\n\"",
            "acl_len",
            "*pbuflen"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*parm"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"smb %p parm %p data %p\\n\"",
            "pSMBr",
            "parm",
            "*acl_inf"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_ntransact",
          "args": [
            "iov[0].iov_base",
            "(char **)&parm",
            "&pdata",
            "&parm_len",
            "pbuflen"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "validate_ntransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3747-3798",
          "snippet": "static int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parms start after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parm end after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data starts after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data %p + count %d (%p) past smb end %p start %p\\n\",\n\t\t\t *ppdata, data_count, (data_count + *ppdata),\n\t\t\t end_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcifs_dbg(FYI, \"parm count and data count larger than SMB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parms start after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parm end after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data starts after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data %p + count %d (%p) past smb end %p start %p\\n\",\n\t\t\t *ppdata, data_count, (data_count + *ppdata),\n\t\t\t end_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcifs_dbg(FYI, \"parm count and data count larger than SMB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QuerySecDesc = %d\\n\"",
            "rc"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_acl_get"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "1/* num iovec */",
            "&buf_type",
            "0"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "11"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "11"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "4"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init_nttransact",
          "args": [
            "NT_TRANSACT_QUERY_SECURITY_DESC",
            "0",
            "8/* parm len */",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"GetCifsACL\\n\""
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}"
  },
  {
    "function_name": "validate_ntransact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3747-3798",
    "snippet": "static int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parms start after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parm end after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data starts after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data %p + count %d (%p) past smb end %p start %p\\n\",\n\t\t\t *ppdata, data_count, (data_count + *ppdata),\n\t\t\t end_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcifs_dbg(FYI, \"parm count and data count larger than SMB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"parm count and data count larger than SMB\\n\""
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"data %p + count %d (%p) past smb end %p start %p\\n\"",
            "*ppdata",
            "data_count",
            "(data_count + *ppdata)",
            "end_of_smb",
            "pSMBr"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"data starts after end of smb\\n\""
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"parm end after end of smb\\n\""
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"parms start after end of smb\\n\""
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->ParameterCount"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parms start after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parm end after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data starts after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data %p + count %d (%p) past smb end %p start %p\\n\",\n\t\t\t *ppdata, data_count, (data_count + *ppdata),\n\t\t\t end_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcifs_dbg(FYI, \"parm count and data count larger than SMB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}"
  },
  {
    "function_name": "smb_init_nttransact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3718-3745",
    "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sub_command"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "temp_offset + parm_len"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "temp_offset"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CIFSMaxBufSize & 0xFFFFFF00"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "parm_len"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_NT_TRANSACT",
            "19 + setup_count",
            "tcon",
            "(void **)&pSMB"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
  },
  {
    "function_name": "CIFSGetExtAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3626-3705",
    "snippet": "int\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetExtAttr\\n\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in GetExtAttr\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in GetExtAttr\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "pfinfo->mask"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Illegal size ret in GetExtAttr\\n\""
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataCount"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 3678
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"error %d in GetExtAttr\\n\"",
            "rc"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_ATTR_FLAGS"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FILE_INFORMATION"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In GetExtAttr\\n\""
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetExtAttr\\n\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in GetExtAttr\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in GetExtAttr\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBSetPosixACL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3546-3623",
    "snippet": "int\nCIFSSMBSetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *fileName,\n\t\t   const char *local_acl, const int buflen,\n\t\t   const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tchar *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetPosixACL (Unix) for path %s\\n\", fileName);\nsetAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB size from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tparm_data = ((char *) &pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\n\t/* convert to on the wire format for POSIX ACL */\n\tdata_count = ACL_to_cifs_posix(parm_data, local_acl, buflen, acl_type);\n\n\tif (data_count == 0) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto setACLerrorExit;\n\t}\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set POSIX ACL returned %d\\n\", rc);\n\nsetACLerrorExit:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setAclRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set POSIX ACL returned %d\\n\"",
            "rc"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "data_count"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_POSIX_ACL"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACL_to_cifs_posix",
          "args": [
            "parm_data",
            "local_acl",
            "buflen",
            "acl_type"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "ACL_to_cifs_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3410-3455",
          "snippet": "static __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcifs_dbg(FYI, \"setting acl with %d entries from buf of length %d and version of %d\\n\",\n\t\t count, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcifs_dbg(FYI, \"unknown POSIX ACL version %d\\n\",\n\t\t\t le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->default_entry_count = cpu_to_le16(0xFFFF);\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->access_entry_count = cpu_to_le16(0xFFFF);\n\t} else {\n\t\tcifs_dbg(FYI, \"unknown ACL type %d\\n\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcifs_dbg(FYI, \"setting acl with %d entries from buf of length %d and version of %d\\n\",\n\t\t count, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcifs_dbg(FYI, \"unknown POSIX ACL version %d\\n\",\n\t\t\t le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->default_entry_count = cpu_to_le16(0xFFFF);\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->access_entry_count = cpu_to_le16(0xFFFF);\n\t} else {\n\t\tcifs_dbg(FYI, \"unknown ACL type %d\\n\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "fileName",
            "name_len"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "fileName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SetPosixACL (Unix) for path %s\\n\"",
            "fileName"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *fileName,\n\t\t   const char *local_acl, const int buflen,\n\t\t   const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tchar *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetPosixACL (Unix) for path %s\\n\", fileName);\nsetAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB size from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tparm_data = ((char *) &pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\n\t/* convert to on the wire format for POSIX ACL */\n\tdata_count = ACL_to_cifs_posix(parm_data, local_acl, buflen, acl_type);\n\n\tif (data_count == 0) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto setACLerrorExit;\n\t}\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set POSIX ACL returned %d\\n\", rc);\n\nsetACLerrorExit:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setAclRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBGetPosixACL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3457-3544",
    "snippet": "int\nCIFSSMBGetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *searchName,\n\t\t   char *acl_inf, const int buflen, const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_POSIX_ACL */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetPosixACL (Unix) for path %s\\n\", searchName);\n\nqueryAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   searchName, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = 0;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t\toffsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Query POSIX ACL = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\trc = cifs_copy_posix_acl(acl_inf,\n\t\t\t\t(char *)&pSMBr->hdr.Protocol+data_offset,\n\t\t\t\tbuflen, acl_type, count);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto queryAclRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_copy_posix_acl",
          "args": [
            "acl_inf",
            "(char *)&pSMBr->hdr.Protocol+data_offset",
            "buflen",
            "acl_type",
            "count"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_copy_posix_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3334-3387",
          "snippet": "static int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcifs_dbg(FYI, \"bad CIFS POSIX ACL size %d vs. %d\\n\",\n\t\t\t\t size_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcifs_dbg(FYI, \"bad CIFS POSIX ACL size %d vs. %d\\n\",\n\t\t\t\t size_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataCount"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Query POSIX ACL = %d\\n\"",
            "rc"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_acl_get"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_POSIX_ACL"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4000"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "searchName",
            "name_len"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "searchName",
            "PATH_MAX"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "searchName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In GetPosixACL (Unix) for path %s\\n\"",
            "searchName"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBGetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *searchName,\n\t\t   char *acl_inf, const int buflen, const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_POSIX_ACL */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetPosixACL (Unix) for path %s\\n\", searchName);\n\nqueryAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   searchName, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = 0;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t\toffsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Query POSIX ACL = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\trc = cifs_copy_posix_acl(acl_inf,\n\t\t\t\t(char *)&pSMBr->hdr.Protocol+data_offset,\n\t\t\t\tbuflen, acl_type, count);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto queryAclRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "ACL_to_cifs_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3410-3455",
    "snippet": "static __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcifs_dbg(FYI, \"setting acl with %d entries from buf of length %d and version of %d\\n\",\n\t\t count, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcifs_dbg(FYI, \"unknown POSIX ACL version %d\\n\",\n\t\t\t le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->default_entry_count = cpu_to_le16(0xFFFF);\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->access_entry_count = cpu_to_le16(0xFFFF);\n\t} else {\n\t\tcifs_dbg(FYI, \"unknown ACL type %d\\n\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "count * sizeof(struct cifs_posix_ace)"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_ace_to_cifs_ace",
          "args": [
            "&cifs_acl->ace_array[i]",
            "&local_acl->a_entries[i]"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "convert_ace_to_cifs_ace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3389-3407",
          "snippet": "static __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unknown ACL type %d\\n\"",
            "acl_type"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xFFFF"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xFFFF"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unknown POSIX ACL version %d\\n\"",
            "le32_to_cpu(local_acl->a_version)"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "local_acl->a_version"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"setting acl with %d entries from buf of length %d and version of %d\\n\"",
            "count",
            "buflen",
            "le32_to_cpu(local_acl->a_version)"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_count",
          "args": [
            "(size_t)buflen"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcifs_dbg(FYI, \"setting acl with %d entries from buf of length %d and version of %d\\n\",\n\t\t count, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcifs_dbg(FYI, \"unknown POSIX ACL version %d\\n\",\n\t\t\t le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->default_entry_count = cpu_to_le16(0xFFFF);\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->access_entry_count = cpu_to_le16(0xFFFF);\n\t} else {\n\t\tcifs_dbg(FYI, \"unknown ACL type %d\\n\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "convert_ace_to_cifs_ace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3389-3407",
    "snippet": "static __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "le32_to_cpu(local_ace->e_id)"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "local_ace->e_id"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "-1"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "local_ace->e_tag"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_copy_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3334-3387",
    "snippet": "static int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcifs_dbg(FYI, \"bad CIFS POSIX ACL size %d vs. %d\\n\",\n\t\t\t\t size_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_convert_ace",
          "args": [
            "&local_acl->a_entries[i]",
            "pACE"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_ace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3318-3331",
          "snippet": "static void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POSIX_ACL_XATTR_VERSION"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "count"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cifs_acl->default_entry_count"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"bad CIFS POSIX ACL size %d vs. %d\\n\"",
            "size_of_data_area",
            "size"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcifs_dbg(FYI, \"bad CIFS POSIX ACL size %d vs. %d\\n\",\n\t\t\t\t size_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}"
  },
  {
    "function_name": "cifs_convert_ace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3318-3331",
    "snippet": "static void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\n\treturn;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le64_to_cpu(cifs_ace->cifs_uid)"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "cifs_ace->cifs_uid"
          ],
          "line": 3324
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cifs_ace->cifs_e_tag"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cifs_ace->cifs_e_perm"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n/*\n\tcifs_dbg(FYI, \"perm %d tag %d id %d\\n\",\n\t\t ace->e_perm, ace->e_tag, ace->e_id);\n*/\n\n\treturn;\n}"
  },
  {
    "function_name": "CIFSSMB_set_compression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3261-3312",
    "snippet": "int\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_compr_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcifs_dbg(FYI, \"Set compression for %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\tpSMB->TotalParameterCount = 0;\n\tpSMB->TotalDataCount = cpu_to_le32(2);\n\tpSMB->MaxParameterCount = 0;\n\tpSMB->MaxDataCount = 0;\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = cpu_to_le32(2);\n\tpSMB->DataOffset =\n\t\tcpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4);  /* 84 */\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = 0;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_SET_COMPRESSION);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\t/* 3 byte pad, followed by 2 byte compress state */\n\tpSMB->ByteCount = cpu_to_le16(5);\n\tinc_rfc1001_len(pSMB, 5);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetCompression = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3305
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in SetCompression = %d\\n\"",
            "rc"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "5"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "5"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FSCTL_SET_COMPRESSION"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NT_TRANSACT_IOCTL"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "COMPRESSION_FORMAT_DEFAULT"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_TRANSACT",
            "23",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set compression for %u\\n\"",
            "fid"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_compr_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcifs_dbg(FYI, \"Set compression for %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\tpSMB->TotalParameterCount = 0;\n\tpSMB->TotalDataCount = cpu_to_le32(2);\n\tpSMB->MaxParameterCount = 0;\n\tpSMB->MaxDataCount = 0;\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = cpu_to_le32(2);\n\tpSMB->DataOffset =\n\t\tcpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4);  /* 84 */\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = 0;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_SET_COMPRESSION);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\t/* 3 byte pad, followed by 2 byte compress state */\n\tpSMB->ByteCount = cpu_to_le16(5);\n\tinc_rfc1001_len(pSMB, 5);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetCompression = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBQuerySymLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3138-3259",
    "snippet": "int\nCIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid, char **symlinkinfo,\n\t\t    const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\tbool is_unicode;\n\tunsigned int sub_len;\n\tchar *sub_start;\n\tstruct reparse_symlink_data *reparse_buf;\n\tstruct reparse_posix_data *posix_buf;\n\t__u32 data_offset, data_count;\n\tchar *end_of_smb;\n\n\tcifs_dbg(FYI, \"In Windows reparse style QueryLink for fid %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryReparseLinkInfo = %d\\n\", rc);\n\t\tgoto qreparse_out;\n\t}\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t/* BB also check enough total bytes returned */\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto qreparse_out;\n\t}\n\tif (!data_count || (data_count > 2048)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Invalid return data count on get reparse info ioctl\\n\");\n\t\tgoto qreparse_out;\n\t}\n\tend_of_smb = 2 + get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\treparse_buf = (struct reparse_symlink_data *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\tif ((char *)reparse_buf >= end_of_smb) {\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (reparse_buf->ReparseTag == cpu_to_le32(IO_REPARSE_TAG_NFS)) {\n\t\tcifs_dbg(FYI, \"NFS style reparse tag\\n\");\n\t\tposix_buf =  (struct reparse_posix_data *)reparse_buf;\n\n\t\tif (posix_buf->InodeType != cpu_to_le64(NFS_SPECFILE_LNK)) {\n\t\t\tcifs_dbg(FYI, \"unsupported file type 0x%llx\\n\",\n\t\t\t\t le64_to_cpu(posix_buf->InodeType));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tis_unicode = true;\n\t\tsub_len = le16_to_cpu(reparse_buf->ReparseDataLength);\n\t\tif (posix_buf->PathBuffer + sub_len > end_of_smb) {\n\t\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\t*symlinkinfo = cifs_strndup_from_utf16(posix_buf->PathBuffer,\n\t\t\t\tsub_len, is_unicode, nls_codepage);\n\t\tgoto qreparse_out;\n\t} else if (reparse_buf->ReparseTag !=\n\t\t\tcpu_to_le32(IO_REPARSE_TAG_SYMLINK)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto qreparse_out;\n\t}\n\n\t/* Reparse tag is NTFS symlink */\n\tsub_start = le16_to_cpu(reparse_buf->SubstituteNameOffset) +\n\t\t\t\treparse_buf->PathBuffer;\n\tsub_len = le16_to_cpu(reparse_buf->SubstituteNameLength);\n\tif (sub_start + sub_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\n\t/* BB FIXME investigate remapping reserved chars here */\n\t*symlinkinfo = cifs_strndup_from_utf16(sub_start, sub_len, is_unicode,\n\t\t\t\t\t       nls_codepage);\n\tif (!*symlinkinfo)\n\t\trc = -ENOMEM;\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "sub_start",
            "sub_len",
            "is_unicode",
            "nls_codepage"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"reparse buf beyond SMB\\n\""
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "reparse_buf->SubstituteNameLength"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "IO_REPARSE_TAG_SYMLINK"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"reparse buf beyond SMB\\n\""
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unsupported file type 0x%llx\\n\"",
            "le64_to_cpu(posix_buf->InodeType)"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "posix_buf->InodeType"
          ],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "NFS_SPECFILE_LNK"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"NFS style reparse tag\\n\""
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "IO_REPARSE_TAG_NFS"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Invalid return data count on get reparse info ioctl\\n\""
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->DataCount"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QueryReparseLinkInfo = %d\\n\"",
            "rc"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FSCTL_GET_REPARSE_POINT"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NT_TRANSACT_IOCTL"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CIFSMaxBufSize & 0xFFFFFF00"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_TRANSACT",
            "23",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In Windows reparse style QueryLink for fid %u\\n\"",
            "fid"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid, char **symlinkinfo,\n\t\t    const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\tbool is_unicode;\n\tunsigned int sub_len;\n\tchar *sub_start;\n\tstruct reparse_symlink_data *reparse_buf;\n\tstruct reparse_posix_data *posix_buf;\n\t__u32 data_offset, data_count;\n\tchar *end_of_smb;\n\n\tcifs_dbg(FYI, \"In Windows reparse style QueryLink for fid %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryReparseLinkInfo = %d\\n\", rc);\n\t\tgoto qreparse_out;\n\t}\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t/* BB also check enough total bytes returned */\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto qreparse_out;\n\t}\n\tif (!data_count || (data_count > 2048)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Invalid return data count on get reparse info ioctl\\n\");\n\t\tgoto qreparse_out;\n\t}\n\tend_of_smb = 2 + get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\treparse_buf = (struct reparse_symlink_data *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\tif ((char *)reparse_buf >= end_of_smb) {\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (reparse_buf->ReparseTag == cpu_to_le32(IO_REPARSE_TAG_NFS)) {\n\t\tcifs_dbg(FYI, \"NFS style reparse tag\\n\");\n\t\tposix_buf =  (struct reparse_posix_data *)reparse_buf;\n\n\t\tif (posix_buf->InodeType != cpu_to_le64(NFS_SPECFILE_LNK)) {\n\t\t\tcifs_dbg(FYI, \"unsupported file type 0x%llx\\n\",\n\t\t\t\t le64_to_cpu(posix_buf->InodeType));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tis_unicode = true;\n\t\tsub_len = le16_to_cpu(reparse_buf->ReparseDataLength);\n\t\tif (posix_buf->PathBuffer + sub_len > end_of_smb) {\n\t\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\t*symlinkinfo = cifs_strndup_from_utf16(posix_buf->PathBuffer,\n\t\t\t\tsub_len, is_unicode, nls_codepage);\n\t\tgoto qreparse_out;\n\t} else if (reparse_buf->ReparseTag !=\n\t\t\tcpu_to_le32(IO_REPARSE_TAG_SYMLINK)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto qreparse_out;\n\t}\n\n\t/* Reparse tag is NTFS symlink */\n\tsub_start = le16_to_cpu(reparse_buf->SubstituteNameOffset) +\n\t\t\t\treparse_buf->PathBuffer;\n\tsub_len = le16_to_cpu(reparse_buf->SubstituteNameLength);\n\tif (sub_start + sub_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\n\t/* BB FIXME investigate remapping reserved chars here */\n\t*symlinkinfo = cifs_strndup_from_utf16(sub_start, sub_len, is_unicode,\n\t\t\t\t\t       nls_codepage);\n\tif (!*symlinkinfo)\n\t\trc = -ENOMEM;\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBUnixQuerySymLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "3034-3126",
    "snippet": "int\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcifs_dbg(FYI, \"In QPathSymLinkInfo (Unix) for path %s\\n\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifs_strtoUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySymLinkInfo = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_utf16(data_start,\n\t\t\t\t\tcount, is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "data_start",
            "count",
            "is_unicode",
            "nls_codepage"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataOffset"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in QuerySymLinkInfo = %d\\n\"",
            "rc"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_UNIX_LINK"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_PATH_INFORMATION"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFSMaxBufSize"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "searchName",
            "name_len"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "searchName",
            "PATH_MAX"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "searchName",
            "PATH_MAX",
            "nls_codepage"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In QPathSymLinkInfo (Unix) for path %s\\n\"",
            "searchName"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcifs_dbg(FYI, \"In QPathSymLinkInfo (Unix) for path %s\\n\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifs_strtoUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySymLinkInfo = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_utf16(data_start,\n\t\t\t\t\tcount, is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSCreateHardLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2960-3032",
    "snippet": "int\nCIFSCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tNT_RENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSCreateHardLink\\n\");\nwinCreateHardLinkRetry:\n\n\trc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\n\tpSMB->ClusterCount = 0;\n\n\tpSMB->BufferFormat = 0x04;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->OldFileName, from_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t\t/* protocol specifies ASCII buffer format (0x04) for unicode */\n\t\tpSMB->OldFileName[name_len] = 0x04;\n\t\tpSMB->OldFileName[name_len + 1] = 0x00; /* pad */\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(from_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, from_name, name_len);\n\t\tname_len2 = strnlen(to_name, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* string type byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in hard link (NT rename) = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto winCreateHardLinkRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in hard link (NT rename) = %d\\n\"",
            "rc"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_hardlinks"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "&pSMB->OldFileName[name_len + 1]",
            "to_name",
            "name_len2"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "to_name",
            "PATH_MAX"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->OldFileName",
            "from_name",
            "name_len"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "from_name",
            "PATH_MAX"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *)&pSMB->OldFileName[name_len+2]",
            "to_name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CREATE_HARD_LINK"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_RENAME",
            "4",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSCreateHardLink\\n\""
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tNT_RENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSCreateHardLink\\n\");\nwinCreateHardLinkRetry:\n\n\trc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\n\tpSMB->ClusterCount = 0;\n\n\tpSMB->BufferFormat = 0x04;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->OldFileName, from_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t\t/* protocol specifies ASCII buffer format (0x04) for unicode */\n\t\tpSMB->OldFileName[name_len] = 0x04;\n\t\tpSMB->OldFileName[name_len + 1] = 0x00; /* pad */\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(from_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, from_name, name_len);\n\t\tname_len2 = strnlen(to_name, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* string type byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in hard link (NT rename) = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto winCreateHardLinkRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSUnixCreateHardLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2874-2958",
    "snippet": "int\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Create Hard link Unix style\\n\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, fromName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo (hard link) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in SetPathInfo (hard link) = %d\\n\"",
            "rc"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_hardlinks"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_UNIX_HLINK"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len_target"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "data_offset",
            "fromName",
            "name_len_target"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fromName",
            "PATH_MAX"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) data_offset",
            "fromName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "toName",
            "name_len"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "toName",
            "PATH_MAX"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In Create Hard link Unix style\\n\""
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Create Hard link Unix style\\n\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, fromName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo (hard link) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSUnixCreateSymLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2784-2872",
    "snippet": "int\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Symlink Unix style\\n\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUTF16((__le16 *) pSMB->FileName, fromName,\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUTF16((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo create symlink = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in SetPathInfo create symlink = %d\\n\"",
            "rc"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_symlinks"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_UNIX_LINK"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len_target"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "data_offset",
            "toName",
            "name_len_target"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "toName",
            "PATH_MAX"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *) data_offset",
            "toName",
            "PATH_MAX/* find define for this maxpathcomponent */",
            "nls_codepage"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "fromName",
            "name_len"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fromName",
            "PATH_MAX"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In Symlink Unix style\\n\""
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Symlink Unix style\\n\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUTF16((__le16 *) pSMB->FileName, fromName,\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUTF16((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo create symlink = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2716-2782",
    "snippet": "int\nCIFSSMBCopy(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fromName, const __u16 target_tid, const char *toName,\n\t    const int flags, const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCOPY_REQ *pSMB = NULL;\n\tCOPY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"In CIFSSMBCopy\\n\");\ncopyRetry:\n\trc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->Tid2 = target_tid;\n\n\tpSMB->Flags = cpu_to_le16(flags & COPY_TREE);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      fromName, PATH_MAX, nls_codepage,\n\t\t\t\t\t      remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;     /* pad */\n\t\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2; /* convert to bytes */\n\t} else { \t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;    /* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;    /* trailing null */\n\t\tname_len2++;    /* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in copy = %d with %d files copied\\n\",\n\t\t\t rc, le16_to_cpu(pSMBr->CopyCount));\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto copyRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in copy = %d with %d files copied\\n\"",
            "rc",
            "le16_to_cpu(pSMBr->CopyCount)"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->CopyCount"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "&pSMB->OldFileName[name_len + 1]",
            "toName",
            "name_len2"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "toName",
            "PATH_MAX"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->OldFileName",
            "fromName",
            "name_len"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fromName",
            "PATH_MAX"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *)&pSMB->OldFileName[name_len+2]",
            "toName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "flags & COPY_TREE"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_COPY",
            "1",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBCopy\\n\""
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBCopy(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fromName, const __u16 target_tid, const char *toName,\n\t    const int flags, const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCOPY_REQ *pSMB = NULL;\n\tCOPY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"In CIFSSMBCopy\\n\");\ncopyRetry:\n\trc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->Tid2 = target_tid;\n\n\tpSMB->Flags = cpu_to_le16(flags & COPY_TREE);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      fromName, PATH_MAX, nls_codepage,\n\t\t\t\t\t      remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;     /* pad */\n\t\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2; /* convert to bytes */\n\t} else { \t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;    /* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;    /* trailing null */\n\t\tname_len2++;    /* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in copy = %d with %d files copied\\n\",\n\t\t\t rc, le16_to_cpu(pSMBr->CopyCount));\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto copyRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBRenameOpenFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2634-2714",
    "snippet": "int CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"Rename to File by handle\\n\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Rename (by file handle) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Rename (by file handle) = %d\\n\"",
            "rc"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&pTcon->stats.cifs_stats.num_t2renames"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "pTcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_FILE_RENAME_INFORMATION"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2 * len_of_str"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *)rename_info->target_name",
            "target_name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dummy_string",
            "\"cifs%x\"",
            "pSMB->hdr.Mid"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "pTcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Rename to File by handle\\n\""
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"Rename to File by handle\\n\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Rename (by file handle) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBRename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2564-2632",
    "snippet": "int\nCIFSSMBRename(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *from_name, const char *to_name,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tRENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRename\\n\");\nrenameRetry:\n\trc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      from_name, PATH_MAX,\n\t\t\t\t\t      cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* pad */\n\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(from_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, from_name, name_len);\n\t\tname_len2 = strnlen(to_name, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in rename = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto renameRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in rename = %d\\n\"",
            "rc"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_renames"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "&pSMB->OldFileName[name_len + 1]",
            "to_name",
            "name_len2"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "to_name",
            "PATH_MAX"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->OldFileName",
            "from_name",
            "name_len"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "from_name",
            "PATH_MAX"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *)&pSMB->OldFileName[name_len+2]",
            "to_name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_RENAME",
            "1",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBRename\\n\""
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBRename(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *from_name, const char *to_name,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tRENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRename\\n\");\nrenameRetry:\n\trc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      from_name, PATH_MAX,\n\t\t\t\t\t      cifs_sb->local_nls, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* pad */\n\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(from_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, from_name, name_len);\n\t\tname_len2 = strnlen(to_name, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in rename = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto renameRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBFlush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2543-2562",
    "snippet": "int\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBFlush\\n\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in Flush = %d\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in Flush = %d\\n\"",
            "rc"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_flushes"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_FLUSH",
            "1",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBFlush\\n\""
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBFlush\\n\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in Flush = %d\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2510-2541",
    "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in Close = %d\\n\"",
            "rc"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_closes"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_CLOSE",
            "3",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBClose\\n\""
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBPosixLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2377-2507",
    "snippet": "int\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buf_type",
            "iov[0].iov_base"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "parm_data->pid"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "parm_data->length"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_WRLCK"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_RDLCK"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_UNLCK"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->t2.DataCount"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Posix Lock = %d\\n\"",
            "rc"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "1/* num iovecs */",
            "&resp_buf_type",
            "timeout"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveBlockingLock",
          "args": [
            "xid",
            "tcon",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveBlockingLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "969-1113",
          "snippet": "int\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_SET_POSIX_LOCK"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "len"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_offset"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "netpid"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "lock_type"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_FILE_INFORMATION"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_QUERY_FILE_INFORMATION"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Posix Lock\\n\""
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2306-2375",
    "snippet": "int\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in Lock = %d\\n\"",
            "rc"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_locks"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *)pSMB",
            "flags"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendReceiveBlockingLock",
          "args": [
            "xid",
            "tcon",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMB",
            "&bytes_returned"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveBlockingLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "969-1113",
          "snippet": "int\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(offset>>32)"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "offset>>32"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)offset"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(len>>32)"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "len>>32"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)len"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "netpid"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "numUnlock"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "numLock"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_LOCKING_ANDX",
            "8",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"CIFSSMBLock timeout %d numLock %d\\n\"",
            "(int)waitFlag",
            "numLock"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_lockv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2264-2304",
    "snippet": "int cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in cifs_lockv = %d\\n\"",
            "rc"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "2",
            "&resp_buf_type",
            "CIFS_NO_RESP"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_locks"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_unlock"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_lock"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_LOCKING_ANDX",
            "8",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_lockv num lock %d num unlock %d\\n\"",
            "num_lock",
            "num_unlock"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBWrite2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2160-2262",
    "snippet": "int\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcifs_dbg(FYI, \"write2 at %lld %d bytes\\n\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error Write2 = %d\\n\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buf_type",
            "iov[0].iov_base"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->Count"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error Write2 = %d\\n\"",
            "rc"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_writes"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "n_vec + 1",
            "&resp_buf_type",
            "0"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count + 5"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count + 1"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count + 5"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count >> 16"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count & 0xFFFF"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_write_req, Data) - 4"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset >> 32"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset & 0xFFFFFFFF"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid >> 16)"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid >> 16"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_WRITE_ANDX",
            "wct",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"write2 at %lld %d bytes\\n\"",
            "(long long)offset",
            "count"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcifs_dbg(FYI, \"write2 at %lld %d bytes\\n\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error Write2 = %d\\n\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_async_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2077-2158",
    "snippet": "int\ncifs_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { };\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif (wdata->offset >> 32 > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\tgoto async_writev_out;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)wdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = wdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\n\tsmb->Reserved = 0xFFFFFFFF;\n\tsmb->WriteMode = 0;\n\tsmb->Remaining = 0;\n\n\tsmb->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4 + 1;\n\tiov.iov_base = smb;\n\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\tsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\n\tsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\n\n\tif (wct == 14) {\n\t\tinc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\n\t\tput_bcc(wdata->bytes + 1, &smb->hdr);\n\t} else {\n\t\t/* wct == 12 */\n\t\tstruct smb_com_writex_req *smbw =\n\t\t\t\t(struct smb_com_writex_req *)smb;\n\t\tinc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\n\t\tput_bcc(wdata->bytes + 5, &smbw->hdr);\n\t\tiov.iov_len += 4; /* pad bigger by four bytes */\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, NULL,\n\t\t\t\tcifs_writev_callback, wdata, 0);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\telse\n\t\tkref_put(&wdata->refcount, release);\n\nasync_writev_out:\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "smb"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "release"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_writes"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "tcon->ses->server",
            "&rqst",
            "NULL",
            "cifs_writev_callback",
            "wdata",
            "0"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&wdata->refcount"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bcc",
          "args": [
            "wdata->bytes + 5",
            "&smbw->hdr"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "put_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "455-461",
          "snippet": "static inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "&smbw->hdr",
            "wdata->bytes + 5"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "wdata->bytes >> 16"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "wdata->bytes & 0xFFFF"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"async write at %llu %u bytes\\n\"",
            "wdata->offset",
            "wdata->bytes"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb->hdr.smb_buf_length"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_write_req, Data) - 4"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "wdata->offset >> 32"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "wdata->offset & 0xFFFFFFFF"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(wdata->pid >> 16)"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wdata->pid >> 16"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)wdata->pid"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_WRITE_ANDX",
            "wct",
            "tcon",
            "(void **)&smb"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { };\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif (wdata->offset >> 32 > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\tgoto async_writev_out;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)wdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = wdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\n\tsmb->Reserved = 0xFFFFFFFF;\n\tsmb->WriteMode = 0;\n\tsmb->Remaining = 0;\n\n\tsmb->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4 + 1;\n\tiov.iov_base = smb;\n\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\tsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\n\tsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\n\n\tif (wct == 14) {\n\t\tinc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\n\t\tput_bcc(wdata->bytes + 1, &smb->hdr);\n\t} else {\n\t\t/* wct == 12 */\n\t\tstruct smb_com_writex_req *smbw =\n\t\t\t\t(struct smb_com_writex_req *)smb;\n\t\tinc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\n\t\tput_bcc(wdata->bytes + 5, &smbw->hdr);\n\t\tiov.iov_len += 4; /* pad bigger by four bytes */\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, NULL,\n\t\t\t\tcifs_writev_callback, wdata, 0);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\telse\n\t\tkref_put(&wdata->refcount, release);\n\nasync_writev_out:\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_writev_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2031-2074",
    "snippet": "static void\ncifs_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\twdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le16_to_cpu(smb->CountHigh);\n\t\twritten <<= 16;\n\t\twritten += le16_to_cpu(smb->Count);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(tcon->ses->server, 1, 0);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "tcon->ses->server",
            "1",
            "0"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&wdata->work"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "smb->Count"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_check_receive",
          "args": [
            "mid",
            "tcon->ses->server",
            "0"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_check_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "658-685",
          "snippet": "int\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\twdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le16_to_cpu(smb->CountHigh);\n\t\twritten <<= 16;\n\t\twritten += le16_to_cpu(smb->Count);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(tcon->ses->server, 1, 0);\n}"
  },
  {
    "function_name": "cifs_writedata_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "2010-2025",
    "snippet": "struct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&wdata->work",
            "complete"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&wdata->done"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wdata->list"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&wdata->refcount"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages",
            "GFP_NOFS"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}"
  },
  {
    "function_name": "cifs_writev_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1979-2008",
    "snippet": "void\ncifs_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tint i = 0;\n\n\tif (wdata->result == 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tcifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\n\t\t\t\t\t wdata->bytes);\n\t} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\n\t\treturn cifs_writev_requeue(wdata);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tstruct page *page = wdata->pages[i];\n\t\tif (wdata->result == -EAGAIN)\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\telse if (wdata->result < 0)\n\t\t\tSetPageError(page);\n\t\tend_page_writeback(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (wdata->result != -EAGAIN)\n\t\tmapping_set_error(inode->i_mapping, wdata->result);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_writedata_release"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "wdata->result"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_writev_requeue",
          "args": [
            "wdata"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writev_requeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1897-1977",
          "snippet": "static void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc = 0;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct TCP_Server_Info *server;\n\tunsigned int rest_len;\n\n\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\ti = 0;\n\trest_len = wdata->bytes;\n\tdo {\n\t\tstruct cifs_writedata *wdata2;\n\t\tunsigned int j, nr_pages, wsize, tailsz, cur_len;\n\n\t\twsize = server->ops->wp_retry_size(inode);\n\t\tif (wsize < rest_len) {\n\t\t\tnr_pages = wsize / PAGE_CACHE_SIZE;\n\t\t\tif (!nr_pages) {\n\t\t\t\trc = -ENOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_len = nr_pages * PAGE_CACHE_SIZE;\n\t\t\ttailsz = PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\tnr_pages = DIV_ROUND_UP(rest_len, PAGE_CACHE_SIZE);\n\t\t\tcur_len = rest_len;\n\t\t\ttailsz = rest_len - (nr_pages - 1) * PAGE_CACHE_SIZE;\n\t\t}\n\n\t\twdata2 = cifs_writedata_alloc(nr_pages, cifs_writev_complete);\n\t\tif (!wdata2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\twdata2->pages[j] = wdata->pages[i + j];\n\t\t\tlock_page(wdata2->pages[j]);\n\t\t\tclear_page_dirty_for_io(wdata2->pages[j]);\n\t\t}\n\n\t\twdata2->sync_mode = wdata->sync_mode;\n\t\twdata2->nr_pages = nr_pages;\n\t\twdata2->offset = page_offset(wdata2->pages[0]);\n\t\twdata2->pagesz = PAGE_CACHE_SIZE;\n\t\twdata2->tailsz = tailsz;\n\t\twdata2->bytes = cur_len;\n\n\t\twdata2->cfile = find_writable_file(CIFS_I(inode), false);\n\t\tif (!wdata2->cfile) {\n\t\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\t\trc = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\twdata2->pid = wdata2->cfile->pid;\n\t\trc = server->ops->async_writev(wdata2, cifs_writedata_release);\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\tunlock_page(wdata2->pages[j]);\n\t\t\tif (rc != 0 && rc != -EAGAIN) {\n\t\t\t\tSetPageError(wdata2->pages[j]);\n\t\t\t\tend_page_writeback(wdata2->pages[j]);\n\t\t\t\tpage_cache_release(wdata2->pages[j]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc) {\n\t\t\tkref_put(&wdata2->refcount, cifs_writedata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\trest_len -= cur_len;\n\t\ti += nr_pages;\n\t} while (i < wdata->nr_pages);\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc = 0;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct TCP_Server_Info *server;\n\tunsigned int rest_len;\n\n\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\ti = 0;\n\trest_len = wdata->bytes;\n\tdo {\n\t\tstruct cifs_writedata *wdata2;\n\t\tunsigned int j, nr_pages, wsize, tailsz, cur_len;\n\n\t\twsize = server->ops->wp_retry_size(inode);\n\t\tif (wsize < rest_len) {\n\t\t\tnr_pages = wsize / PAGE_CACHE_SIZE;\n\t\t\tif (!nr_pages) {\n\t\t\t\trc = -ENOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_len = nr_pages * PAGE_CACHE_SIZE;\n\t\t\ttailsz = PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\tnr_pages = DIV_ROUND_UP(rest_len, PAGE_CACHE_SIZE);\n\t\t\tcur_len = rest_len;\n\t\t\ttailsz = rest_len - (nr_pages - 1) * PAGE_CACHE_SIZE;\n\t\t}\n\n\t\twdata2 = cifs_writedata_alloc(nr_pages, cifs_writev_complete);\n\t\tif (!wdata2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\twdata2->pages[j] = wdata->pages[i + j];\n\t\t\tlock_page(wdata2->pages[j]);\n\t\t\tclear_page_dirty_for_io(wdata2->pages[j]);\n\t\t}\n\n\t\twdata2->sync_mode = wdata->sync_mode;\n\t\twdata2->nr_pages = nr_pages;\n\t\twdata2->offset = page_offset(wdata2->pages[0]);\n\t\twdata2->pagesz = PAGE_CACHE_SIZE;\n\t\twdata2->tailsz = tailsz;\n\t\twdata2->bytes = cur_len;\n\n\t\twdata2->cfile = find_writable_file(CIFS_I(inode), false);\n\t\tif (!wdata2->cfile) {\n\t\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\t\trc = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\twdata2->pid = wdata2->cfile->pid;\n\t\trc = server->ops->async_writev(wdata2, cifs_writedata_release);\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\tunlock_page(wdata2->pages[j]);\n\t\t\tif (rc != 0 && rc != -EAGAIN) {\n\t\t\t\tSetPageError(wdata2->pages[j]);\n\t\t\t\tend_page_writeback(wdata2->pages[j]);\n\t\t\t\tpage_cache_release(wdata2->pages[j]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc) {\n\t\t\tkref_put(&wdata2->refcount, cifs_writedata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\trest_len -= cur_len;\n\t\ti += nr_pages;\n\t} while (i < wdata->nr_pages);\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_bytes_written",
          "args": [
            "tlink_tcon(wdata->cfile->tlink)",
            "wdata->bytes"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1203-1211",
          "snippet": "static inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_update_eof",
          "args": [
            "CIFS_I(inode)",
            "wdata->offset",
            "wdata->bytes"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_update_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1624-1632",
          "snippet": "void\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifs_writedata",
            "work"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tint i = 0;\n\n\tif (wdata->result == 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tcifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\n\t\t\t\t\t wdata->bytes);\n\t} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\n\t\treturn cifs_writev_requeue(wdata);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tstruct page *page = wdata->pages[i];\n\t\tif (wdata->result == -EAGAIN)\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\telse if (wdata->result < 0)\n\t\t\tSetPageError(page);\n\t\tend_page_writeback(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (wdata->result != -EAGAIN)\n\t\tmapping_set_error(inode->i_mapping, wdata->result);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}"
  },
  {
    "function_name": "cifs_writev_requeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1897-1977",
    "snippet": "static void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc = 0;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct TCP_Server_Info *server;\n\tunsigned int rest_len;\n\n\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\ti = 0;\n\trest_len = wdata->bytes;\n\tdo {\n\t\tstruct cifs_writedata *wdata2;\n\t\tunsigned int j, nr_pages, wsize, tailsz, cur_len;\n\n\t\twsize = server->ops->wp_retry_size(inode);\n\t\tif (wsize < rest_len) {\n\t\t\tnr_pages = wsize / PAGE_CACHE_SIZE;\n\t\t\tif (!nr_pages) {\n\t\t\t\trc = -ENOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_len = nr_pages * PAGE_CACHE_SIZE;\n\t\t\ttailsz = PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\tnr_pages = DIV_ROUND_UP(rest_len, PAGE_CACHE_SIZE);\n\t\t\tcur_len = rest_len;\n\t\t\ttailsz = rest_len - (nr_pages - 1) * PAGE_CACHE_SIZE;\n\t\t}\n\n\t\twdata2 = cifs_writedata_alloc(nr_pages, cifs_writev_complete);\n\t\tif (!wdata2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\twdata2->pages[j] = wdata->pages[i + j];\n\t\t\tlock_page(wdata2->pages[j]);\n\t\t\tclear_page_dirty_for_io(wdata2->pages[j]);\n\t\t}\n\n\t\twdata2->sync_mode = wdata->sync_mode;\n\t\twdata2->nr_pages = nr_pages;\n\t\twdata2->offset = page_offset(wdata2->pages[0]);\n\t\twdata2->pagesz = PAGE_CACHE_SIZE;\n\t\twdata2->tailsz = tailsz;\n\t\twdata2->bytes = cur_len;\n\n\t\twdata2->cfile = find_writable_file(CIFS_I(inode), false);\n\t\tif (!wdata2->cfile) {\n\t\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\t\trc = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\twdata2->pid = wdata2->cfile->pid;\n\t\trc = server->ops->async_writev(wdata2, cifs_writedata_release);\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\tunlock_page(wdata2->pages[j]);\n\t\t\tif (rc != 0 && rc != -EAGAIN) {\n\t\t\t\tSetPageError(wdata2->pages[j]);\n\t\t\t\tend_page_writeback(wdata2->pages[j]);\n\t\t\t\tpage_cache_release(wdata2->pages[j]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc) {\n\t\t\tkref_put(&wdata2->refcount, cifs_writedata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\trest_len -= cur_len;\n\t\ti += nr_pages;\n\t} while (i < wdata->nr_pages);\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_writedata_release"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata2->refcount",
            "cifs_writedata_release"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "wdata2->pages[j]"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "wdata2->pages[j]"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "wdata2->pages[j]"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "wdata2->pages[j]"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->async_writev",
          "args": [
            "wdata2",
            "cifs_writedata_release"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No writable handles for inode\\n\""
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_writable_file",
          "args": [
            "CIFS_I(inode)",
            "false"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "find_writable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1753-1831",
          "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "wdata2->pages[0]"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "wdata2->pages[j]"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_writedata_alloc",
          "args": [
            "nr_pages",
            "cifs_writev_complete"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writedata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2010-2025",
          "snippet": "struct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rest_len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->wp_retry_size",
          "args": [
            "inode"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc = 0;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct TCP_Server_Info *server;\n\tunsigned int rest_len;\n\n\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\ti = 0;\n\trest_len = wdata->bytes;\n\tdo {\n\t\tstruct cifs_writedata *wdata2;\n\t\tunsigned int j, nr_pages, wsize, tailsz, cur_len;\n\n\t\twsize = server->ops->wp_retry_size(inode);\n\t\tif (wsize < rest_len) {\n\t\t\tnr_pages = wsize / PAGE_CACHE_SIZE;\n\t\t\tif (!nr_pages) {\n\t\t\t\trc = -ENOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_len = nr_pages * PAGE_CACHE_SIZE;\n\t\t\ttailsz = PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\tnr_pages = DIV_ROUND_UP(rest_len, PAGE_CACHE_SIZE);\n\t\t\tcur_len = rest_len;\n\t\t\ttailsz = rest_len - (nr_pages - 1) * PAGE_CACHE_SIZE;\n\t\t}\n\n\t\twdata2 = cifs_writedata_alloc(nr_pages, cifs_writev_complete);\n\t\tif (!wdata2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\twdata2->pages[j] = wdata->pages[i + j];\n\t\t\tlock_page(wdata2->pages[j]);\n\t\t\tclear_page_dirty_for_io(wdata2->pages[j]);\n\t\t}\n\n\t\twdata2->sync_mode = wdata->sync_mode;\n\t\twdata2->nr_pages = nr_pages;\n\t\twdata2->offset = page_offset(wdata2->pages[0]);\n\t\twdata2->pagesz = PAGE_CACHE_SIZE;\n\t\twdata2->tailsz = tailsz;\n\t\twdata2->bytes = cur_len;\n\n\t\twdata2->cfile = find_writable_file(CIFS_I(inode), false);\n\t\tif (!wdata2->cfile) {\n\t\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\t\trc = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\twdata2->pid = wdata2->cfile->pid;\n\t\trc = server->ops->async_writev(wdata2, cifs_writedata_release);\n\n\t\tfor (j = 0; j < nr_pages; j++) {\n\t\t\tunlock_page(wdata2->pages[j]);\n\t\t\tif (rc != 0 && rc != -EAGAIN) {\n\t\t\t\tSetPageError(wdata2->pages[j]);\n\t\t\t\tend_page_writeback(wdata2->pages[j]);\n\t\t\t\tpage_cache_release(wdata2->pages[j]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc) {\n\t\t\tkref_put(&wdata2->refcount, cifs_writedata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\trest_len -= cur_len;\n\t\ti += nr_pages;\n\t} while (i < wdata->nr_pages);\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}"
  },
  {
    "function_name": "cifs_writedata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1881-1891",
    "snippet": "void\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wdata"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "wdata->cfile"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "refcount",
            "structcifs_writedata",
            "refcount"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}"
  },
  {
    "function_name": "CIFSSMBWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1754-1879",
    "snippet": "int\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->Count"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Send error in write = %d\\n\"",
            "rc"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_writes"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "long_op"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bytes_sent >> 16"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bytes_sent & 0xFFFF"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "pSMB->Data",
            "ubuf",
            "bytes_sent"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pSMB->Data",
            "buf",
            "bytes_sent"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof(struct smb_com_write_req, Data) - 4"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "constunsigned int",
            "CIFSMaxBufSize",
            "count"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset >> 32"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset & 0xFFFFFFFF"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid >> 16)"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid >> 16"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_WRITE_ANDX",
            "wct",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1645-1751",
    "snippet": "int\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rsp_buf",
          "args": [
            "resp_buf_type",
            "iov[0].iov_base"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "free_rsp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "229-236",
          "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buf",
            "pReadData",
            "data_length"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->DataOffset"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"bad length %d for count %d\\n\"",
            "data_length",
            "count"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Send error in read = %d\\n\"",
            "rc"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_reads"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "tcon->ses",
            "iov",
            "1/* num iovecs */",
            "&resp_buf_type",
            "CIFS_LOG_ERROR"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pSMB->hdr.smb_buf_length"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "count >> 16"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count & 0xFFFF"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset >> 32"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset & 0xFFFFFFFF"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(pid >> 16)"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid >> 16"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)pid"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_READ_ANDX",
            "wct",
            "tcon",
            "(void **) &pSMB"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Reading %d bytes on fid %d\\n\"",
            "count",
            "netfid"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_async_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1581-1643",
    "snippet": "int\ncifs_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc;\n\tREAD_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((rdata->offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)rdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(rdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = rdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(rdata->offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tsmb->OffsetHigh = cpu_to_le32(rdata->offset >> 32);\n\tsmb->Remaining = 0;\n\tsmb->MaxCount = cpu_to_le16(rdata->bytes & 0xFFFF);\n\tsmb->MaxCountHigh = cpu_to_le32(rdata->bytes >> 16);\n\tif (wct == 12)\n\t\tsmb->ByteCount = 0;\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *smbr =\n\t\t\t(struct smb_com_readx_req *)smb;\n\t\tsmbr->ByteCount = 0;\n\t}\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\trdata->iov.iov_base = smb;\n\trdata->iov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, cifs_readv_receive,\n\t\t\t     cifs_readv_callback, rdata, 0);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\telse\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "smb"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_readdata_release"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_reads"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "tcon->ses->server",
            "&rqst",
            "cifs_readv_receive",
            "cifs_readv_callback",
            "rdata",
            "0"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&rdata->refcount"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb->hdr.smb_buf_length"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rdata->bytes >> 16"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "rdata->bytes & 0xFFFF"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rdata->offset >> 32"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rdata->offset & 0xFFFFFFFF"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(rdata->pid >> 16)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "rdata->pid >> 16"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)rdata->pid"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_READ_ANDX",
            "wct",
            "tcon",
            "(void **)&smb"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: offset=%llu bytes=%u\\n\"",
            "__func__",
            "rdata->offset",
            "rdata->bytes"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "rdata->cfile->tlink"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc;\n\tREAD_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((rdata->offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)rdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(rdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = rdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(rdata->offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tsmb->OffsetHigh = cpu_to_le32(rdata->offset >> 32);\n\tsmb->Remaining = 0;\n\tsmb->MaxCount = cpu_to_le16(rdata->bytes & 0xFFFF);\n\tsmb->MaxCountHigh = cpu_to_le32(rdata->bytes >> 16);\n\tif (wct == 12)\n\t\tsmb->ByteCount = 0;\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *smbr =\n\t\t\t(struct smb_com_readx_req *)smb;\n\t\tsmbr->ByteCount = 0;\n\t}\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\trdata->iov.iov_base = smb;\n\trdata->iov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, cifs_readv_receive,\n\t\t\t     cifs_readv_callback, rdata, 0);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\telse\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_readv_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1528-1578",
    "snippet": "static void\ncifs_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc = 0;\n\n\t\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t\t  mid->sequence_number);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\trdata->result = -EIO;\n\t}\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, 1, 0);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "server",
            "1",
            "0"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&rdata->work"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_bytes_read",
          "args": [
            "tcon",
            "rdata->got_bytes"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1213-1219",
          "snippet": "static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_account_read",
          "args": [
            "rdata->got_bytes"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_account_read",
          "args": [
            "rdata->got_bytes"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB signature verification returned error = %d\\n\"",
            "rc"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_verify_signature",
          "args": [
            "&rqst",
            "server",
            "mid->sequence_number"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_verify_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "206-259",
          "snippet": "int cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: mid=%llu state=%d result=%d bytes=%u\\n\"",
            "__func__",
            "mid->mid",
            "mid->mid_state",
            "rdata->result",
            "rdata->bytes"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "rdata->cfile->tlink"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\n\t\t\t\t .rq_nvec = 1,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc = 0;\n\n\t\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t\t  mid->sequence_number);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\trdata->result = -EIO;\n\t}\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, 1, 0);\n}"
  },
  {
    "function_name": "cifs_readv_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1420-1526",
    "snippet": "int\ncifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length, len;\n\tunsigned int data_offset, data_len;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tchar *buf = server->smallbuf;\n\tunsigned int buflen = get_rfc1002_length(buf) + 4;\n\n\tcifs_dbg(FYI, \"%s: mid=%llu offset=%llu bytes=%u\\n\",\n\t\t __func__, mid->mid, rdata->offset, rdata->bytes);\n\n\t/*\n\t * read the rest of READ_RSP header (sans Data array), or whatever we\n\t * can if there's not enough data. At this point, we've read down to\n\t * the Mid.\n\t */\n\tlen = min_t(unsigned int, buflen, server->vals->read_rsp_size) -\n\t\t\t\t\t\t\tHEADER_SIZE(server) + 1;\n\n\trdata->iov.iov_base = buf + HEADER_SIZE(server) - 1;\n\trdata->iov.iov_len = len;\n\n\tlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\t/* Was the SMB read successful? */\n\trdata->result = server->ops->map_error(buf, false);\n\tif (rdata->result != 0) {\n\t\tcifs_dbg(FYI, \"%s: server returned error %d\\n\",\n\t\t\t __func__, rdata->result);\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\t/* Is there enough to get to the rest of the READ_RSP header? */\n\tif (server->total_read < server->vals->read_rsp_size) {\n\t\tcifs_dbg(FYI, \"%s: server returned short header. got=%u expected=%zu\\n\",\n\t\t\t __func__, server->total_read,\n\t\t\t server->vals->read_rsp_size);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tdata_offset = server->ops->read_data_offset(buf) + 4;\n\tif (data_offset < server->total_read) {\n\t\t/*\n\t\t * win2k8 sometimes sends an offset of 0 when the read\n\t\t * is beyond the EOF. Treat it as if the data starts just after\n\t\t * the header.\n\t\t */\n\t\tcifs_dbg(FYI, \"%s: data offset (%u) inside read response header\\n\",\n\t\t\t __func__, data_offset);\n\t\tdata_offset = server->total_read;\n\t} else if (data_offset > MAX_CIFS_SMALL_BUFFER_SIZE) {\n\t\t/* data_offset is beyond the end of smallbuf */\n\t\tcifs_dbg(FYI, \"%s: data offset (%u) beyond end of smallbuf\\n\",\n\t\t\t __func__, data_offset);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tcifs_dbg(FYI, \"%s: total_read=%u data_offset=%u\\n\",\n\t\t __func__, server->total_read, data_offset);\n\n\tlen = data_offset - server->total_read;\n\tif (len > 0) {\n\t\t/* read any junk before data into the rest of smallbuf */\n\t\trdata->iov.iov_base = buf + server->total_read;\n\t\trdata->iov.iov_len = len;\n\t\tlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t}\n\n\t/* set up first iov for signature check */\n\trdata->iov.iov_base = buf;\n\trdata->iov.iov_len = server->total_read;\n\tcifs_dbg(FYI, \"0: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov.iov_base, rdata->iov.iov_len);\n\n\t/* how much data is in the response? */\n\tdata_len = server->ops->read_data_length(buf);\n\tif (data_offset + data_len > buflen) {\n\t\t/* data_len is corrupt -- discard frame */\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tlength = rdata->read_into_pages(server, rdata, data_len);\n\tif (length < 0)\n\t\treturn length;\n\n\tserver->total_read += length;\n\n\tcifs_dbg(FYI, \"total_read=%u buflen=%u remaining=%u\\n\",\n\t\t server->total_read, buflen, data_len);\n\n\t/* discard anything left over */\n\tif (server->total_read < buflen)\n\t\treturn cifs_readv_discard(server, mid);\n\n\tdequeue_mid(mid, false);\n\treturn length;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_mid",
          "args": [
            "mid",
            "false"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "657-670",
          "snippet": "void\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_readv_discard",
          "args": [
            "server",
            "mid"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1397-1418",
          "snippet": "static int\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tunsigned int rfclen = get_rfc1002_length(server->smallbuf);\n\tint remaining = rfclen + 4 - server->total_read;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\n\twhile (remaining > 0) {\n\t\tint length;\n\n\t\tlength = cifs_read_from_socket(server, server->bigbuf,\n\t\t\t\tmin_t(unsigned int, remaining,\n\t\t\t\t    CIFSMaxBufSize + MAX_HEADER_SIZE(server)));\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t\tremaining -= length;\n\t}\n\n\tdequeue_mid(mid, rdata->result);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tunsigned int rfclen = get_rfc1002_length(server->smallbuf);\n\tint remaining = rfclen + 4 - server->total_read;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\n\twhile (remaining > 0) {\n\t\tint length;\n\n\t\tlength = cifs_read_from_socket(server, server->bigbuf,\n\t\t\t\tmin_t(unsigned int, remaining,\n\t\t\t\t    CIFSMaxBufSize + MAX_HEADER_SIZE(server)));\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t\tremaining -= length;\n\t}\n\n\tdequeue_mid(mid, rdata->result);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"total_read=%u buflen=%u remaining=%u\\n\"",
            "server->total_read",
            "buflen",
            "data_len"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdata->read_into_pages",
          "args": [
            "server",
            "rdata",
            "data_len"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->read_data_length",
          "args": [
            "buf"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"0: iov_base=%p iov_len=%zu\\n\"",
            "rdata->iov.iov_base",
            "rdata->iov.iov_len"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readv_from_socket",
          "args": [
            "server",
            "&rdata->iov",
            "1",
            "len"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "542-599",
          "snippet": "int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: total_read=%u data_offset=%u\\n\"",
            "__func__",
            "server->total_read",
            "data_offset"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: data offset (%u) beyond end of smallbuf\\n\"",
            "__func__",
            "data_offset"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: data offset (%u) inside read response header\\n\"",
            "__func__",
            "data_offset"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->read_data_offset",
          "args": [
            "buf"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: server returned short header. got=%u expected=%zu\\n\"",
            "__func__",
            "server->total_read",
            "server->vals->read_rsp_size"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: server returned error %d\\n\"",
            "__func__",
            "rdata->result"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->map_error",
          "args": [
            "buf",
            "false"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "buflen",
            "server->vals->read_rsp_size"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: mid=%llu offset=%llu bytes=%u\\n\"",
            "__func__",
            "mid->mid",
            "rdata->offset",
            "rdata->bytes"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "buf"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length, len;\n\tunsigned int data_offset, data_len;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tchar *buf = server->smallbuf;\n\tunsigned int buflen = get_rfc1002_length(buf) + 4;\n\n\tcifs_dbg(FYI, \"%s: mid=%llu offset=%llu bytes=%u\\n\",\n\t\t __func__, mid->mid, rdata->offset, rdata->bytes);\n\n\t/*\n\t * read the rest of READ_RSP header (sans Data array), or whatever we\n\t * can if there's not enough data. At this point, we've read down to\n\t * the Mid.\n\t */\n\tlen = min_t(unsigned int, buflen, server->vals->read_rsp_size) -\n\t\t\t\t\t\t\tHEADER_SIZE(server) + 1;\n\n\trdata->iov.iov_base = buf + HEADER_SIZE(server) - 1;\n\trdata->iov.iov_len = len;\n\n\tlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\t/* Was the SMB read successful? */\n\trdata->result = server->ops->map_error(buf, false);\n\tif (rdata->result != 0) {\n\t\tcifs_dbg(FYI, \"%s: server returned error %d\\n\",\n\t\t\t __func__, rdata->result);\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\t/* Is there enough to get to the rest of the READ_RSP header? */\n\tif (server->total_read < server->vals->read_rsp_size) {\n\t\tcifs_dbg(FYI, \"%s: server returned short header. got=%u expected=%zu\\n\",\n\t\t\t __func__, server->total_read,\n\t\t\t server->vals->read_rsp_size);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tdata_offset = server->ops->read_data_offset(buf) + 4;\n\tif (data_offset < server->total_read) {\n\t\t/*\n\t\t * win2k8 sometimes sends an offset of 0 when the read\n\t\t * is beyond the EOF. Treat it as if the data starts just after\n\t\t * the header.\n\t\t */\n\t\tcifs_dbg(FYI, \"%s: data offset (%u) inside read response header\\n\",\n\t\t\t __func__, data_offset);\n\t\tdata_offset = server->total_read;\n\t} else if (data_offset > MAX_CIFS_SMALL_BUFFER_SIZE) {\n\t\t/* data_offset is beyond the end of smallbuf */\n\t\tcifs_dbg(FYI, \"%s: data offset (%u) beyond end of smallbuf\\n\",\n\t\t\t __func__, data_offset);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tcifs_dbg(FYI, \"%s: total_read=%u data_offset=%u\\n\",\n\t\t __func__, server->total_read, data_offset);\n\n\tlen = data_offset - server->total_read;\n\tif (len > 0) {\n\t\t/* read any junk before data into the rest of smallbuf */\n\t\trdata->iov.iov_base = buf + server->total_read;\n\t\trdata->iov.iov_len = len;\n\t\tlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t}\n\n\t/* set up first iov for signature check */\n\trdata->iov.iov_base = buf;\n\trdata->iov.iov_len = server->total_read;\n\tcifs_dbg(FYI, \"0: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov.iov_base, rdata->iov.iov_len);\n\n\t/* how much data is in the response? */\n\tdata_len = server->ops->read_data_length(buf);\n\tif (data_offset + data_len > buflen) {\n\t\t/* data_len is corrupt -- discard frame */\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tlength = rdata->read_into_pages(server, rdata, data_len);\n\tif (length < 0)\n\t\treturn length;\n\n\tserver->total_read += length;\n\n\tcifs_dbg(FYI, \"total_read=%u buflen=%u remaining=%u\\n\",\n\t\t server->total_read, buflen, data_len);\n\n\t/* discard anything left over */\n\tif (server->total_read < buflen)\n\t\treturn cifs_readv_discard(server, mid);\n\n\tdequeue_mid(mid, false);\n\treturn length;\n}"
  },
  {
    "function_name": "cifs_readv_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1397-1418",
    "snippet": "static int\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tunsigned int rfclen = get_rfc1002_length(server->smallbuf);\n\tint remaining = rfclen + 4 - server->total_read;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\n\twhile (remaining > 0) {\n\t\tint length;\n\n\t\tlength = cifs_read_from_socket(server, server->bigbuf,\n\t\t\t\tmin_t(unsigned int, remaining,\n\t\t\t\t    CIFSMaxBufSize + MAX_HEADER_SIZE(server)));\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t\tremaining -= length;\n\t}\n\n\tdequeue_mid(mid, rdata->result);\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_mid",
          "args": [
            "mid",
            "rdata->result"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "657-670",
          "snippet": "void\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_read_from_socket",
          "args": [
            "server",
            "server->bigbuf",
            "min_t(unsigned int, remaining,\n\t\t\t\t    CIFSMaxBufSize + MAX_HEADER_SIZE(server))"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "601-611",
          "snippet": "int\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "remaining",
            "CIFSMaxBufSize + MAX_HEADER_SIZE(server)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_HEADER_SIZE",
          "args": [
            "server"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "server->smallbuf"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tunsigned int rfclen = get_rfc1002_length(server->smallbuf);\n\tint remaining = rfclen + 4 - server->total_read;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\n\twhile (remaining > 0) {\n\t\tint length;\n\n\t\tlength = cifs_read_from_socket(server, server->bigbuf,\n\t\t\t\tmin_t(unsigned int, remaining,\n\t\t\t\t    CIFSMaxBufSize + MAX_HEADER_SIZE(server)));\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t\tremaining -= length;\n\t}\n\n\tdequeue_mid(mid, rdata->result);\n\treturn 0;\n}"
  },
  {
    "function_name": "CIFS_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1271-1391",
    "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "req"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)buf",
            "(char *)&rsp->CreationTime",
            "36"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FILE_CREATE"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in Open = %d\\n\"",
            "rc"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_opens"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *)req",
            "(struct smb_hdr *)rsp",
            "&bytes_returned",
            "0"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "req",
            "count"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "SECURITY_IMPERSONATION"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "create_options & CREATE_OPTIONS_MASK"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "disposition"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FILE_SHARE_ALL"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ATTR_READONLY"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ATTR_POSIX_SEMANTICS"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ATTR_NORMAL"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ATTR_SYSTEM"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "desired_access"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REQ_BATCHOPLOCK"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REQ_OPLOCK"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "req->fileName",
            "path",
            "name_len"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "path",
            "PATH_MAX"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *)(req->fileName + 1)",
            "path",
            "PATH_MAX",
            "nls",
            "remap"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NT_CREATE_ANDX",
            "24",
            "tcon",
            "(void **)&req",
            "(void **)&rsp"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMBLegacyOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1164-1269",
    "snippet": "int\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "le32_to_cpu(pSMBr->EndOfFile)"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->EndOfFile"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le16_to_cpu(pSMBr->FileAttributes)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->FileAttributes"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in Open = %d\\n\"",
            "rc"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_opens"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *)pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "convert_disposition(openDisposition)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_disposition",
          "args": [
            "openDisposition"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "convert_disposition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1120-1148",
          "snippet": "static __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unknown disposition %d\\n\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unknown disposition %d\\n\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_READONLY"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0/*ATTR_NORMAL*/"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_SYSTEM"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x40"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "access_flags_to_smbopen_mode(access_flags)"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_flags_to_smbopen_mode",
          "args": [
            "access_flags"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "access_flags_to_smbopen_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1150-1162",
          "snippet": "static int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "REQ_MORE_INFO"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "REQ_BATCHOPLOCK"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "REQ_OPLOCK"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->fileName",
            "fileName",
            "name_len"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) (pSMB->fileName + 1)",
            "fileName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_OPEN_ANDX",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "access_flags_to_smbopen_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1150-1162",
    "snippet": "static int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}"
  },
  {
    "function_name": "convert_disposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "1120-1148",
    "snippet": "static __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unknown disposition %d\\n\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unknown disposition %d\\n\"",
            "disposition"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unknown disposition %d\\n\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}"
  },
  {
    "function_name": "CIFSPOSIXCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "997-1118",
    "snippet": "int\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_posixopens"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_posixmkdirs"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) pRetData",
            "(char *)psx_rsp + sizeof(OPEN_PSX_RSP)",
            "sizeof(FILE_UNIX_BASIC_INFO)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Open response data too small\\n\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"unknown type\\n\""
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_UNIX_BASIC"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FILE_CREATE"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "psx_rsp->OplockFlags"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_t2",
          "args": [
            "(struct smb_t2_rsp *)pSMBr"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "validate_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "334-364",
          "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"copying inode info\\n\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Posix create returned %d\\n\"",
            "rc"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_POSIX_OPEN"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "*pOplock"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "posix_flags"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "mode"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_QUERY_FILE_UNIX_BASIC"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1000"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "name",
            "name_len"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "PATH_MAX"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "name",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In POSIX Create\\n\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBMkDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "952-995",
    "snippet": "int\nCIFSSMBMkDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tCREATE_DIRECTORY_REQ *pSMB = NULL;\n\tCREATE_DIRECTORY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBMkDir\\n\");\nMkDirRetry:\n\trc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_mkdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in Mkdir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto MkDirRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in Mkdir = %d\\n\"",
            "rc"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_mkdirs"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len + 1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "name_len + 1"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->DirName",
            "name",
            "name_len"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "PATH_MAX"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->DirName",
            "name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_CREATE_DIRECTORY",
            "0",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBMkDir\\n\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBMkDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tCREATE_DIRECTORY_REQ *pSMB = NULL;\n\tCREATE_DIRECTORY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBMkDir\\n\");\nMkDirRetry:\n\trc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_mkdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in Mkdir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto MkDirRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBRmDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "907-950",
    "snippet": "int\nCIFSSMBRmDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_DIRECTORY_REQ *pSMB = NULL;\n\tDELETE_DIRECTORY_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRmDir\\n\");\nRmDirRetry:\n\trc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_rmdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMDir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto RmDirRetry;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in RMDir = %d\\n\"",
            "rc"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_rmdirs"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len + 1"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "name_len + 1"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->DirName",
            "name",
            "name_len"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "PATH_MAX"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->DirName",
            "name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_DELETE_DIRECTORY",
            "0",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In CIFSSMBRmDir\\n\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBRmDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_DIRECTORY_REQ *pSMB = NULL;\n\tDELETE_DIRECTORY_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRmDir\\n\");\nRmDirRetry:\n\trc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_rmdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMDir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto RmDirRetry;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBDelFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "861-905",
    "snippet": "int\nCIFSSMBDelFile(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_FILE_REQ *pSMB = NULL;\n\tDELETE_FILE_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\nDelFileRetry:\n\trc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->fileName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->fileName, name, name_len);\n\t}\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMFile = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto DelFileRetry;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Error in RMFile = %d\\n\"",
            "rc"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_deletes"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len + 1"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "name_len + 1"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->fileName",
            "name",
            "name_len"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "PATH_MAX"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->fileName",
            "name",
            "PATH_MAX",
            "cifs_sb->local_nls",
            "remap"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_DELETE",
            "1",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBDelFile(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_FILE_REQ *pSMB = NULL;\n\tDELETE_FILE_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\nDelFileRetry:\n\trc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->fileName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->fileName, name, name_len);\n\t}\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMFile = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto DelFileRetry;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSPOSIXDelFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "785-859",
    "snippet": "int\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *fileName, __u16 type,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In POSIX delete\\n\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Posix delete returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_deletes"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Posix delete returned %d\\n\"",
            "rc"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "tcon->ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "byte_count"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "byte_count"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "SMB_POSIX_UNLINK"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "params"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct unlink_psx_rq)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sizeof(struct unlink_psx_rq)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TRANS2_SET_PATH_INFORMATION"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offset"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "param_offset"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "type"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->FileName",
            "fileName",
            "name_len"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "fileName",
            "PATH_MAX"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsConvertToUTF16",
          "args": [
            "(__le16 *) pSMB->FileName",
            "fileName",
            "PATH_MAX",
            "nls_codepage",
            "remap"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "cifsConvertToUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "403-460",
          "snippet": "int\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t/* check if end of string */\n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t/* see if we must remap this char */\n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfm_char(src_char);\n\t\telse\n\t\t\tdst_char = 0;\n\t\t/*\n\t\t * FIXME: We can not handle remapping backslash (UNI_SLASH)\n\t\t * until all the calls to build_path_from_dentry are modified,\n\t\t * as they use backslash as separator.\n\t\t */\n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t/*\n\t\t\t * if no match, use question mark, which at least in\n\t\t\t * some cases serves as wild card\n\t\t\t */\n\t\t\tif (charlen < 1) {\n\t\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\t\tcharlen = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * character may take more than one byte in the source string,\n\t\t * but will take exactly two bytes in the target string\n\t\t */\n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]); /* Null terminate target unicode string */\n\treturn j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_TRANSACTION2",
            "15",
            "tcon",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In POSIX delete\\n\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *fileName, __u16 type,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In POSIX delete\\n\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Posix delete returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBLogoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "739-783",
    "snippet": "int\nCIFSSMBLogoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In SMBLogoff for session disconnect\\n\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\tif (ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (char *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "ses",
            "(char *) pSMB",
            "0"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "ses->server"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_LOGOFF_ANDX",
            "2",
            "NULL",
            "(void **)&pSMB"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In SMBLogoff for session disconnect\\n\""
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBLogoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In SMBLogoff for session disconnect\\n\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\tif (ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (char *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBEcho",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "704-737",
    "snippet": "int\nCIFSSMBEcho(struct TCP_Server_Info *server)\n{\n\tECHO_REQ *smb;\n\tint rc = 0;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\trc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\t/* set up echo request */\n\tsmb->hdr.Tid = 0xffff;\n\tsmb->hdr.WordCount = 1;\n\tput_unaligned_le16(1, &smb->EchoCount);\n\tput_bcc(1, &smb->hdr);\n\tsmb->Data[0] = 'a';\n\tinc_rfc1001_len(smb, 3);\n\tiov.iov_base = smb;\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, cifs_echo_callback,\n\t\t\t     server, CIFS_ASYNC_OP | CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(smb);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "smb"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Echo request failed: %d\\n\"",
            "rc"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_call_async",
          "args": [
            "server",
            "&rqst",
            "NULL",
            "cifs_echo_callback",
            "server",
            "CIFS_ASYNC_OP | CIFS_ECHO_OP"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_call_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "536-589",
          "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb->hdr.smb_buf_length"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "smb",
            "3"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bcc",
          "args": [
            "1",
            "&smb->hdr"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "put_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "455-461",
          "snippet": "static inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned_le16",
          "args": [
            "1",
            "&smb->EchoCount"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_ECHO",
            "0",
            "NULL",
            "(void **)&smb"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In echo request\\n\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBEcho(struct TCP_Server_Info *server)\n{\n\tECHO_REQ *smb;\n\tint rc = 0;\n\tstruct kvec iov;\n\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\trc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\t/* set up echo request */\n\tsmb->hdr.Tid = 0xffff;\n\tsmb->hdr.WordCount = 1;\n\tput_unaligned_le16(1, &smb->EchoCount);\n\tput_bcc(1, &smb->hdr);\n\tsmb->Data[0] = 'a';\n\tinc_rfc1001_len(smb, 3);\n\tiov.iov_base = smb;\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, cifs_echo_callback,\n\t\t\t     server, CIFS_ASYNC_OP | CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(smb);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_echo_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "695-702",
    "snippet": "static void\ncifs_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, 1, CIFS_ECHO_OP);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "server",
            "1",
            "CIFS_ECHO_OP"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, 1, CIFS_ECHO_OP);\n}"
  },
  {
    "function_name": "CIFSSMBTDis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "650-686",
    "snippet": "int\nCIFSSMBTDis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_hdr *smb_buffer;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In tree disconnect\\n\");\n\n\t/* BB: do we need to check this? These should never be NULL. */\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\t/*\n\t * No need to return error on this operation if tid invalidated and\n\t * closed on server already e.g. due to tcp session crashing. Also,\n\t * the tcon is no longer on the list, so no need to take lock before\n\t * checking this.\n\t */\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\n\t\t\t    (void **)&smb_buffer);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)smb_buffer, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Tree disconnect failed %d\\n\", rc);\n\n\t/* No need to return error on this operation if tid invalidated and\n\t   closed on server already e.g. due to tcp session crashing */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Tree disconnect failed %d\\n\"",
            "rc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceiveNoRsp",
          "args": [
            "xid",
            "tcon->ses",
            "(char *)smb_buffer",
            "0"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceiveNoRsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "600-615",
          "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "SMB_COM_TREE_DISCONNECT",
            "0",
            "tcon",
            "(void **)&smb_buffer"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In tree disconnect\\n\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBTDis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_hdr *smb_buffer;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In tree disconnect\\n\");\n\n\t/* BB: do we need to check this? These should never be NULL. */\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\t/*\n\t * No need to return error on this operation if tid invalidated and\n\t * closed on server already e.g. due to tcp session crashing. Also,\n\t * the tcon is no longer on the list, so no need to take lock before\n\t * checking this.\n\t */\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\n\t\t\t    (void **)&smb_buffer);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)smb_buffer, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Tree disconnect failed %d\\n\", rc);\n\n\t/* No need to return error on this operation if tid invalidated and\n\t   closed on server already e.g. due to tcp session crashing */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "CIFSSMBNegotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "544-648",
    "snippet": "int\nCIFSSMBNegotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 count;\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Mid = get_next_mid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif (should_set_ext_sec_flag(ses->sectype)) {\n\t\tcifs_dbg(FYI, \"Requesting extended security.\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcifs_dbg(FYI, \"Dialect: %d\\n\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_LANMAN;\n\t\trc = decode_lanman_negprot_rsp(server, pSMBr);\n\t\tgoto signing_check;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17, NTLM or better */\n\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcifs_dbg(FYI, \"share mode security\\n\");\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcifs_dbg(NOISY, \"Max buf = %d\\n\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t\trc = decode_ext_sec_blob(ses, pSMBr);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t} else {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\t}\n\nsigning_check:\n\tif (!rc)\n\t\trc = cifs_enable_signing(server, ses->sign);\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcifs_dbg(FYI, \"negprot rc %d\\n\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_NUM_PROT 1",
      "#define CIFS_NUM_PROT 3",
      "#define CIFS_NUM_PROT 2",
      "#define CIFS_NUM_PROT 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"negprot rc %d\\n\"",
            "rc"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "pSMB"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_enable_signing",
          "args": [
            "server",
            "ses->sign"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_enable_signing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "403-444",
          "snippet": "int\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_ext_sec_blob",
          "args": [
            "ses",
            "pSMBr"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "decode_ext_sec_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "366-401",
          "snippet": "static int\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\n{\n\tint\trc = 0;\n\tu16\tcount;\n\tchar\t*guid = pSMBr->u.extended_response.GUID;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcount = get_bcc(&pSMBr->hdr);\n\tif (count < SMB1_CLIENT_GUID_SIZE)\n\t\treturn -EIO;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (server->srv_count > 1) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\n\t\t\tcifs_dbg(FYI, \"server UID changed\\n\");\n\t\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t\t}\n\t} else {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t}\n\n\tif (count == SMB1_CLIENT_GUID_SIZE) {\n\t\tserver->sec_ntlmssp = true;\n\t} else {\n\t\tcount -= SMB1_CLIENT_GUID_SIZE;\n\t\trc = decode_negTokenInit(\n\t\t\tpSMBr->u.extended_response.SecurityBlob, count, server);\n\t\tif (rc != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\n{\n\tint\trc = 0;\n\tu16\tcount;\n\tchar\t*guid = pSMBr->u.extended_response.GUID;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcount = get_bcc(&pSMBr->hdr);\n\tif (count < SMB1_CLIENT_GUID_SIZE)\n\t\treturn -EIO;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (server->srv_count > 1) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\n\t\t\tcifs_dbg(FYI, \"server UID changed\\n\");\n\t\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t\t}\n\t} else {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t}\n\n\tif (count == SMB1_CLIENT_GUID_SIZE) {\n\t\tserver->sec_ntlmssp = true;\n\t} else {\n\t\tcount -= SMB1_CLIENT_GUID_SIZE;\n\t\trc = decode_negTokenInit(\n\t\t\tpSMBr->u.extended_response.SecurityBlob, count, server);\n\t\tif (rc != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ses->server->cryptkey",
            "pSMBr->u.EncryptionKey",
            "CIFS_CRYPTO_KEY_SIZE"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMBr->ServerTimeZone"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMBr->Capabilities"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"Max buf = %d\\n\"",
            "ses->server->maxBuf"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_credits",
          "args": [
            "server",
            "server->maxReq"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "127-134",
          "snippet": "static void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "le16_to_cpu(pSMBr->MaxMpxCount)",
            "cifs_max_pending"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"share mode security\\n\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_lanman_negprot_rsp",
          "args": [
            "server",
            "pSMBr"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "decode_lanman_negprot_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "519-524",
          "snippet": "static inline int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\tcifs_dbg(VFS, \"mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\\n\");\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\tcifs_dbg(VFS, \"mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\\n\");\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Dialect: %d\\n\"",
            "server->dialect"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "ses",
            "(struct smb_hdr *) pSMB",
            "(struct smb_hdr *) pSMBr",
            "&bytes_returned",
            "0"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rfc1001_len",
          "args": [
            "pSMB",
            "count"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rfc1001_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "527-531",
          "snippet": "static inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "protocols[i].name"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pSMB->DialectsArray+count",
            "protocols[i].name",
            "16"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Requesting extended security.\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_set_ext_sec_flag",
          "args": [
            "ses->sectype"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "should_set_ext_sec_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "527-542",
          "snippet": "static bool\nshould_set_ext_sec_flag(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\tcase Kerberos:\n\t\treturn true;\n\tcase Unspecified:\n\t\tif (global_secflags &\n\t\t    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn true;\n\t\t/* Fallthrough */\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic bool\nshould_set_ext_sec_flag(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\tcase Kerberos:\n\t\treturn true;\n\tcase Unspecified:\n\t\tif (global_secflags &\n\t\t    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn true;\n\t\t/* Fallthrough */\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "server"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_init",
          "args": [
            "SMB_COM_NEGOTIATE",
            "0",
            "NULL/* no tcon yet */",
            "(void **) &pSMB",
            "(void **) &pSMBr"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "smb_init_nttransact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3718-3745",
          "snippet": "static int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: server is NULL!\\n\"",
            "__func__"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\n#define CIFS_NUM_PROT 1\n#define CIFS_NUM_PROT 3\n#define CIFS_NUM_PROT 2\n#define CIFS_NUM_PROT 4\n\nint\nCIFSSMBNegotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 count;\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Mid = get_next_mid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif (should_set_ext_sec_flag(ses->sectype)) {\n\t\tcifs_dbg(FYI, \"Requesting extended security.\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcifs_dbg(FYI, \"Dialect: %d\\n\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_LANMAN;\n\t\trc = decode_lanman_negprot_rsp(server, pSMBr);\n\t\tgoto signing_check;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17, NTLM or better */\n\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcifs_dbg(FYI, \"share mode security\\n\");\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcifs_dbg(NOISY, \"Max buf = %d\\n\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t\trc = decode_ext_sec_blob(ses, pSMBr);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t} else {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\t}\n\nsigning_check:\n\tif (!rc)\n\t\trc = cifs_enable_signing(server, ses->sign);\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcifs_dbg(FYI, \"negprot rc %d\\n\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "should_set_ext_sec_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "527-542",
    "snippet": "static bool\nshould_set_ext_sec_flag(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\tcase Kerberos:\n\t\treturn true;\n\tcase Unspecified:\n\t\tif (global_secflags &\n\t\t    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn true;\n\t\t/* Fallthrough */\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic bool\nshould_set_ext_sec_flag(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\tcase Kerberos:\n\t\treturn true;\n\tcase Unspecified:\n\t\tif (global_secflags &\n\t\t    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn true;\n\t\t/* Fallthrough */\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "decode_lanman_negprot_rsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "519-524",
    "snippet": "static inline int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\tcifs_dbg(VFS, \"mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\\n\");\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\\n\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic inline int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\tcifs_dbg(VFS, \"mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\\n\");\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "decode_lanman_negprot_rsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "447-517",
    "snippet": "static int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\t__s16 tmp;\n\tstruct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;\n\n\tif (server->dialect != LANMAN_PROT && server->dialect != LANMAN2_PROT)\n\t\treturn -EOPNOTSUPP;\n\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->maxReq = min_t(unsigned int,\n\t\t\t       le16_to_cpu(rsp->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\tserver->maxBuf = le16_to_cpu(rsp->MaxBufSize);\n\t/* even though we do not use raw we might as well set this\n\taccurately, in case we ever find a need for it */\n\tif ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {\n\t\tserver->max_rw = 0xFF00;\n\t\tserver->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;\n\t} else {\n\t\tserver->max_rw = 0;/* do not need to use raw anyway */\n\t\tserver->capabilities = CAP_MPX_MODE;\n\t}\n\ttmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);\n\tif (tmp == -1) {\n\t\t/* OS/2 often does not set timezone therefore\n\t\t * we must use server time to calc time zone.\n\t\t * Could deviate slightly from the right zone.\n\t\t * Smallest defined timezone difference is 15 minutes\n\t\t * (i.e. Nepal).  Rounding up/down is done to match\n\t\t * this requirement.\n\t\t */\n\t\tint val, seconds, remain, result;\n\t\tstruct timespec ts, utc;\n\t\tutc = CURRENT_TIME;\n\t\tts = cnvrtDosUnixTm(rsp->SrvTime.Date,\n\t\t\t\t    rsp->SrvTime.Time, 0);\n\t\tcifs_dbg(FYI, \"SrvTime %d sec since 1970 (utc: %d) diff: %d\\n\",\n\t\t\t (int)ts.tv_sec, (int)utc.tv_sec,\n\t\t\t (int)(utc.tv_sec - ts.tv_sec));\n\t\tval = (int)(utc.tv_sec - ts.tv_sec);\n\t\tseconds = abs(val);\n\t\tresult = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;\n\t\tremain = seconds % MIN_TZ_ADJ;\n\t\tif (remain >= (MIN_TZ_ADJ / 2))\n\t\t\tresult += MIN_TZ_ADJ;\n\t\tif (val < 0)\n\t\t\tresult = -result;\n\t\tserver->timeAdj = result;\n\t} else {\n\t\tserver->timeAdj = (int)tmp;\n\t\tserver->timeAdj *= 60; /* also in seconds */\n\t}\n\tcifs_dbg(FYI, \"server->timeAdj: %d seconds\\n\", server->timeAdj);\n\n\n\t/* BB get server time for time conversions and add\n\tcode to use it and timezone since this is not UTC */\n\n\tif (rsp->EncryptionKeyLength ==\n\t\t\tcpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {\n\t\tmemcpy(server->cryptkey, rsp->EncryptionKey,\n\t\t\tCIFS_CRYPTO_KEY_SIZE);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\treturn -EIO; /* need cryptkey unless plain text */\n\t}\n\n\tcifs_dbg(FYI, \"LANMAN negotiated\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"LANMAN negotiated\\n\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->cryptkey",
            "rsp->EncryptionKey",
            "CIFS_CRYPTO_KEY_SIZE"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "CIFS_CRYPTO_KEY_SIZE"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"server->timeAdj: %d seconds\\n\"",
            "server->timeAdj"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "val"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SrvTime %d sec since 1970 (utc: %d) diff: %d\\n\"",
            "(int)ts.tv_sec",
            "(int)utc.tv_sec",
            "(int)(utc.tv_sec - ts.tv_sec)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnvrtDosUnixTm",
          "args": [
            "rsp->SrvTime.Date",
            "rsp->SrvTime.Time",
            "0"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "cnvrtDosUnixTm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "962-1014",
          "snippet": "struct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)\n{\n\tstruct timespec ts;\n\tint sec, min, days, month, year;\n\tu16 date = le16_to_cpu(le_date);\n\tu16 time = le16_to_cpu(le_time);\n\tSMB_TIME *st = (SMB_TIME *)&time;\n\tSMB_DATE *sd = (SMB_DATE *)&date;\n\n\tcifs_dbg(FYI, \"date %d time %d\\n\", date, time);\n\n\tsec = 2 * st->TwoSeconds;\n\tmin = st->Minutes;\n\tif ((sec > 59) || (min > 59))\n\t\tcifs_dbg(VFS, \"illegal time min %d sec %d\\n\", min, sec);\n\tsec += (min * 60);\n\tsec += 60 * 60 * st->Hours;\n\tif (st->Hours > 24)\n\t\tcifs_dbg(VFS, \"illegal hours %d\\n\", st->Hours);\n\tdays = sd->Day;\n\tmonth = sd->Month;\n\tif ((days > 31) || (month > 12)) {\n\t\tcifs_dbg(VFS, \"illegal date, month %d day: %d\\n\", month, days);\n\t\tif (month > 12)\n\t\t\tmonth = 12;\n\t}\n\tmonth -= 1;\n\tdays += total_days_of_prev_months[month];\n\tdays += 3652; /* account for difference in days between 1980 and 1970 */\n\tyear = sd->Year;\n\tdays += year * 365;\n\tdays += (year/4); /* leap year */\n\t/* generalized leap year calculation is more complex, ie no leap year\n\tfor years/100 except for years/400, but since the maximum number for DOS\n\t year is 2**7, the last year is 1980+127, which means we need only\n\t consider 2 special case years, ie the years 2000 and 2100, and only\n\t adjust for the lack of leap year for the year 2100, as 2000 was a\n\t leap year (divisable by 400) */\n\tif (year >= 120)  /* the year 2100 */\n\t\tdays = days - 1;  /* do not count leap year for the year 2100 */\n\n\t/* adjust for leap year where we are still before leap day */\n\tif (year != 120)\n\t\tdays -= ((year & 0x03) == 0) && (month < 2 ? 1 : 0);\n\tsec += 24 * 60 * 60 * days;\n\n\tts.tv_sec = sec + offset;\n\n\t/* cifs_dbg(FYI, \"sec after cnvrt dos to unix time %d\\n\",sec); */\n\n\tts.tv_nsec = 0;\n\treturn ts;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int total_days_of_prev_months[] = {\n\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nstatic const int total_days_of_prev_months[] = {\n\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n};\n\nstruct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)\n{\n\tstruct timespec ts;\n\tint sec, min, days, month, year;\n\tu16 date = le16_to_cpu(le_date);\n\tu16 time = le16_to_cpu(le_time);\n\tSMB_TIME *st = (SMB_TIME *)&time;\n\tSMB_DATE *sd = (SMB_DATE *)&date;\n\n\tcifs_dbg(FYI, \"date %d time %d\\n\", date, time);\n\n\tsec = 2 * st->TwoSeconds;\n\tmin = st->Minutes;\n\tif ((sec > 59) || (min > 59))\n\t\tcifs_dbg(VFS, \"illegal time min %d sec %d\\n\", min, sec);\n\tsec += (min * 60);\n\tsec += 60 * 60 * st->Hours;\n\tif (st->Hours > 24)\n\t\tcifs_dbg(VFS, \"illegal hours %d\\n\", st->Hours);\n\tdays = sd->Day;\n\tmonth = sd->Month;\n\tif ((days > 31) || (month > 12)) {\n\t\tcifs_dbg(VFS, \"illegal date, month %d day: %d\\n\", month, days);\n\t\tif (month > 12)\n\t\t\tmonth = 12;\n\t}\n\tmonth -= 1;\n\tdays += total_days_of_prev_months[month];\n\tdays += 3652; /* account for difference in days between 1980 and 1970 */\n\tyear = sd->Year;\n\tdays += year * 365;\n\tdays += (year/4); /* leap year */\n\t/* generalized leap year calculation is more complex, ie no leap year\n\tfor years/100 except for years/400, but since the maximum number for DOS\n\t year is 2**7, the last year is 1980+127, which means we need only\n\t consider 2 special case years, ie the years 2000 and 2100, and only\n\t adjust for the lack of leap year for the year 2100, as 2000 was a\n\t leap year (divisable by 400) */\n\tif (year >= 120)  /* the year 2100 */\n\t\tdays = days - 1;  /* do not count leap year for the year 2100 */\n\n\t/* adjust for leap year where we are still before leap day */\n\tif (year != 120)\n\t\tdays -= ((year & 0x03) == 0) && (month < 2 ? 1 : 0);\n\tsec += 24 * 60 * 60 * days;\n\n\tts.tv_sec = sec + offset;\n\n\t/* cifs_dbg(FYI, \"sec after cnvrt dos to unix time %d\\n\",sec); */\n\n\tts.tv_nsec = 0;\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->ServerTimeZone"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_credits",
          "args": [
            "server",
            "server->maxReq"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "127-134",
          "snippet": "static void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "le16_to_cpu(rsp->MaxMpxCount)",
            "cifs_max_pending"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\n{\n\t__s16 tmp;\n\tstruct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;\n\n\tif (server->dialect != LANMAN_PROT && server->dialect != LANMAN2_PROT)\n\t\treturn -EOPNOTSUPP;\n\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->maxReq = min_t(unsigned int,\n\t\t\t       le16_to_cpu(rsp->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\tserver->maxBuf = le16_to_cpu(rsp->MaxBufSize);\n\t/* even though we do not use raw we might as well set this\n\taccurately, in case we ever find a need for it */\n\tif ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {\n\t\tserver->max_rw = 0xFF00;\n\t\tserver->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;\n\t} else {\n\t\tserver->max_rw = 0;/* do not need to use raw anyway */\n\t\tserver->capabilities = CAP_MPX_MODE;\n\t}\n\ttmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);\n\tif (tmp == -1) {\n\t\t/* OS/2 often does not set timezone therefore\n\t\t * we must use server time to calc time zone.\n\t\t * Could deviate slightly from the right zone.\n\t\t * Smallest defined timezone difference is 15 minutes\n\t\t * (i.e. Nepal).  Rounding up/down is done to match\n\t\t * this requirement.\n\t\t */\n\t\tint val, seconds, remain, result;\n\t\tstruct timespec ts, utc;\n\t\tutc = CURRENT_TIME;\n\t\tts = cnvrtDosUnixTm(rsp->SrvTime.Date,\n\t\t\t\t    rsp->SrvTime.Time, 0);\n\t\tcifs_dbg(FYI, \"SrvTime %d sec since 1970 (utc: %d) diff: %d\\n\",\n\t\t\t (int)ts.tv_sec, (int)utc.tv_sec,\n\t\t\t (int)(utc.tv_sec - ts.tv_sec));\n\t\tval = (int)(utc.tv_sec - ts.tv_sec);\n\t\tseconds = abs(val);\n\t\tresult = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;\n\t\tremain = seconds % MIN_TZ_ADJ;\n\t\tif (remain >= (MIN_TZ_ADJ / 2))\n\t\t\tresult += MIN_TZ_ADJ;\n\t\tif (val < 0)\n\t\t\tresult = -result;\n\t\tserver->timeAdj = result;\n\t} else {\n\t\tserver->timeAdj = (int)tmp;\n\t\tserver->timeAdj *= 60; /* also in seconds */\n\t}\n\tcifs_dbg(FYI, \"server->timeAdj: %d seconds\\n\", server->timeAdj);\n\n\n\t/* BB get server time for time conversions and add\n\tcode to use it and timezone since this is not UTC */\n\n\tif (rsp->EncryptionKeyLength ==\n\t\t\tcpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {\n\t\tmemcpy(server->cryptkey, rsp->EncryptionKey,\n\t\t\tCIFS_CRYPTO_KEY_SIZE);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\treturn -EIO; /* need cryptkey unless plain text */\n\t}\n\n\tcifs_dbg(FYI, \"LANMAN negotiated\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_enable_signing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "403-444",
    "snippet": "int\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Server does not support signing!\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Server requires signing, but it's disabled in SecurityFlags!\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\n\n\t/*\n\t * Is signing required by mnt options? If not then check\n\t * global_secflags to see if it is there.\n\t */\n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t/*\n\t * If signing is required then it's automatically enabled too,\n\t * otherwise, check to see if the secflags allow it.\n\t */\n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t/* If server requires signing, does client allow it? */\n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t/* If client requires signing, does server allow it? */\n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_ext_sec_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "366-401",
    "snippet": "static int\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\n{\n\tint\trc = 0;\n\tu16\tcount;\n\tchar\t*guid = pSMBr->u.extended_response.GUID;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcount = get_bcc(&pSMBr->hdr);\n\tif (count < SMB1_CLIENT_GUID_SIZE)\n\t\treturn -EIO;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (server->srv_count > 1) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\n\t\t\tcifs_dbg(FYI, \"server UID changed\\n\");\n\t\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t\t}\n\t} else {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t}\n\n\tif (count == SMB1_CLIENT_GUID_SIZE) {\n\t\tserver->sec_ntlmssp = true;\n\t} else {\n\t\tcount -= SMB1_CLIENT_GUID_SIZE;\n\t\trc = decode_negTokenInit(\n\t\t\tpSMBr->u.extended_response.SecurityBlob, count, server);\n\t\tif (rc != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_negTokenInit",
          "args": [
            "pSMBr->u.extended_response.SecurityBlob",
            "count",
            "server"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "decode_negTokenInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/asn1.c",
          "lines": "493-623",
          "snippet": "int\ndecode_negTokenInit(unsigned char *security_blob, int length,\n\t\t    struct TCP_Server_Info *server)\n{\n\tstruct asn1_ctx ctx;\n\tunsigned char *end;\n\tunsigned char *sequence_end;\n\tunsigned long *oid = NULL;\n\tunsigned int cls, con, tag, oidlen, rc;\n\n\t/* cifs_dump_mem(\" Received SecBlob \", security_blob, length); */\n\n\tasn1_open(&ctx, security_blob, length);\n\n\t/* GSSAPI header */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_APL) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d\\n\", cls, con, tag);\n\t\treturn 0;\n\t}\n\n\t/* Check for SPNEGO OID -- remember to free obj->oid */\n\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\tif (rc) {\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI) &&\n\t\t    (cls == ASN1_UNI)) {\n\t\t\trc = asn1_oid_decode(&ctx, end, &oid, &oidlen);\n\t\t\tif (rc) {\n\t\t\t\trc = compare_oid(oid, oidlen, SPNEGO_OID,\n\t\t\t\t\t\t SPNEGO_OID_LEN);\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\t/* SPNEGO OID not present or garbled -- bail out */\n\tif (!rc) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t}\n\n\t/* SPNEGO */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* negTokenInit */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence of */\n\tif (asn1_header_decode\n\t    (&ctx, &sequence_end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* list of security mechanisms */\n\twhile (!asn1_eoc_decode(&ctx, sequence_end)) {\n\t\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(FYI, \"Error decoding negTokenInit hdr exit2\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI)) {\n\t\t\tif (asn1_oid_decode(&ctx, end, &oid, &oidlen)) {\n\n\t\t\t\tcifs_dbg(FYI, \"OID len = %d oid = 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t\t\t\t oidlen, *oid, *(oid + 1), *(oid + 2),\n\t\t\t\t\t *(oid + 3));\n\n\t\t\t\tif (compare_oid(oid, oidlen, MSKRB5_OID,\n\t\t\t\t\t\tMSKRB5_OID_LEN))\n\t\t\t\t\tserver->sec_mskerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5U2U_OID,\n\t\t\t\t\t\t     KRB5U2U_OID_LEN))\n\t\t\t\t\tserver->sec_kerberosu2u = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5_OID,\n\t\t\t\t\t\t     KRB5_OID_LEN))\n\t\t\t\t\tserver->sec_kerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, NTLMSSP_OID,\n\t\t\t\t\t\t     NTLMSSP_OID_LEN))\n\t\t\t\t\tserver->sec_ntlmssp = true;\n\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Should be an oid what is going on?\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We currently ignore anything at the end of the SPNEGO blob after\n\t * the mechTypes have been parsed, since none of that info is\n\t * used at the moment.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MSKRB5_OID_LEN  7",
            "#define KRB5U2U_OID_LEN  8",
            "#define KRB5_OID_LEN  7",
            "#define NTLMSSP_OID_LEN  10",
            "#define SPNEGO_OID_LEN 7",
            "#define ASN1_CON\t1\t/* Constructed */",
            "#define ASN1_PRI\t0\t/* Primitive */",
            "#define ASN1_SEQ\t16\t/* Sequence */",
            "#define ASN1_OJI\t6\t/* Object Identifier  */",
            "#define ASN1_EOC\t0\t/* End Of Contents or N/A */",
            "#define ASN1_CTX\t2\t/* Context */",
            "#define ASN1_APL\t1\t/* Application */",
            "#define ASN1_UNI\t0\t/* Universal */"
          ],
          "globals_used": [
            "static unsigned long SPNEGO_OID[7] = { 1, 3, 6, 1, 5, 5, 2 };",
            "static unsigned long NTLMSSP_OID[10] = { 1, 3, 6, 1, 4, 1, 311, 2, 2, 10 };",
            "static unsigned long KRB5_OID[7] = { 1, 2, 840, 113554, 1, 2, 2 };",
            "static unsigned long KRB5U2U_OID[8] = { 1, 2, 840, 113554, 1, 2, 2, 3 };",
            "static unsigned long MSKRB5_OID[7] = { 1, 2, 840, 48018, 1, 2, 2 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define MSKRB5_OID_LEN  7\n#define KRB5U2U_OID_LEN  8\n#define KRB5_OID_LEN  7\n#define NTLMSSP_OID_LEN  10\n#define SPNEGO_OID_LEN 7\n#define ASN1_CON\t1\t/* Constructed */\n#define ASN1_PRI\t0\t/* Primitive */\n#define ASN1_SEQ\t16\t/* Sequence */\n#define ASN1_OJI\t6\t/* Object Identifier  */\n#define ASN1_EOC\t0\t/* End Of Contents or N/A */\n#define ASN1_CTX\t2\t/* Context */\n#define ASN1_APL\t1\t/* Application */\n#define ASN1_UNI\t0\t/* Universal */\n\nstatic unsigned long SPNEGO_OID[7] = { 1, 3, 6, 1, 5, 5, 2 };\nstatic unsigned long NTLMSSP_OID[10] = { 1, 3, 6, 1, 4, 1, 311, 2, 2, 10 };\nstatic unsigned long KRB5_OID[7] = { 1, 2, 840, 113554, 1, 2, 2 };\nstatic unsigned long KRB5U2U_OID[8] = { 1, 2, 840, 113554, 1, 2, 2, 3 };\nstatic unsigned long MSKRB5_OID[7] = { 1, 2, 840, 48018, 1, 2, 2 };\n\nint\ndecode_negTokenInit(unsigned char *security_blob, int length,\n\t\t    struct TCP_Server_Info *server)\n{\n\tstruct asn1_ctx ctx;\n\tunsigned char *end;\n\tunsigned char *sequence_end;\n\tunsigned long *oid = NULL;\n\tunsigned int cls, con, tag, oidlen, rc;\n\n\t/* cifs_dump_mem(\" Received SecBlob \", security_blob, length); */\n\n\tasn1_open(&ctx, security_blob, length);\n\n\t/* GSSAPI header */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_APL) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d\\n\", cls, con, tag);\n\t\treturn 0;\n\t}\n\n\t/* Check for SPNEGO OID -- remember to free obj->oid */\n\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\tif (rc) {\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI) &&\n\t\t    (cls == ASN1_UNI)) {\n\t\t\trc = asn1_oid_decode(&ctx, end, &oid, &oidlen);\n\t\t\tif (rc) {\n\t\t\t\trc = compare_oid(oid, oidlen, SPNEGO_OID,\n\t\t\t\t\t\t SPNEGO_OID_LEN);\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\t/* SPNEGO OID not present or garbled -- bail out */\n\tif (!rc) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit header\\n\");\n\t\treturn 0;\n\t}\n\n\t/* SPNEGO */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* negTokenInit */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence */\n\tif (asn1_header_decode(&ctx, &end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_CTX) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_EOC)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 0\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* sequence of */\n\tif (asn1_header_decode\n\t    (&ctx, &sequence_end, &cls, &con, &tag) == 0) {\n\t\tcifs_dbg(FYI, \"Error decoding 2nd part of negTokenInit\\n\");\n\t\treturn 0;\n\t} else if ((cls != ASN1_UNI) || (con != ASN1_CON)\n\t\t   || (tag != ASN1_SEQ)) {\n\t\tcifs_dbg(FYI, \"cls = %d con = %d tag = %d end = %p (%d) exit 1\\n\",\n\t\t\t cls, con, tag, end, *end);\n\t\treturn 0;\n\t}\n\n\t/* list of security mechanisms */\n\twhile (!asn1_eoc_decode(&ctx, sequence_end)) {\n\t\trc = asn1_header_decode(&ctx, &end, &cls, &con, &tag);\n\t\tif (!rc) {\n\t\t\tcifs_dbg(FYI, \"Error decoding negTokenInit hdr exit2\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif ((tag == ASN1_OJI) && (con == ASN1_PRI)) {\n\t\t\tif (asn1_oid_decode(&ctx, end, &oid, &oidlen)) {\n\n\t\t\t\tcifs_dbg(FYI, \"OID len = %d oid = 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t\t\t\t oidlen, *oid, *(oid + 1), *(oid + 2),\n\t\t\t\t\t *(oid + 3));\n\n\t\t\t\tif (compare_oid(oid, oidlen, MSKRB5_OID,\n\t\t\t\t\t\tMSKRB5_OID_LEN))\n\t\t\t\t\tserver->sec_mskerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5U2U_OID,\n\t\t\t\t\t\t     KRB5U2U_OID_LEN))\n\t\t\t\t\tserver->sec_kerberosu2u = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, KRB5_OID,\n\t\t\t\t\t\t     KRB5_OID_LEN))\n\t\t\t\t\tserver->sec_kerberos = true;\n\t\t\t\telse if (compare_oid(oid, oidlen, NTLMSSP_OID,\n\t\t\t\t\t\t     NTLMSSP_OID_LEN))\n\t\t\t\t\tserver->sec_ntlmssp = true;\n\n\t\t\t\tkfree(oid);\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Should be an oid what is going on?\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * We currently ignore anything at the end of the SPNEGO blob after\n\t * the mechTypes have been parsed, since none of that info is\n\t * used at the moment.\n\t */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->server_GUID",
            "guid",
            "SMB1_CLIENT_GUID_SIZE"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->server_GUID",
            "guid",
            "SMB1_CLIENT_GUID_SIZE"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"server UID changed\\n\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "server->server_GUID",
            "guid",
            "SMB1_CLIENT_GUID_SIZE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMBr->hdr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\n{\n\tint\trc = 0;\n\tu16\tcount;\n\tchar\t*guid = pSMBr->u.extended_response.GUID;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcount = get_bcc(&pSMBr->hdr);\n\tif (count < SMB1_CLIENT_GUID_SIZE)\n\t\treturn -EIO;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (server->srv_count > 1) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\n\t\t\tcifs_dbg(FYI, \"server UID changed\\n\");\n\t\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t\t}\n\t} else {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t}\n\n\tif (count == SMB1_CLIENT_GUID_SIZE) {\n\t\tserver->sec_ntlmssp = true;\n\t} else {\n\t\tcount -= SMB1_CLIENT_GUID_SIZE;\n\t\trc = decode_negTokenInit(\n\t\t\tpSMBr->u.extended_response.SecurityBlob, count, server);\n\t\tif (rc != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "validate_t2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "334-364",
    "snippet": "static int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dump_mem",
          "args": [
            "\"Invalid transact2 SMB: \"",
            "(char *)pSMB",
            "sizeof(struct smb_t2_rsp) + 16"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dump_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "34-40",
          "snippet": "void\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "&pSMB->hdr"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMB->t2_rsp.DataCount"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMB->t2_rsp.ParameterCount"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMB->t2_rsp.DataOffset"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMB->t2_rsp.ParameterOffset"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "smb_init_no_reconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "324-332",
    "snippet": "static int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__smb_init",
          "args": [
            "smb_command",
            "wct",
            "tcon",
            "request_buf",
            "response_buf"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__smb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "285-308",
          "snippet": "static int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}"
  },
  {
    "function_name": "smb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "311-322",
    "snippet": "static int\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t void **request_buf, void **response_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__smb_init",
          "args": [
            "smb_command",
            "wct",
            "tcon",
            "request_buf",
            "response_buf"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__smb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "285-308",
          "snippet": "static int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reconnect_tcon",
          "args": [
            "tcon",
            "smb_command"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "115-228",
          "snippet": "static int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t void **request_buf, void **response_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}"
  },
  {
    "function_name": "__smb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "285-308",
    "snippet": "static int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->num_smbs_sent"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header_assemble",
          "args": [
            "(struct smb_hdr *) *request_buf",
            "smb_command",
            "tcon",
            "wct"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "header_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "240-287",
          "snippet": "void\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_get",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "146-178",
          "snippet": "struct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "small_smb_init_no_tc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "258-282",
    "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "ses->server"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small_smb_init",
          "args": [
            "smb_command",
            "wct",
            "NULL",
            "request_buf"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "small_smb_init_no_tc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "258-282",
          "snippet": "int\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "small_smb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "233-256",
    "snippet": "static int\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command,\n\t\t\ttcon, wct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->num_smbs_sent"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header_assemble",
          "args": [
            "(struct smb_hdr *) *request_buf",
            "smb_command",
            "tcon",
            "wct"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "header_assemble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "240-287",
          "snippet": "void\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_get",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "193-213",
          "snippet": "struct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nstruct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_reconnect_tcon",
          "args": [
            "tcon",
            "smb_command"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "115-228",
          "snippet": "static int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command,\n\t\t\ttcon, wct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_reconnect_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "115-228",
    "snippet": "static int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "nls_codepage"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_cifs_unix_caps",
          "args": [
            "0",
            "tcon",
            "NULL",
            "NULL"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "reset_cifs_unix_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3072-3170",
          "snippet": "void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tconInfoReconnectCount"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"reconnect tcon rc = %d\\n\"",
            "rc"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSTCon",
          "args": [
            "0",
            "ses",
            "tcon->treeName",
            "tcon",
            "nls_codepage"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSTCon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3637-3791",
          "snippet": "int\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->sectype == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->sectype == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_mark_open_files_invalid",
          "args": [
            "tcon"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_mark_open_files_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "93-112",
          "snippet": "void\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setup_session",
          "args": [
            "0",
            "ses",
            "nls_codepage"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3855-3876",
          "snippet": "int\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_negotiate_protocol",
          "args": [
            "0",
            "ses"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_negotiate_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3827-3853",
          "snippet": "int\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->session_mutex"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"gave up waiting on reconnect in smb_init\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "server->response_q",
            "(server->tcpStatus != CifsNeedReconnect)",
            "10 * HZ"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"can not send cmd %d while umounting\\n\"",
            "smb_command"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_mark_open_files_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
    "lines": "93-112",
    "snippet": "void\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifsFileInfo",
            "tlist"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "tmp",
            "tmp1",
            "&tcon->openFileList"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/*\n\t * BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t * to this tcon.\n\t */\n}"
  }
]