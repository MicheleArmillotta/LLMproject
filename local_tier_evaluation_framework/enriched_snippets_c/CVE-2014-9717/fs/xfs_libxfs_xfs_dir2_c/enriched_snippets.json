[
  {
    "function_name": "xfs_dir2_shrink_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "657-731",
    "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "bno"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno > 0"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno == 0"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_before",
          "args": [
            "tp",
            "dp",
            "&bno",
            "XFS_DATA_FORK"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1555-1596",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_byte",
          "args": [
            "args->geo",
            "db + 1",
            "0"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "249-254",
          "snippet": "static inline xfs_dir2_off_t\nxfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\txfs_dir2_data_aoff_t o)\n{\n\treturn ((xfs_dir2_off_t)db << geo->blklog) + o;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_off_t\nxfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\txfs_dir2_data_aoff_t o)\n{\n\treturn ((xfs_dir2_off_t)db << geo->blklog) + o;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_LEAF_OFFSET"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "bp"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "done"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "tp",
            "dp",
            "da",
            "args->geo->fsbcount",
            "XFS_BMAPI_METADATA",
            "0",
            "args->firstblock",
            "args->flist",
            "&done"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "db"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_shrink_inode",
          "args": [
            "args",
            "db"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_isleaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "638-650",
    "snippet": "int\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_last_offset",
          "args": [
            "args->dp",
            "&last",
            "XFS_DATA_FORK"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1671-1696",
          "snippet": "int\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_isblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "619-633",
    "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rval == 0 || args->dp->i_d.di_size == args->geo->blksize"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "args->dp->i_mount",
            "last"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_offset",
          "args": [
            "args->dp",
            "&last",
            "XFS_DATA_FORK"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1671-1696",
          "snippet": "int\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_grow_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "575-614",
    "snippet": "int\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "bno + count"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "args->geo",
            "(xfs_dablk_t)bno"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode_int",
          "args": [
            "args",
            "&bno",
            "count"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1994-2078",
          "snippet": "int\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "space * XFS_DIR2_SPACE_SIZE"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_grow_inode",
          "args": [
            "args",
            "space"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir_canenter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "556-563",
    "snippet": "int\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir_createname",
          "args": [
            "tp",
            "dp",
            "name",
            "0",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_createname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "255-321",
          "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}"
  },
  {
    "function_name": "xfs_dir_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "491-551",
    "snippet": "int\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_replace",
          "args": [
            "args"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "2125-2206",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry changed */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* btree level */\n\txfs_ino_t\t\tinum;\t\t/* new inode number */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry being changed */\n\tint\t\t\trval;\t\t/* internal return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_replace(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\tinum = args->inumber;\n\t/*\n\t * Lookup the entry to change in the btree.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error) {\n\t\trval = error;\n\t}\n\t/*\n\t * It should be found, since the vnodeops layer has looked it up\n\t * and locked it.  But paranoia is good.\n\t */\n\tif (rval == -EEXIST) {\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\t\t/*\n\t\t * Find the leaf entry.\n\t\t */\n\t\tblk = &state->path.blk[state->path.active - 1];\n\t\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t\tleaf = blk->bp->b_addr;\n\t\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\t\tlep = &ents[blk->index];\n\t\tASSERT(state->extravalid);\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\thdr = state->extrablk.bp->b_addr;\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t      ((char *)hdr +\n\t\t       xfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address)));\n\t\tASSERT(inum != be64_to_cpu(dep->inumber));\n\t\t/*\n\t\t * Fill in the new inode number and log the entry.\n\t\t */\n\t\tdep->inumber = cpu_to_be64(inum);\n\t\targs->dp->d_ops->data_put_ftype(dep, args->filetype);\n\t\txfs_dir2_data_log_entry(args, state->extrablk.bp, dep);\n\t\trval = 0;\n\t}\n\t/*\n\t * Didn't find it, and we're holding a data block.  Drop it.\n\t */\n\telse if (state->extravalid) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\t/*\n\t * Release all the buffers in the cursor.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry changed */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* btree level */\n\txfs_ino_t\t\tinum;\t\t/* new inode number */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry being changed */\n\tint\t\t\trval;\t\t/* internal return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_replace(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\tinum = args->inumber;\n\t/*\n\t * Lookup the entry to change in the btree.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error) {\n\t\trval = error;\n\t}\n\t/*\n\t * It should be found, since the vnodeops layer has looked it up\n\t * and locked it.  But paranoia is good.\n\t */\n\tif (rval == -EEXIST) {\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\t\t/*\n\t\t * Find the leaf entry.\n\t\t */\n\t\tblk = &state->path.blk[state->path.active - 1];\n\t\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t\tleaf = blk->bp->b_addr;\n\t\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\t\tlep = &ents[blk->index];\n\t\tASSERT(state->extravalid);\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\thdr = state->extrablk.bp->b_addr;\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t      ((char *)hdr +\n\t\t       xfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address)));\n\t\tASSERT(inum != be64_to_cpu(dep->inumber));\n\t\t/*\n\t\t * Fill in the new inode number and log the entry.\n\t\t */\n\t\tdep->inumber = cpu_to_be64(inum);\n\t\targs->dp->d_ops->data_put_ftype(dep, args->filetype);\n\t\txfs_dir2_data_log_entry(args, state->extrablk.bp, dep);\n\t\trval = 0;\n\t}\n\t/*\n\t * Didn't find it, and we're holding a data block.  Drop it.\n\t */\n\telse if (state->extravalid) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\t/*\n\t * Release all the buffers in the cursor.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_replace",
          "args": [
            "args"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1480-1527",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index of leaf entry */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_replace(args);\n\n\t/*\n\t * Look up the entry.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, get data address from it.\n\t */\n\tlep = &ents[index];\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tASSERT(args->inumber != be64_to_cpu(dep->inumber));\n\t/*\n\t * Put the new inode number in, log it.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttp = args->trans;\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index of leaf entry */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_replace(args);\n\n\t/*\n\t * Look up the entry.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, get data address from it.\n\t */\n\tlep = &ents[index];\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tASSERT(args->inumber != be64_to_cpu(dep->inumber));\n\t/*\n\t * Put the new inode number in, log it.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttp = args->trans;\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isleaf",
          "args": [
            "args",
            "&v"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isleaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "638-650",
          "snippet": "int\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_replace",
          "args": [
            "args"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "834-875",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isblock",
          "args": [
            "args",
            "&v"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "619-633",
          "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_replace",
          "args": [
            "args"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "868-991",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\txfs_ino_t\t\tino=0;\t\t/* entry old inode number */\n\tint\t\t\ti8elevated;\t/* sf_toino8 set i8count=1 */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_replace(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the shortform directory is way too small.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * New inode number is large, and need to convert to 8-byte inodes.\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\tint\terror;\t\t\t/* error return value */\n\t\tint\tnewsize;\t\t/* new inode size */\n\n\t\tnewsize =\n\t\t\tdp->i_df.if_bytes +\n\t\t\t(sfp->count + 1) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\t/*\n\t\t * Won't fit as shortform, convert to block then do replace.\n\t\t */\n\t\tif (newsize > XFS_IFORK_DSIZE(dp)) {\n\t\t\terror = xfs_dir2_sf_to_block(args);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\treturn xfs_dir2_block_replace(args);\n\t\t}\n\t\t/*\n\t\t * Still fits, convert to 8-byte now.\n\t\t */\n\t\txfs_dir2_sf_toino8(args);\n\t\ti8elevated = 1;\n\t\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t} else\n\t\ti8elevated = 0;\n\n\tASSERT(args->namelen != 1 || args->name[0] != '.');\n\t/*\n\t * Replace ..'s entry.\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tASSERT(args->inumber != ino);\n\t\tdp->d_ops->sf_put_parent_ino(sfp, args->inumber);\n\t}\n\t/*\n\t * Normal entry, look for the name.\n\t */\n\telse {\n\t\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\t\tASSERT(args->inumber != ino);\n\t\t\t\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\t\t\t\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Didn't find it.\n\t\t */\n\t\tif (i == sfp->count) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\tif (i8elevated)\n\t\t\t\txfs_dir2_sf_toino4(args);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * See if the old number was large, the new number is small.\n\t */\n\tif (ino > XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber <= XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * And the old count was one, so need to convert to small.\n\t\t */\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\t/*\n\t * See if the old number was small, the new number is large.\n\t */\n\tif (ino <= XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * add to the i8count unless we just converted to 8-byte\n\t\t * inodes (which does an implied i8count = 1)\n\t\t */\n\t\tASSERT(sfp->i8count != 0);\n\t\tif (!i8elevated)\n\t\t\tsfp->i8count++;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_DDATA);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\txfs_ino_t\t\tino=0;\t\t/* entry old inode number */\n\tint\t\t\ti8elevated;\t/* sf_toino8 set i8count=1 */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_replace(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the shortform directory is way too small.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * New inode number is large, and need to convert to 8-byte inodes.\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\tint\terror;\t\t\t/* error return value */\n\t\tint\tnewsize;\t\t/* new inode size */\n\n\t\tnewsize =\n\t\t\tdp->i_df.if_bytes +\n\t\t\t(sfp->count + 1) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\t/*\n\t\t * Won't fit as shortform, convert to block then do replace.\n\t\t */\n\t\tif (newsize > XFS_IFORK_DSIZE(dp)) {\n\t\t\terror = xfs_dir2_sf_to_block(args);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\treturn xfs_dir2_block_replace(args);\n\t\t}\n\t\t/*\n\t\t * Still fits, convert to 8-byte now.\n\t\t */\n\t\txfs_dir2_sf_toino8(args);\n\t\ti8elevated = 1;\n\t\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t} else\n\t\ti8elevated = 0;\n\n\tASSERT(args->namelen != 1 || args->name[0] != '.');\n\t/*\n\t * Replace ..'s entry.\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tASSERT(args->inumber != ino);\n\t\tdp->d_ops->sf_put_parent_ino(sfp, args->inumber);\n\t}\n\t/*\n\t * Normal entry, look for the name.\n\t */\n\telse {\n\t\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\t\tASSERT(args->inumber != ino);\n\t\t\t\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\t\t\t\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Didn't find it.\n\t\t */\n\t\tif (i == sfp->count) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\tif (i8elevated)\n\t\t\t\txfs_dir2_sf_toino4(args);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * See if the old number was large, the new number is small.\n\t */\n\tif (ino > XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber <= XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * And the old count was one, so need to convert to small.\n\t\t */\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\t/*\n\t * See if the old number was small, the new number is large.\n\t */\n\tif (ino <= XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * add to the i8count unless we just converted to 8-byte\n\t\t * inodes (which does an implied i8count = 1)\n\t\t */\n\t\tASSERT(sfp->i8count != 0);\n\t\tif (!i8elevated)\n\t\t\tsfp->i8count++;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_DDATA);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->i_mount->m_dirnameops->hashname",
          "args": [
            "name"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*args)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_ino_validate",
          "args": [
            "tp->t_mountp",
            "inum"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ino_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "191-220",
          "snippet": "int\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_replace(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\t\t/* name of entry to replace */\n\txfs_ino_t\tinum,\t\t/* new inode number */\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\n\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\tif (rval)\n\t\treturn rval;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_replace(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_replace(args);\n\telse\n\t\trval = xfs_dir2_node_replace(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "429-486",
    "snippet": "int\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_removename",
          "args": [
            "args"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "2063-2120",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_removename(\n\tstruct xfs_da_args\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_da_state_blk\t*blk;\t\t/* leaf block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* operation return value */\n\tstruct xfs_da_state\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_removename(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/* Look up the entry we're deleting, set up the cursor. */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\tgoto out_free;\n\n\t/* Didn't find it, upper layer screwed up. */\n\tif (rval != -EEXIST) {\n\t\terror = rval;\n\t\tgoto out_free;\n\t}\n\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(state->extravalid);\n\t/*\n\t * Remove the leaf and data entries.\n\t * Extrablk refers to the data block.\n\t */\n\terror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\n\t\t&state->extrablk, &rval);\n\tif (error)\n\t\tgoto out_free;\n\t/*\n\t * Fix the hash values up the btree.\n\t */\n\txfs_da3_fixhashpath(state, &state->path);\n\t/*\n\t * If we need to join leaf blocks, do it.\n\t */\n\tif (rval && state->path.active > 1)\n\t\terror = xfs_da3_join(state);\n\t/*\n\t * If no errors so far, try conversion to leaf format.\n\t */\n\tif (!error)\n\t\terror = xfs_dir2_node_to_leaf(state);\nout_free:\n\txfs_da_state_free(state);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_removename(\n\tstruct xfs_da_args\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_da_state_blk\t*blk;\t\t/* leaf block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* operation return value */\n\tstruct xfs_da_state\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_removename(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/* Look up the entry we're deleting, set up the cursor. */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\tgoto out_free;\n\n\t/* Didn't find it, upper layer screwed up. */\n\tif (rval != -EEXIST) {\n\t\terror = rval;\n\t\tgoto out_free;\n\t}\n\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(state->extravalid);\n\t/*\n\t * Remove the leaf and data entries.\n\t * Extrablk refers to the data block.\n\t */\n\terror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\n\t\t&state->extrablk, &rval);\n\tif (error)\n\t\tgoto out_free;\n\t/*\n\t * Fix the hash values up the btree.\n\t */\n\txfs_da3_fixhashpath(state, &state->path);\n\t/*\n\t * If we need to join leaf blocks, do it.\n\t */\n\tif (rval && state->path.active > 1)\n\t\terror = xfs_da3_join(state);\n\t/*\n\t * If no errors so far, try conversion to leaf format.\n\t */\n\tif (!error)\n\t\terror = xfs_dir2_node_to_leaf(state);\nout_free:\n\txfs_da_state_free(state);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_removename",
          "args": [
            "args"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1336-1475",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_removename(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf block best freespace */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry structure */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_db_t\t\ti;\t\t/* temporary data block # */\n\tint\t\t\tindex;\t\t/* index into leaf entries */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_dir2_data_off_t\toldbest;\t/* old value of best free */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_removename(args);\n\n\t/*\n\t * Lookup the leaf entry, get the leaf and data blocks read in.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, use that to point to the data entry.\n\t */\n\tlep = &ents[index];\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\txfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tneedscan = needlog = 0;\n\toldbest = be16_to_cpu(bf[0].length);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tASSERT(be16_to_cpu(bestsp[db]) == oldbest);\n\t/*\n\t * Mark the former data entry unused.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * We just mark the leaf entry stale by putting a null in it.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, lbp, index, index);\n\n\t/*\n\t * Scan the freespace in the data block again if necessary,\n\t * log the data block header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the longest freespace in the data block has changed,\n\t * put the new value in the bests table and log that.\n\t */\n\tif (be16_to_cpu(bf[0].length) != oldbest) {\n\t\tbestsp[db] = bf[0].length;\n\t\txfs_dir3_leaf_log_bests(args, lbp, db, db);\n\t}\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the data block is now empty then get rid of the data block.\n\t */\n\tif (be16_to_cpu(bf[0].length) ==\n\t\t\targs->geo->blksize - dp->d_ops->data_entry_offset) {\n\t\tASSERT(db != args->geo->datablk);\n\t\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\t\t/*\n\t\t\t * Nope, can't get rid of it because it caused\n\t\t\t * allocation of a bmap btree block to do so.\n\t\t\t * Just go on, returning success, leaving the\n\t\t\t * empty block in place.\n\t\t\t */\n\t\t\tif (error == -ENOSPC && args->total == 0)\n\t\t\t\terror = 0;\n\t\t\txfs_dir3_leaf_check(dp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\tdbp = NULL;\n\t\t/*\n\t\t * If this is the last data block then compact the\n\t\t * bests table by getting rid of entries.\n\t\t */\n\t\tif (db == be32_to_cpu(ltp->bestcount) - 1) {\n\t\t\t/*\n\t\t\t * Look for the last active entry (i).\n\t\t\t */\n\t\t\tfor (i = db - 1; i > 0; i--) {\n\t\t\t\tif (bestsp[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy the table down so inactive entries at the\n\t\t\t * end are removed.\n\t\t\t */\n\t\t\tmemmove(&bestsp[db - i], bestsp,\n\t\t\t\t(be32_to_cpu(ltp->bestcount) - (db - i)) * sizeof(*bestsp));\n\t\t\tbe32_add_cpu(&ltp->bestcount, -(db - i));\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t} else\n\t\t\tbestsp[db] = cpu_to_be16(NULLDATAOFF);\n\t}\n\t/*\n\t * If the data block was not the first one, drop it.\n\t */\n\telse if (db != args->geo->datablk)\n\t\tdbp = NULL;\n\n\txfs_dir3_leaf_check(dp, lbp);\n\t/*\n\t * See if we can convert to block form.\n\t */\n\treturn xfs_dir2_leaf_to_block(args, lbp, dbp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_removename(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf block best freespace */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry structure */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_db_t\t\ti;\t\t/* temporary data block # */\n\tint\t\t\tindex;\t\t/* index into leaf entries */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_dir2_data_off_t\toldbest;\t/* old value of best free */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_removename(args);\n\n\t/*\n\t * Lookup the leaf entry, get the leaf and data blocks read in.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, use that to point to the data entry.\n\t */\n\tlep = &ents[index];\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\txfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tneedscan = needlog = 0;\n\toldbest = be16_to_cpu(bf[0].length);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tASSERT(be16_to_cpu(bestsp[db]) == oldbest);\n\t/*\n\t * Mark the former data entry unused.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * We just mark the leaf entry stale by putting a null in it.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, lbp, index, index);\n\n\t/*\n\t * Scan the freespace in the data block again if necessary,\n\t * log the data block header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the longest freespace in the data block has changed,\n\t * put the new value in the bests table and log that.\n\t */\n\tif (be16_to_cpu(bf[0].length) != oldbest) {\n\t\tbestsp[db] = bf[0].length;\n\t\txfs_dir3_leaf_log_bests(args, lbp, db, db);\n\t}\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the data block is now empty then get rid of the data block.\n\t */\n\tif (be16_to_cpu(bf[0].length) ==\n\t\t\targs->geo->blksize - dp->d_ops->data_entry_offset) {\n\t\tASSERT(db != args->geo->datablk);\n\t\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\t\t/*\n\t\t\t * Nope, can't get rid of it because it caused\n\t\t\t * allocation of a bmap btree block to do so.\n\t\t\t * Just go on, returning success, leaving the\n\t\t\t * empty block in place.\n\t\t\t */\n\t\t\tif (error == -ENOSPC && args->total == 0)\n\t\t\t\terror = 0;\n\t\t\txfs_dir3_leaf_check(dp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\tdbp = NULL;\n\t\t/*\n\t\t * If this is the last data block then compact the\n\t\t * bests table by getting rid of entries.\n\t\t */\n\t\tif (db == be32_to_cpu(ltp->bestcount) - 1) {\n\t\t\t/*\n\t\t\t * Look for the last active entry (i).\n\t\t\t */\n\t\t\tfor (i = db - 1; i > 0; i--) {\n\t\t\t\tif (bestsp[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy the table down so inactive entries at the\n\t\t\t * end are removed.\n\t\t\t */\n\t\t\tmemmove(&bestsp[db - i], bestsp,\n\t\t\t\t(be32_to_cpu(ltp->bestcount) - (db - i)) * sizeof(*bestsp));\n\t\t\tbe32_add_cpu(&ltp->bestcount, -(db - i));\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t} else\n\t\t\tbestsp[db] = cpu_to_be16(NULLDATAOFF);\n\t}\n\t/*\n\t * If the data block was not the first one, drop it.\n\t */\n\telse if (db != args->geo->datablk)\n\t\tdbp = NULL;\n\n\txfs_dir3_leaf_check(dp, lbp);\n\t/*\n\t * See if we can convert to block form.\n\t */\n\treturn xfs_dir2_leaf_to_block(args, lbp, dbp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isleaf",
          "args": [
            "args",
            "&v"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isleaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "638-650",
          "snippet": "int\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_removename",
          "args": [
            "args"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "754-828",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_removename(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf pointer */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* block leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to fixup bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* shortform size */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\ttrace_xfs_dir2_block_removename(args);\n\n\t/*\n\t * Look up the entry in the block.  Gets the buffer and entry index.\n\t * It will always be there, the vnodeops level does a lookup first.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\ttp = args->trans;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry using the leaf entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Mark the data entry's space free.\n\t */\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Fix up the block tail.\n\t */\n\tbe32_add_cpu(&btp->stale, 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\t/*\n\t * Remove the leaf entry by marking it stale.\n\t */\n\tblp[ent].address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir2_block_log_leaf(tp, bp, ent, ent);\n\t/*\n\t * Fix up bestfree, log the header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * See if the size as a shortform is good enough.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\t/*\n\t * If it works, do the conversion.\n\t */\n\treturn xfs_dir2_block_to_sf(args, bp, size, &sfh);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_removename(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf pointer */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* block leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to fixup bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* shortform size */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\ttrace_xfs_dir2_block_removename(args);\n\n\t/*\n\t * Look up the entry in the block.  Gets the buffer and entry index.\n\t * It will always be there, the vnodeops level does a lookup first.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\ttp = args->trans;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry using the leaf entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Mark the data entry's space free.\n\t */\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Fix up the block tail.\n\t */\n\tbe32_add_cpu(&btp->stale, 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\t/*\n\t * Remove the leaf entry by marking it stale.\n\t */\n\tblp[ent].address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir2_block_log_leaf(tp, bp, ent, ent);\n\t/*\n\t * Fix up bestfree, log the header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * See if the size as a shortform is good enough.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\t/*\n\t * If it works, do the conversion.\n\t */\n\treturn xfs_dir2_block_to_sf(args, bp, size, &sfh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isblock",
          "args": [
            "args",
            "&v"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "619-633",
          "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_removename",
          "args": [
            "args"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "781-863",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_removename(\n\txfs_da_args_t\t\t*args)\n{\n\tint\t\t\tbyteoff;\t/* offset of removed entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tentsize;\t/* this entry's size */\n\tint\t\t\ti;\t\t/* shortform entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_removename(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\toldsize = (int)dp->i_d.di_size;\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (oldsize < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == oldsize);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsize >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Loop over the old directory entries.\n\t * Find the one we're deleting.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\tASSERT(dp->d_ops->sf_get_ino(sfp, sfep) ==\n\t\t\t       args->inumber);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find it.\n\t */\n\tif (i == sfp->count)\n\t\treturn -ENOENT;\n\t/*\n\t * Calculate sizes.\n\t */\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\tentsize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tnewsize = oldsize - entsize;\n\t/*\n\t * Copy the part if any after the removed entry, sliding it down.\n\t */\n\tif (byteoff + entsize < oldsize)\n\t\tmemmove((char *)sfp + byteoff, (char *)sfp + byteoff + entsize,\n\t\t\toldsize - (byteoff + entsize));\n\t/*\n\t * Fix up the header and file size.\n\t */\n\tsfp->count--;\n\tdp->i_d.di_size = newsize;\n\t/*\n\t * Reallocate, making it smaller.\n\t */\n\txfs_idata_realloc(dp, newsize - oldsize, XFS_DATA_FORK);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Are we changing inode number size?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_removename(\n\txfs_da_args_t\t\t*args)\n{\n\tint\t\t\tbyteoff;\t/* offset of removed entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tentsize;\t/* this entry's size */\n\tint\t\t\ti;\t\t/* shortform entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_removename(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\toldsize = (int)dp->i_d.di_size;\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (oldsize < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == oldsize);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsize >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Loop over the old directory entries.\n\t * Find the one we're deleting.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\tASSERT(dp->d_ops->sf_get_ino(sfp, sfep) ==\n\t\t\t       args->inumber);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find it.\n\t */\n\tif (i == sfp->count)\n\t\treturn -ENOENT;\n\t/*\n\t * Calculate sizes.\n\t */\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\tentsize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tnewsize = oldsize - entsize;\n\t/*\n\t * Copy the part if any after the removed entry, sliding it down.\n\t */\n\tif (byteoff + entsize < oldsize)\n\t\tmemmove((char *)sfp + byteoff, (char *)sfp + byteoff + entsize,\n\t\t\toldsize - (byteoff + entsize));\n\t/*\n\t * Fix up the header and file size.\n\t */\n\tsfp->count--;\n\tdp->i_d.di_size = newsize;\n\t/*\n\t * Reallocate, making it smaller.\n\t */\n\txfs_idata_realloc(dp, newsize - oldsize, XFS_DATA_FORK);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Are we changing inode number size?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->i_mount->m_dirnameops->hashname",
          "args": [
            "name"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*args)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_dir_remove"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_removename(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\tino,\n\txfs_fsblock_t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_remove);\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = ino;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_removename(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_removename(args);\n\telse\n\t\trval = xfs_dir2_node_removename(args);\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "354-424",
    "snippet": "int\nxfs_dir_lookup(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\t*inum,\t\t/* out: inode number */\n\tstruct xfs_name *ci_name)\t/* out: actual name if CI match */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_lookup);\n\n\t/*\n\t * We need to use KM_NOFS here so that lockdep will not throw false\n\t * positive deadlock warnings on a non-transactional lookup path. It is\n\t * safe to recurse into inode recalim in that case, but lockdep can't\n\t * easily be taught about it. Hence KM_NOFS avoids having to add more\n\t * lockdep Doing this avoids having to add a bunch of lockdep class\n\t * annotations into the reclaim path for the ilock.\n\t */\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->dp = dp;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\tif (ci_name)\n\t\targs->op_flags |= XFS_DA_OP_CILOOKUP;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_lookup(args);\n\telse\n\t\trval = xfs_dir2_node_lookup(args);\n\nout_check_rval:\n\tif (rval == -EEXIST)\n\t\trval = 0;\n\tif (!rval) {\n\t\t*inum = args->inumber;\n\t\tif (ci_name) {\n\t\t\tci_name->name = args->value;\n\t\t\tci_name->len = args->valuelen;\n\t\t}\n\t}\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_lookup",
          "args": [
            "args"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "2010-2058",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_lookup(\n\txfs_da_args_t\t*args)\t\t\t/* operation arguments */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\ti;\t\t\t/* btree level */\n\tint\t\trval;\t\t\t/* operation return value */\n\txfs_da_state_t\t*state;\t\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Fill in the path to the entry in the cursor.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t/* If a CI match, dup the actual name and return -EEXIST */\n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t/*\n\t * Release the btree blocks and leaf block.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t/*\n\t * Release the data block if we have it.\n\t */\n\tif (state->extravalid && state->extrablk.bp) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_lookup(\n\txfs_da_args_t\t*args)\t\t\t/* operation arguments */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\ti;\t\t\t/* btree level */\n\tint\t\trval;\t\t\t/* operation return value */\n\txfs_da_state_t\t*state;\t\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Fill in the path to the entry in the cursor.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t/* If a CI match, dup the actual name and return -EEXIST */\n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t/*\n\t * Release the btree blocks and leaf block.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t/*\n\t * Release the data block if we have it.\n\t */\n\tif (state->extravalid && state->extrablk.bp) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_lookup",
          "args": [
            "args"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1148-1196",
          "snippet": "int\nxfs_dir2_leaf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* found entry index */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_lookup(args);\n\n\t/*\n\t * Look up name in the leaf block, returning both buffers and index.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\ttp = args->trans;\n\tdp = args->dp;\n\txfs_dir3_leaf_check(dp, lbp);\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Get to the leaf entry and contained data entry address.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\t/*\n\t * Return the found inode number & CI name if appropriate\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_leaf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* found entry index */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_lookup(args);\n\n\t/*\n\t * Look up name in the leaf block, returning both buffers and index.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\ttp = args->trans;\n\tdp = args->dp;\n\txfs_dir3_leaf_check(dp, lbp);\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Get to the leaf entry and contained data entry address.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\t/*\n\t * Return the found inode number & CI name if appropriate\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isleaf",
          "args": [
            "args",
            "&v"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isleaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "638-650",
          "snippet": "int\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_lookup",
          "args": [
            "args"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "604-644",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* dir lookup arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_lookup(args);\n\n\t/*\n\t * Get the buffer, look up the entry.\n\t * If not found (ENOENT) then return, have no buffer.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent)))\n\t\treturn error;\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Get the offset from the leaf entry, to point to the data.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Fill in inode number, CI name if appropriate, release the block.\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* dir lookup arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_lookup(args);\n\n\t/*\n\t * Get the buffer, look up the entry.\n\t * If not found (ENOENT) then return, have no buffer.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent)))\n\t\treturn error;\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Get the offset from the leaf entry, to point to the data.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Fill in inode number, CI name if appropriate, release the block.\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isblock",
          "args": [
            "args",
            "&v"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "619-633",
          "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_lookup",
          "args": [
            "args"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "696-776",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->i_mount->m_dirnameops->hashname",
          "args": [
            "name"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*args)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_dir_lookup"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_lookup(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name,\n\txfs_ino_t\t*inum,\t\t/* out: inode number */\n\tstruct xfs_name *ci_name)\t/* out: actual name if CI match */\n{\n\tstruct xfs_da_args *args;\n\tint\t\trval;\n\tint\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_lookup);\n\n\t/*\n\t * We need to use KM_NOFS here so that lockdep will not throw false\n\t * positive deadlock warnings on a non-transactional lookup path. It is\n\t * safe to recurse into inode recalim in that case, but lockdep can't\n\t * easily be taught about it. Hence KM_NOFS avoids having to add more\n\t * lockdep Doing this avoids having to add a bunch of lockdep class\n\t * annotations into the reclaim path for the ilock.\n\t */\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->dp = dp;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_OKNOENT;\n\tif (ci_name)\n\t\targs->op_flags |= XFS_DA_OP_CILOOKUP;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_lookup(args);\n\t\tgoto out_check_rval;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_lookup(args);\n\telse\n\t\trval = xfs_dir2_node_lookup(args);\n\nout_check_rval:\n\tif (rval == -EEXIST)\n\t\trval = 0;\n\tif (!rval) {\n\t\t*inum = args->inumber;\n\t\tif (ci_name) {\n\t\t\tci_name->name = args->value;\n\t\t\tci_name->len = args->valuelen;\n\t\t}\n\t}\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir_cilookup_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "327-346",
    "snippet": "int\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args->value",
            "name",
            "len"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "len",
            "KM_NOFS | KM_MAYFAIL"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}"
  },
  {
    "function_name": "xfs_dir_createname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "255-321",
    "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_addname",
          "args": [
            "args"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1566-1630",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_addname",
          "args": [
            "args"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "601-901",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isleaf",
          "args": [
            "args",
            "&v"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isleaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "638-650",
          "snippet": "int\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isleaf(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\t*vp = last == args->geo->leafblk + args->geo->fsbcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_addname",
          "args": [
            "args"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "330-562",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isblock",
          "args": [
            "args",
            "&v"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "619-633",
          "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_addname",
          "args": [
            "args"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "282-375",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tincr_isize;\t/* total change in size */\n\tint\t\t\tnew_isize;\t/* di_size after adding name */\n\tint\t\t\tobjchange;\t/* changing to 8-byte inodes */\n\txfs_dir2_data_aoff_t\toffset = 0;\t/* offset for new entry */\n\tint\t\t\tpick;\t\t/* which algorithm to use */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_sf_entry_t\t*sfep = NULL;\t/* shortform entry */\n\n\ttrace_xfs_dir2_sf_addname(args);\n\n\tASSERT(xfs_dir2_sf_lookup(args) == -ENOENT);\n\tdp = args->dp;\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Make sure the shortform value has some of its header.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Compute entry (and change in) size.\n\t */\n\tincr_isize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tobjchange = 0;\n\n\t/*\n\t * Do we have to change to 8 byte inodes?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\t/*\n\t\t * Yes, adjust the inode size.  old count + (parent + new)\n\t\t */\n\t\tincr_isize +=\n\t\t\t(sfp->count + 2) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\tobjchange = 1;\n\t}\n\n\tnew_isize = (int)dp->i_d.di_size + incr_isize;\n\t/*\n\t * Won't fit as shortform any more (due to size),\n\t * or the pick routine says it won't (due to offset values).\n\t */\n\tif (new_isize > XFS_IFORK_DSIZE(dp) ||\n\t    (pick =\n\t     xfs_dir2_sf_addname_pick(args, objchange, &sfep, &offset)) == 0) {\n\t\t/*\n\t\t * Just checking or no space reservation, it doesn't fit.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to block form then add the name.\n\t\t */\n\t\terror = xfs_dir2_sf_to_block(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_block_addname(args);\n\t}\n\t/*\n\t * Just checking, it fits.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\t/*\n\t * Do it the easy way - just add it at the end.\n\t */\n\tif (pick == 1)\n\t\txfs_dir2_sf_addname_easy(args, sfep, offset, new_isize);\n\t/*\n\t * Do it the hard way - look for a place to insert the new entry.\n\t * Convert to 8 byte inode numbers first if necessary.\n\t */\n\telse {\n\t\tASSERT(pick == 2);\n\t\tif (objchange)\n\t\t\txfs_dir2_sf_toino8(args);\n\t\txfs_dir2_sf_addname_hard(args, objchange, new_isize);\n\t}\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tincr_isize;\t/* total change in size */\n\tint\t\t\tnew_isize;\t/* di_size after adding name */\n\tint\t\t\tobjchange;\t/* changing to 8-byte inodes */\n\txfs_dir2_data_aoff_t\toffset = 0;\t/* offset for new entry */\n\tint\t\t\tpick;\t\t/* which algorithm to use */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_sf_entry_t\t*sfep = NULL;\t/* shortform entry */\n\n\ttrace_xfs_dir2_sf_addname(args);\n\n\tASSERT(xfs_dir2_sf_lookup(args) == -ENOENT);\n\tdp = args->dp;\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Make sure the shortform value has some of its header.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Compute entry (and change in) size.\n\t */\n\tincr_isize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tobjchange = 0;\n\n\t/*\n\t * Do we have to change to 8 byte inodes?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\t/*\n\t\t * Yes, adjust the inode size.  old count + (parent + new)\n\t\t */\n\t\tincr_isize +=\n\t\t\t(sfp->count + 2) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\tobjchange = 1;\n\t}\n\n\tnew_isize = (int)dp->i_d.di_size + incr_isize;\n\t/*\n\t * Won't fit as shortform any more (due to size),\n\t * or the pick routine says it won't (due to offset values).\n\t */\n\tif (new_isize > XFS_IFORK_DSIZE(dp) ||\n\t    (pick =\n\t     xfs_dir2_sf_addname_pick(args, objchange, &sfep, &offset)) == 0) {\n\t\t/*\n\t\t * Just checking or no space reservation, it doesn't fit.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to block form then add the name.\n\t\t */\n\t\terror = xfs_dir2_sf_to_block(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_block_addname(args);\n\t}\n\t/*\n\t * Just checking, it fits.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\t/*\n\t * Do it the easy way - just add it at the end.\n\t */\n\tif (pick == 1)\n\t\txfs_dir2_sf_addname_easy(args, sfep, offset, new_isize);\n\t/*\n\t * Do it the hard way - look for a place to insert the new entry.\n\t * Convert to 8 byte inode numbers first if necessary.\n\t */\n\telse {\n\t\tASSERT(pick == 2);\n\t\tif (objchange)\n\t\t\txfs_dir2_sf_toino8(args);\n\t\txfs_dir2_sf_addname_hard(args, objchange, new_isize);\n\t}\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->i_mount->m_dirnameops->hashname",
          "args": [
            "name"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*args)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_dir_create"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_ino_validate",
          "args": [
            "tp->t_mountp",
            "inum"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ino_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "191-220",
          "snippet": "int\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "225-249",
    "snippet": "int\nxfs_dir_init(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\txfs_inode_t\t*pdp)\n{\n\tstruct xfs_da_args *args;\n\tint\t\terror;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\terror = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);\n\tif (error)\n\t\treturn error;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->dp = dp;\n\targs->trans = tp;\n\terror = xfs_dir2_sf_create(args, pdp->i_ino);\n\tkmem_free(args);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_create",
          "args": [
            "args",
            "pdp->i_ino"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "642-690",
          "snippet": "int\t\t\t\t\t/* error, always 0 */\nxfs_dir2_sf_create(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\txfs_ino_t\tpino)\t\t/* parent inode number */\n{\n\txfs_inode_t\t*dp;\t\t/* incore directory inode */\n\tint\t\ti8count;\t/* parent inode is an 8-byte number */\n\txfs_dir2_sf_hdr_t *sfp;\t\t/* shortform structure */\n\tint\t\tsize;\t\t/* directory size */\n\n\ttrace_xfs_dir2_sf_create(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_d.di_size == 0);\n\t/*\n\t * If it's currently a zero-length extent file,\n\t * convert it to local format.\n\t */\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_EXTENTS) {\n\t\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\tdp->i_df.if_flags |= XFS_IFINLINE;\n\t}\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\tASSERT(dp->i_df.if_bytes == 0);\n\ti8count = pino > XFS_DIR2_MAX_SHORT_INUM;\n\tsize = xfs_dir2_sf_hdr_size(i8count);\n\t/*\n\t * Make a buffer for the data.\n\t */\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\t/*\n\t * Fill in the header,\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfp->i8count = i8count;\n\t/*\n\t * Now can put in the inode number, since i8count is set.\n\t */\n\tdp->d_ops->sf_put_parent_ino(sfp, pino);\n\tsfp->count = 0;\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t/* error, always 0 */\nxfs_dir2_sf_create(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\txfs_ino_t\tpino)\t\t/* parent inode number */\n{\n\txfs_inode_t\t*dp;\t\t/* incore directory inode */\n\tint\t\ti8count;\t/* parent inode is an 8-byte number */\n\txfs_dir2_sf_hdr_t *sfp;\t\t/* shortform structure */\n\tint\t\tsize;\t\t/* directory size */\n\n\ttrace_xfs_dir2_sf_create(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_d.di_size == 0);\n\t/*\n\t * If it's currently a zero-length extent file,\n\t * convert it to local format.\n\t */\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_EXTENTS) {\n\t\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\tdp->i_df.if_flags |= XFS_IFINLINE;\n\t}\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\tASSERT(dp->i_df.if_bytes == 0);\n\ti8count = pino > XFS_DIR2_MAX_SHORT_INUM;\n\tsize = xfs_dir2_sf_hdr_size(i8count);\n\t/*\n\t * Make a buffer for the data.\n\t */\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\t/*\n\t * Fill in the header,\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfp->i8count = i8count;\n\t/*\n\t * Now can put in the inode number, since i8count is set.\n\t */\n\tdp->d_ops->sf_put_parent_ino(sfp, pino);\n\tsfp->count = 0;\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*args)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_ino_validate",
          "args": [
            "tp->t_mountp",
            "pdp->i_ino"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ino_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "191-220",
          "snippet": "int\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_init(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\txfs_inode_t\t*pdp)\n{\n\tstruct xfs_da_args *args;\n\tint\t\terror;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\terror = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);\n\tif (error)\n\t\treturn error;\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->dp = dp;\n\targs->trans = tp;\n\terror = xfs_dir2_sf_create(args, pdp->i_ino);\n\tkmem_free(args);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir_ino_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "191-220",
    "snippet": "int\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_dir_ino_validate\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Invalid inode number 0x%Lx\"",
            "(unsigned long long) ino"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!ino_ok",
            "mp",
            "XFS_ERRTAG_DIR_INO_VALIDATE",
            "XFS_RANDOM_DIR_INO_VALIDATE"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_OFFBNO_TO_AGINO",
          "args": [
            "mp",
            "agblkno",
            "ioff"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_OFFSET",
          "args": [
            "mp",
            "ino"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGBNO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir_isempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "173-186",
    "snippet": "int\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_isempty(\n\txfs_inode_t\t*dp)\n{\n\txfs_dir2_sf_hdr_t\t*sfp;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (dp->i_d.di_size == 0)\t/* might happen during shutdown. */\n\t\treturn 1;\n\tif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\treturn !sfp->count;\n}"
  },
  {
    "function_name": "xfs_da_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "162-168",
    "snippet": "void\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mp->m_attr_geo"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}"
  },
  {
    "function_name": "xfs_da_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "100-160",
    "snippet": "int\nxfs_da_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_da_geometry\t*dageo;\n\tint\t\t\tnodehdr_size;\n\n\n\tASSERT(mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT);\n\tASSERT((1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\n\t       XFS_MAX_BLOCKSIZE);\n\n\tmp->m_dir_inode_ops = xfs_dir_get_ops(mp, NULL);\n\tmp->m_nondir_inode_ops = xfs_nondir_get_ops(mp, NULL);\n\n\tnodehdr_size = mp->m_dir_inode_ops->node_hdr_size;\n\tmp->m_dir_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t    KM_SLEEP | KM_MAYFAIL);\n\tmp->m_attr_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t     KM_SLEEP | KM_MAYFAIL);\n\tif (!mp->m_dir_geo || !mp->m_attr_geo) {\n\t\tkmem_free(mp->m_dir_geo);\n\t\tkmem_free(mp->m_attr_geo);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set up directory geometry */\n\tdageo = mp->m_dir_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;\n\n\t/*\n\t * Now we've set up the block conversion variables, we can calculate the\n\t * segment block constants using the geometry structure.\n\t */\n\tdageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);\n\tdageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);\n\tdageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\t/* set up attribute geometry - single fsb only */\n\tdageo = mp->m_attr_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1;\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\tif (xfs_sb_version_hasasciici(&mp->m_sb))\n\t\tmp->m_dirnameops = &xfs_ascii_ci_nameops;\n\telse\n\t\tmp->m_dirnameops = &xfs_default_nameops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct xfs_nameops xfs_ascii_ci_nameops = {\n\t.hashname\t= xfs_ascii_ci_hashname,\n\t.compname\t= xfs_ascii_ci_compname,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hasasciici",
          "args": [
            "&mp->m_sb"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasasciici",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "427-430",
          "snippet": "static inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_da",
          "args": [
            "dageo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "268-272",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mp->m_attr_geo"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(struct xfs_da_geometry)",
            "KM_SLEEP | KM_MAYFAIL"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_nondir_get_ops",
          "args": [
            "mp",
            "NULL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_nondir_get_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.c",
          "lines": "896-908",
          "snippet": "const struct xfs_dir_ops *\nxfs_nondir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_nondir_inode_ops)\n\t\treturn mp->m_nondir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_nondir_ops;\n\treturn &xfs_dir2_nondir_ops;\n}",
          "includes": [
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_dir_ops xfs_dir2_nondir_ops = {\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n};",
            "static const struct xfs_dir_ops xfs_dir3_nondir_ops = {\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_dir_ops xfs_dir2_nondir_ops = {\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n};\nstatic const struct xfs_dir_ops xfs_dir3_nondir_ops = {\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n};\n\nconst struct xfs_dir_ops *\nxfs_nondir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_nondir_inode_ops)\n\t\treturn mp->m_nondir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_nondir_ops;\n\treturn &xfs_dir2_nondir_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_get_ops",
          "args": [
            "mp",
            "NULL"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_get_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.c",
          "lines": "880-894",
          "snippet": "const struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}",
          "includes": [
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};\n\nconst struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\n\t       XFS_MAX_BLOCKSIZE"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_nameops xfs_ascii_ci_nameops = {\n\t.hashname\t= xfs_ascii_ci_hashname,\n\t.compname\t= xfs_ascii_ci_compname,\n};\n\nint\nxfs_da_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_da_geometry\t*dageo;\n\tint\t\t\tnodehdr_size;\n\n\n\tASSERT(mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT);\n\tASSERT((1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\n\t       XFS_MAX_BLOCKSIZE);\n\n\tmp->m_dir_inode_ops = xfs_dir_get_ops(mp, NULL);\n\tmp->m_nondir_inode_ops = xfs_nondir_get_ops(mp, NULL);\n\n\tnodehdr_size = mp->m_dir_inode_ops->node_hdr_size;\n\tmp->m_dir_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t    KM_SLEEP | KM_MAYFAIL);\n\tmp->m_attr_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t     KM_SLEEP | KM_MAYFAIL);\n\tif (!mp->m_dir_geo || !mp->m_attr_geo) {\n\t\tkmem_free(mp->m_dir_geo);\n\t\tkmem_free(mp->m_attr_geo);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set up directory geometry */\n\tdageo = mp->m_dir_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;\n\n\t/*\n\t * Now we've set up the block conversion variables, we can calculate the\n\t * segment block constants using the geometry structure.\n\t */\n\tdageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);\n\tdageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);\n\tdageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\t/* set up attribute geometry - single fsb only */\n\tdageo = mp->m_attr_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1;\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\tif (xfs_sb_version_hasasciici(&mp->m_sb))\n\t\tmp->m_dirnameops = &xfs_ascii_ci_nameops;\n\telse\n\t\tmp->m_dirnameops = &xfs_default_nameops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ascii_ci_compname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "71-93",
    "snippet": "xfs_dacmp\nxfs_ascii_ci_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tenum xfs_dacmp\tresult;\n\tint\t\ti;\n\n\tif (args->namelen != len)\n\t\treturn XFS_CMP_DIFFERENT;\n\n\tresult = XFS_CMP_EXACT;\n\tfor (i = 0; i < len; i++) {\n\t\tif (args->name[i] == name[i])\n\t\t\tcontinue;\n\t\tif (tolower(args->name[i]) != tolower(name[i]))\n\t\t\treturn XFS_CMP_DIFFERENT;\n\t\tresult = XFS_CMP_CASE;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC enum"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "name[i]"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC enum;\n\nxfs_dacmp\nxfs_ascii_ci_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tenum xfs_dacmp\tresult;\n\tint\t\ti;\n\n\tif (args->namelen != len)\n\t\treturn XFS_CMP_DIFFERENT;\n\n\tresult = XFS_CMP_EXACT;\n\tfor (i = 0; i < len; i++) {\n\t\tif (args->name[i] == name[i])\n\t\t\tcontinue;\n\t\tif (tolower(args->name[i]) != tolower(name[i]))\n\t\t\treturn XFS_CMP_DIFFERENT;\n\t\tresult = XFS_CMP_CASE;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "xfs_ascii_ci_hashname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
    "lines": "58-69",
    "snippet": "STATIC xfs_dahash_t\nxfs_ascii_ci_hashname(\n\tstruct xfs_name\t*name)\n{\n\txfs_dahash_t\thash;\n\tint\t\ti;\n\n\tfor (i = 0, hash = 0; i < name->len; i++)\n\t\thash = tolower(name->name[i]) ^ rol32(hash, 7);\n\n\treturn hash;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "hash",
            "7"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "name->name[i]"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_dahash_t\nxfs_ascii_ci_hashname(\n\tstruct xfs_name\t*name)\n{\n\txfs_dahash_t\thash;\n\tint\t\ti;\n\n\tfor (i = 0, hash = 0; i < name->len; i++)\n\t\thash = tolower(name->name[i]) ^ rol32(hash, 7);\n\n\treturn hash;\n}"
  }
]