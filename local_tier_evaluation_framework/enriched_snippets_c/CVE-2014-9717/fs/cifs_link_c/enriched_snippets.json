[
  {
    "function_name": "cifs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "686-745",
    "snippet": "int\ncifs_symlink(struct inode *inode, struct dentry *direntry, const char *symname)\n{\n\tint rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\n\txid = get_xid();\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto symlink_exit;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s\\n\", full_path);\n\tcifs_dbg(FYI, \"symname is %s\\n\", symname);\n\n\t/* BB what if DFS and this volume is on different share? BB */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\trc = create_mf_symlink(xid, pTcon, cifs_sb, full_path, symname);\n\telse if (pTcon->unix_ext)\n\t\trc = CIFSUnixCreateSymLink(xid, pTcon, full_path, symname,\n\t\t\t\t\t   cifs_sb->local_nls);\n\t/* else\n\t   rc = CIFSCreateReparseSymLink(xid, pTcon, fromName, toName,\n\t\t\t\t\tcifs_sb_target->local_nls); */\n\n\tif (rc == 0) {\n\t\tif (pTcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&newinode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\n\t\tif (rc != 0) {\n\t\t\tcifs_dbg(FYI, \"Create symlink ok, getinodeinfo fail rc = %d\\n\",\n\t\t\t\t rc);\n\t\t} else {\n\t\t\td_instantiate(direntry, newinode);\n\t\t}\n\t}\nsymlink_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "direntry",
            "newinode"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Create symlink ok, getinodeinfo fail rc = %d\\n\"",
            "rc"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&newinode",
            "full_path",
            "NULL",
            "inode->i_sb",
            "xid",
            "NULL"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&newinode",
            "full_path",
            "inode->i_sb",
            "xid"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSUnixCreateSymLink",
          "args": [
            "xid",
            "pTcon",
            "full_path",
            "symname",
            "cifs_sb->local_nls"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSUnixCreateSymLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2784-2872",
          "snippet": "int\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Symlink Unix style\\n\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUTF16((__le16 *) pSMB->FileName, fromName,\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUTF16((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo create symlink = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Symlink Unix style\\n\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUTF16((__le16 *) pSMB->FileName, fromName,\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUTF16((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t    /* find define for this maxpathcomponent */\n\t\t\t\t    , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo create symlink = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_mf_symlink",
          "args": [
            "xid",
            "pTcon",
            "cifs_sb",
            "full_path",
            "symname"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "create_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "203-234",
          "snippet": "static int\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *fromName,\n\t\t  const char *toName)\n{\n\tint rc;\n\tu8 *buf;\n\tunsigned int bytes_written = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->ses->server->ops->create_mf_symlink)\n\t\trc = tcon->ses->server->ops->create_mf_symlink(xid, tcon,\n\t\t\t\t\tcifs_sb, fromName, buf, &bytes_written);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\trc = -EIO;\nout:\n\tkfree(buf);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nstatic int\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *fromName,\n\t\t  const char *toName)\n{\n\tint rc;\n\tu8 *buf;\n\tunsigned int bytes_written = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->ses->server->ops->create_mf_symlink)\n\t\trc = tcon->ses->server->ops->create_mf_symlink(xid, tcon,\n\t\t\t\t\tcifs_sb, fromName, buf, &bytes_written);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\trc = -EIO;\nout:\n\tkfree(buf);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"symname is %s\\n\"",
            "symname"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Full path: %s\\n\"",
            "full_path"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\ncifs_symlink(struct inode *inode, struct dentry *direntry, const char *symname)\n{\n\tint rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\n\txid = get_xid();\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto symlink_exit;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s\\n\", full_path);\n\tcifs_dbg(FYI, \"symname is %s\\n\", symname);\n\n\t/* BB what if DFS and this volume is on different share? BB */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\trc = create_mf_symlink(xid, pTcon, cifs_sb, full_path, symname);\n\telse if (pTcon->unix_ext)\n\t\trc = CIFSUnixCreateSymLink(xid, pTcon, full_path, symname,\n\t\t\t\t\t   cifs_sb->local_nls);\n\t/* else\n\t   rc = CIFSCreateReparseSymLink(xid, pTcon, fromName, toName,\n\t\t\t\t\tcifs_sb_target->local_nls); */\n\n\tif (rc == 0) {\n\t\tif (pTcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&newinode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\n\t\tif (rc != 0) {\n\t\t\tcifs_dbg(FYI, \"Create symlink ok, getinodeinfo fail rc = %d\\n\",\n\t\t\t\t rc);\n\t\t} else {\n\t\t\td_instantiate(direntry, newinode);\n\t\t}\n\t}\nsymlink_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "629-684",
    "snippet": "void *\ncifs_follow_link(struct dentry *direntry, struct nameidata *nd)\n{\n\tstruct inode *inode = direntry->d_inode;\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tchar *target_path = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\txid = get_xid();\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\ttlink = NULL;\n\t\tgoto out;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (!full_path)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\", full_path, inode);\n\n\trc = -EACCES;\n\t/*\n\t * First try Minshall+French Symlinks, if configured\n\t * and fallback to UNIX Extensions Symlinks.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\trc = query_mf_symlink(xid, tcon, cifs_sb, full_path,\n\t\t\t\t      &target_path);\n\n\tif (rc != 0 && server->ops->query_symlink)\n\t\trc = server->ops->query_symlink(xid, tcon, full_path,\n\t\t\t\t\t\t&target_path, cifs_sb);\n\n\tkfree(full_path);\nout:\n\tif (rc != 0) {\n\t\tkfree(target_path);\n\t\ttarget_path = ERR_PTR(rc);\n\t}\n\n\tfree_xid(xid);\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\tnd_set_link(nd, target_path);\n\treturn NULL;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "target_path"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "target_path"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->query_symlink",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "&target_path",
            "cifs_sb"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "query_mf_symlink",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path",
            "&target_path"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "query_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "236-268",
          "snippet": "static int\nquery_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t char **symlinkinfo)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) { /* not a symlink */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, symlinkinfo);\nout:\n\tkfree(buf);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nstatic int\nquery_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t char **symlinkinfo)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) { /* not a symlink */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, symlinkinfo);\nout:\n\tkfree(buf);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Full path: %s inode = 0x%p\\n\"",
            "full_path",
            "inode"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid *\ncifs_follow_link(struct dentry *direntry, struct nameidata *nd)\n{\n\tstruct inode *inode = direntry->d_inode;\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tchar *target_path = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\txid = get_xid();\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\ttlink = NULL;\n\t\tgoto out;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (!full_path)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\", full_path, inode);\n\n\trc = -EACCES;\n\t/*\n\t * First try Minshall+French Symlinks, if configured\n\t * and fallback to UNIX Extensions Symlinks.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\trc = query_mf_symlink(xid, tcon, cifs_sb, full_path,\n\t\t\t\t      &target_path);\n\n\tif (rc != 0 && server->ops->query_symlink)\n\t\trc = server->ops->query_symlink(xid, tcon, full_path,\n\t\t\t\t\t\t&target_path, cifs_sb);\n\n\tkfree(full_path);\nout:\n\tif (rc != 0) {\n\t\tkfree(target_path);\n\t\ttarget_path = ERR_PTR(rc);\n\t}\n\n\tfree_xid(xid);\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\tnd_set_link(nd, target_path);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cifs_hardlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "539-627",
    "snippet": "int\ncifs_hardlink(struct dentry *old_file, struct inode *inode,\n\t      struct dentry *direntry)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\tchar *from_name = NULL;\n\tchar *to_name = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cifsInode;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfrom_name = build_path_from_dentry(old_file);\n\tto_name = build_path_from_dentry(direntry);\n\tif ((from_name == NULL) || (to_name == NULL)) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_hl_exit;\n\t}\n\n\tif (tcon->unix_ext)\n\t\trc = CIFSUnixCreateHardLink(xid, tcon, from_name, to_name,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_remap(cifs_sb));\n\telse {\n\t\tserver = tcon->ses->server;\n\t\tif (!server->ops->create_hardlink) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cifs_hl_exit;\n\t\t}\n\t\trc = server->ops->create_hardlink(xid, tcon, from_name, to_name,\n\t\t\t\t\t\t  cifs_sb);\n\t\tif ((rc == -EIO) || (rc == -EINVAL))\n\t\t\trc = -EOPNOTSUPP;\n\t}\n\n\td_drop(direntry);\t/* force new lookup from server of target */\n\n\t/*\n\t * if source file is cached (oplocked) revalidate will not go to server\n\t * until the file is closed or oplock broken so update nlinks locally\n\t */\n\tif (old_file->d_inode) {\n\t\tcifsInode = CIFS_I(old_file->d_inode);\n\t\tif (rc == 0) {\n\t\t\tspin_lock(&old_file->d_inode->i_lock);\n\t\t\tinc_nlink(old_file->d_inode);\n\t\t\tspin_unlock(&old_file->d_inode->i_lock);\n\n\t\t\t/*\n\t\t\t * parent dir timestamps will update from srv within a\n\t\t\t * second, would it really be worth it to set the parent\n\t\t\t * dir cifs inode time to zero to force revalidate\n\t\t\t * (faster) for it too?\n\t\t\t */\n\t\t}\n\t\t/*\n\t\t * if not oplocked will force revalidate to get info on source\n\t\t * file from srv.  Note Samba server prior to 4.2 has bug -\n\t\t * not updating src file ctime on hardlinks but Windows servers\n\t\t * handle it properly\n\t\t */\n\t\tcifsInode->time = 0;\n\n\t\t/*\n\t\t * Will update parent dir timestamps from srv within a second.\n\t\t * Would it really be worth it to set the parent dir (cifs\n\t\t * inode) time field to zero to force revalidate on parent\n\t\t * directory faster ie\n\t\t *\n\t\t * CIFS_I(inode)->time = 0;\n\t\t */\n\t}\n\ncifs_hl_exit:\n\tkfree(from_name);\n\tkfree(to_name);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "to_name"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "from_name"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&old_file->d_inode->i_lock"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "old_file->d_inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&old_file->d_inode->i_lock"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "old_file->d_inode"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "direntry"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->create_hardlink",
          "args": [
            "xid",
            "tcon",
            "from_name",
            "to_name",
            "cifs_sb"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSUnixCreateHardLink",
          "args": [
            "xid",
            "tcon",
            "from_name",
            "to_name",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSUnixCreateHardLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2874-2958",
          "snippet": "int\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Create Hard link Unix style\\n\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, fromName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo (hard link) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Create Hard link Unix style\\n\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, fromName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo (hard link) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\ncifs_hardlink(struct dentry *old_file, struct inode *inode,\n\t      struct dentry *direntry)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\tchar *from_name = NULL;\n\tchar *to_name = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cifsInode;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfrom_name = build_path_from_dentry(old_file);\n\tto_name = build_path_from_dentry(direntry);\n\tif ((from_name == NULL) || (to_name == NULL)) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_hl_exit;\n\t}\n\n\tif (tcon->unix_ext)\n\t\trc = CIFSUnixCreateHardLink(xid, tcon, from_name, to_name,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_remap(cifs_sb));\n\telse {\n\t\tserver = tcon->ses->server;\n\t\tif (!server->ops->create_hardlink) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cifs_hl_exit;\n\t\t}\n\t\trc = server->ops->create_hardlink(xid, tcon, from_name, to_name,\n\t\t\t\t\t\t  cifs_sb);\n\t\tif ((rc == -EIO) || (rc == -EINVAL))\n\t\t\trc = -EOPNOTSUPP;\n\t}\n\n\td_drop(direntry);\t/* force new lookup from server of target */\n\n\t/*\n\t * if source file is cached (oplocked) revalidate will not go to server\n\t * until the file is closed or oplock broken so update nlinks locally\n\t */\n\tif (old_file->d_inode) {\n\t\tcifsInode = CIFS_I(old_file->d_inode);\n\t\tif (rc == 0) {\n\t\t\tspin_lock(&old_file->d_inode->i_lock);\n\t\t\tinc_nlink(old_file->d_inode);\n\t\t\tspin_unlock(&old_file->d_inode->i_lock);\n\n\t\t\t/*\n\t\t\t * parent dir timestamps will update from srv within a\n\t\t\t * second, would it really be worth it to set the parent\n\t\t\t * dir cifs inode time to zero to force revalidate\n\t\t\t * (faster) for it too?\n\t\t\t */\n\t\t}\n\t\t/*\n\t\t * if not oplocked will force revalidate to get info on source\n\t\t * file from srv.  Note Samba server prior to 4.2 has bug -\n\t\t * not updating src file ctime on hardlinks but Windows servers\n\t\t * handle it properly\n\t\t */\n\t\tcifsInode->time = 0;\n\n\t\t/*\n\t\t * Will update parent dir timestamps from srv within a second.\n\t\t * Would it really be worth it to set the parent dir (cifs\n\t\t * inode) time field to zero to force revalidate on parent\n\t\t * directory faster ie\n\t\t *\n\t\t * CIFS_I(inode)->time = 0;\n\t\t */\n\t}\n\ncifs_hl_exit:\n\tkfree(from_name);\n\tkfree(to_name);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb3_create_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "473-532",
    "snippet": "int\nsmb3_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint create_options = CREATE_NOT_DIR;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\tstruct kvec iov[2];\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, path);\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\n\t/* iov[0] is reserved for smb header */\n\tiov[1].iov_base = pbuf;\n\tiov[1].iov_len = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = SMB2_write(xid, &io_parms, pbytes_written, iov, 1);\n\n\t/* Make sure we wrote all of the symlink data */\n\tif ((rc == 0) && (*pbytes_written != CIFS_MF_SYMLINK_FILE_SIZE))\n\t\trc = -EIO;\n\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\n\tkfree(utf16_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_write",
          "args": [
            "xid",
            "&io_parms",
            "pbytes_written",
            "iov",
            "1"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2009-2062",
          "snippet": "int\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "path",
            "cifs_sb"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: path: %s\\n\"",
            "__func__",
            "path"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\nsmb3_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint create_options = CREATE_NOT_DIR;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\tstruct kvec iov[2];\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, path);\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\n\t/* iov[0] is reserved for smb header */\n\tiov[1].iov_base = pbuf;\n\tiov[1].iov_len = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = SMB2_write(xid, &io_parms, pbytes_written, iov, 1);\n\n\t/* Make sure we wrote all of the symlink data */\n\tif ((rc == 0) && (*pbytes_written != CIFS_MF_SYMLINK_FILE_SIZE))\n\t\trc = -EIO;\n\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\n\tkfree(utf16_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb3_query_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "411-471",
    "snippet": "int\nsmb3_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_II;\n\tstruct smb2_file_all_info *pfile_info = NULL;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\tif (backup_cred(cifs_sb))\n\t\toparms.create_options |= CREATE_OPEN_BACKUP_INTENT;\n\toparms.disposition = FILE_OPEN;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (utf16_path == NULL)\n\t\treturn -ENOMEM;\n\n\tpfile_info = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t     GFP_KERNEL);\n\n\tif (pfile_info == NULL) {\n\t\tkfree(utf16_path);\n\t\treturn  -ENOMEM;\n\t}\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, pfile_info, NULL);\n\tif (rc)\n\t\tgoto qmf_out_open_fail;\n\n\tif (pfile_info->EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\t/* it's not a symlink */\n\t\trc = -ENOENT; /* Is there a better rc to return? */\n\t\tgoto qmf_out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\trc = SMB2_read(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nqmf_out:\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\nqmf_out_open_fail:\n\tkfree(utf16_path);\n\tkfree(pfile_info);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pfile_info"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_read",
          "args": [
            "xid",
            "&io_parms",
            "pbytes_read",
            "&pbuf",
            "&buf_type"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1819-1868",
          "snippet": "int\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "CIFS_MF_SYMLINK_FILE_SIZE"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "pfile_info",
            "NULL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smb2_file_all_info) + PATH_MAX * 2",
            "GFP_KERNEL"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "path",
            "cifs_sb"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\nsmb3_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_II;\n\tstruct smb2_file_all_info *pfile_info = NULL;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\tif (backup_cred(cifs_sb))\n\t\toparms.create_options |= CREATE_OPEN_BACKUP_INTENT;\n\toparms.disposition = FILE_OPEN;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (utf16_path == NULL)\n\t\treturn -ENOMEM;\n\n\tpfile_info = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t     GFP_KERNEL);\n\n\tif (pfile_info == NULL) {\n\t\tkfree(utf16_path);\n\t\treturn  -ENOMEM;\n\t}\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, pfile_info, NULL);\n\tif (rc)\n\t\tgoto qmf_out_open_fail;\n\n\tif (pfile_info->EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\t/* it's not a symlink */\n\t\trc = -ENOENT; /* Is there a better rc to return? */\n\t\tgoto qmf_out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\trc = SMB2_read(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nqmf_out:\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\nqmf_out_open_fail:\n\tkfree(utf16_path);\n\tkfree(pfile_info);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_create_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "368-405",
    "snippet": "int\ncifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint create_options = CREATE_NOT_DIR;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBWrite(xid, &io_parms, pbytes_written, pbuf, NULL, 0);\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBWrite",
          "args": [
            "xid",
            "&io_parms",
            "pbytes_written",
            "pbuf",
            "NULL",
            "0"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1754-1879",
          "snippet": "int\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\ncifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint create_options = CREATE_NOT_DIR;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBWrite(xid, &io_parms, pbytes_written, pbuf, NULL, 0);\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_query_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "324-366",
    "snippet": "int\ncifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\tFILE_ALL_INFO file_info;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, &file_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\trc = -ENOENT;\n\t\t/* it's not a symlink */\n\t\tgoto out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBRead(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nout:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBRead",
          "args": [
            "xid",
            "&io_parms",
            "pbytes_read",
            "&pbuf",
            "&buf_type"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1645-1751",
          "snippet": "int\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "CIFS_MF_SYMLINK_FILE_SIZE"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "&file_info"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\ncifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\tFILE_ALL_INFO file_info;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, &file_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\trc = -ENOENT;\n\t\t/* it's not a symlink */\n\t\tgoto out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBRead(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nout:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}"
  },
  {
    "function_name": "check_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "270-318",
    "snippet": "int\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t const unsigned char *path)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tif (!couldbe_mf_symlink(fattr))\n\t\t/* it's not a symlink */\n\t\treturn 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) /* not a symlink */\n\t\tgoto out;\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, NULL);\n\tif (rc == -EINVAL) {\n\t\t/* it's not a symlink */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t/* it is a symlink */\n\tfattr->cf_eof = link_len;\n\tfattr->cf_mode &= ~S_IFMT;\n\tfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\n\tfattr->cf_dtype = DT_LNK;\nout:\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mf_symlink",
          "args": [
            "buf",
            "bytes_read",
            "&link_len",
            "NULL"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "101-143",
          "snippet": "static int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"",
            "#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"",
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)",
            "#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))",
            "#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))\n\nstatic int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->query_mf_symlink",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "path",
            "buf",
            "&bytes_read"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CIFS_MF_SYMLINK_FILE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "couldbe_mf_symlink",
          "args": [
            "fattr"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "couldbe_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "189-201",
          "snippet": "bool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nbool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t const unsigned char *path)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tif (!couldbe_mf_symlink(fattr))\n\t\t/* it's not a symlink */\n\t\treturn 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) /* not a symlink */\n\t\tgoto out;\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, NULL);\n\tif (rc == -EINVAL) {\n\t\t/* it's not a symlink */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t/* it is a symlink */\n\tfattr->cf_eof = link_len;\n\tfattr->cf_mode &= ~S_IFMT;\n\tfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\n\tfattr->cf_dtype = DT_LNK;\nout:\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "query_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "236-268",
    "snippet": "static int\nquery_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t char **symlinkinfo)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) { /* not a symlink */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, symlinkinfo);\nout:\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mf_symlink",
          "args": [
            "buf",
            "bytes_read",
            "&link_len",
            "symlinkinfo"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "101-143",
          "snippet": "static int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"",
            "#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"",
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)",
            "#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))",
            "#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))\n\nstatic int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->query_mf_symlink",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "path",
            "buf",
            "&bytes_read"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CIFS_MF_SYMLINK_FILE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nstatic int\nquery_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t char **symlinkinfo)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) { /* not a symlink */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, symlinkinfo);\nout:\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "create_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "203-234",
    "snippet": "static int\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *fromName,\n\t\t  const char *toName)\n{\n\tint rc;\n\tu8 *buf;\n\tunsigned int bytes_written = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->ses->server->ops->create_mf_symlink)\n\t\trc = tcon->ses->server->ops->create_mf_symlink(xid, tcon,\n\t\t\t\t\tcifs_sb, fromName, buf, &bytes_written);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\trc = -EIO;\nout:\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->create_mf_symlink",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "fromName",
            "buf",
            "&bytes_written"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_mf_symlink",
          "args": [
            "buf",
            "CIFS_MF_SYMLINK_FILE_SIZE",
            "toName"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "format_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "145-187",
          "snippet": "static int\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tunsigned int ofs;\n\tu8 md5_hash[16];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tlink_len = strlen(link_str);\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -ENAMETOOLONG;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(buf, buf_len,\n\t\t CIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t link_len,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tofs = CIFS_MF_SYMLINK_LINK_OFFSET;\n\tmemcpy(buf + ofs, link_str, link_len);\n\n\tofs += link_len;\n\tif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = '\\n';\n\t\tofs++;\n\t}\n\n\twhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = ' ';\n\t\tofs++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"",
            "#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"",
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)",
            "#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)",
            "#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n\nstatic int\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tunsigned int ofs;\n\tu8 md5_hash[16];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tlink_len = strlen(link_str);\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -ENAMETOOLONG;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(buf, buf_len,\n\t\t CIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t link_len,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tofs = CIFS_MF_SYMLINK_LINK_OFFSET;\n\tmemcpy(buf + ofs, link_str, link_len);\n\n\tofs += link_len;\n\tif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = '\\n';\n\t\tofs++;\n\t}\n\n\twhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = ' ';\n\t\tofs++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CIFS_MF_SYMLINK_FILE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nstatic int\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *fromName,\n\t\t  const char *toName)\n{\n\tint rc;\n\tu8 *buf;\n\tunsigned int bytes_written = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->ses->server->ops->create_mf_symlink)\n\t\trc = tcon->ses->server->ops->create_mf_symlink(xid, tcon,\n\t\t\t\t\tcifs_sb, fromName, buf, &bytes_written);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\trc = -EIO;\nout:\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "couldbe_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "189-201",
    "snippet": "bool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "fattr->cf_mode"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nbool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "format_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "145-187",
    "snippet": "static int\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tunsigned int ofs;\n\tu8 md5_hash[16];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tlink_len = strlen(link_str);\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -ENAMETOOLONG;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(buf, buf_len,\n\t\t CIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t link_len,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tofs = CIFS_MF_SYMLINK_LINK_OFFSET;\n\tmemcpy(buf + ofs, link_str, link_len);\n\n\tofs += link_len;\n\tif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = '\\n';\n\t\tofs++;\n\t}\n\n\twhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = ' ';\n\t\tofs++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"",
      "#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"",
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)",
      "#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)",
      "#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + ofs",
            "link_str",
            "link_len"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "buf_len",
            "CIFS_MF_SYMLINK_LEN_FORMATCIFS_MF_SYMLINK_MD5_FORMAT",
            "link_len",
            "CIFS_MF_SYMLINK_MD5_ARGS(md5_hash)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_MF_SYMLINK_MD5_ARGS",
          "args": [
            "md5_hash"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: MD5 hash failure: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink_hash",
          "args": [
            "link_len",
            "link_str",
            "md5_hash"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "symlink_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "56-99",
          "snippet": "static int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "link_str"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n\nstatic int\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tunsigned int ofs;\n\tu8 md5_hash[16];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tlink_len = strlen(link_str);\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -ENAMETOOLONG;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(buf, buf_len,\n\t\t CIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t link_len,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tofs = CIFS_MF_SYMLINK_LINK_OFFSET;\n\tmemcpy(buf + ofs, link_str, link_len);\n\n\tofs += link_len;\n\tif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = '\\n';\n\t\tofs++;\n\t}\n\n\twhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = ' ';\n\t\tofs++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_mf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "101-143",
    "snippet": "static int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"",
      "#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"",
      "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)",
      "#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))",
      "#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "link_str",
            "link_len",
            "GFP_KERNEL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "md5_str1",
            "md5_str2",
            "17"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "md5_str2",
            "sizeof(md5_str2)",
            "CIFS_MF_SYMLINK_MD5_FORMAT",
            "CIFS_MF_SYMLINK_MD5_ARGS(md5_hash)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_MF_SYMLINK_MD5_ARGS",
          "args": [
            "md5_hash"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: MD5 hash failure: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink_hash",
          "args": [
            "link_len",
            "link_str",
            "md5_hash"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "symlink_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "56-99",
          "snippet": "static int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "CIFS_MF_SYMLINK_LEN_FORMAT",
            "&link_len"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_MD5_FORMAT \\\n\t\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))\n\nstatic int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tsnprintf(md5_str2, sizeof(md5_str2),\n\t\t CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "symlink_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
    "lines": "56-99",
    "snippet": "static int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2proto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sdescmd5"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "md5"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not generate md5 hash\\n\"",
            "__func__"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&sdescmd5->shash",
            "md5_hash"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with link_str\\n\"",
            "__func__"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdescmd5->shash",
            "link_str",
            "link_len"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not init md5 shash\\n\"",
            "__func__"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&sdescmd5->shash"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "md5"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Crypto md5 allocation error %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "md5"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "md5"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"md5\"",
            "0",
            "0"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md5;\n\tstruct sdesc *sdescmd5;\n\n\tmd5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(md5)) {\n\t\trc = PTR_ERR(md5);\n\t\tcifs_dbg(VFS, \"%s: Crypto md5 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\n\tsdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd5) {\n\t\trc = -ENOMEM;\n\t\tgoto symlink_hash_err;\n\t}\n\tsdescmd5->shash.tfm = md5;\n\tsdescmd5->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(&sdescmd5->shash, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcrypto_free_shash(md5);\n\tkfree(sdescmd5);\n\n\treturn rc;\n}"
  }
]