[
  {
    "function_name": "omfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "349-370",
    "snippet": "static int omfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tomfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "572-597",
          "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define __setattr_copy setattr_copy"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_truncate",
          "args": [
            "inode"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "106-110",
          "snippet": "static void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tomfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "333-336",
    "snippet": "static sector_t omfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, omfs_get_block);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "omfs_get_block"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic sector_t omfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, omfs_get_block);\n}"
  },
  {
    "function_name": "omfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "319-331",
    "snippet": "static int omfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tomfs_get_block);\n\tif (unlikely(ret))\n\t\tomfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "309-317",
          "snippet": "static void omfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tomfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void omfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tomfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "omfs_get_block"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tomfs_get_block);\n\tif (unlikely(ret))\n\t\tomfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "omfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "309-317",
    "snippet": "static void omfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tomfs_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_truncate",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "106-110",
          "snippet": "static void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void omfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tomfs_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "omfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "303-307",
    "snippet": "static int\nomfs_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, omfs_get_block);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "omfs_get_block"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\nomfs_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, omfs_get_block);\n}"
  },
  {
    "function_name": "omfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "298-301",
    "snippet": "static int omfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, omfs_get_block, wbc);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "omfs_get_block",
            "wbc"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, omfs_get_block, wbc);\n}"
  },
  {
    "function_name": "omfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "292-296",
    "snippet": "static int omfs_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, omfs_get_block);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "omfs_get_block"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, omfs_get_block);\n}"
  },
  {
    "function_name": "omfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "287-290",
    "snippet": "static int omfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, omfs_get_block);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "omfs_get_block"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, omfs_get_block);\n}"
  },
  {
    "function_name": "omfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "217-285",
    "snippet": "static int omfs_get_block(struct inode *inode, sector_t block,\n\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct buffer_head *bh;\n\tsector_t next, offset;\n\tint ret;\n\tu64 uninitialized_var(new_block);\n\tu32 max_extents;\n\tint extent_count;\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tint max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint remain;\n\n\tret = -EIO;\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\tnext = inode->i_ino;\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\toffset = find_block(inode, entry, block, extent_count, &remain);\n\t\tif (offset > 0) {\n\t\t\tret = 0;\n\t\t\tmap_bh(bh_result, inode->i_sb, offset);\n\t\t\tif (remain > max_blocks)\n\t\t\t\tremain = max_blocks;\n\t\t\tbh_result->b_size = (remain << inode->i_blkbits);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tif (create) {\n\t\tret = omfs_grow_extent(inode, oe, &new_block);\n\t\tif (ret == 0) {\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\t\tclus_to_blk(sbi, new_block));\n\t\t}\n\t}\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "clus_to_blk(sbi, new_block)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clus_to_blk",
          "args": [
            "sbi",
            "new_block"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "clus_to_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "29-32",
          "snippet": "static inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_grow_extent",
          "args": [
            "inode",
            "oe",
            "&new_block"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_grow_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "116-185",
          "snippet": "static int omfs_grow_extent(struct inode *inode, struct omfs_extent *oe,\n\t\t\tu64 *ret_block)\n{\n\tstruct omfs_extent_entry *terminator;\n\tstruct omfs_extent_entry *entry = &oe->e_entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tu32 extent_count = be32_to_cpu(oe->e_extent_count);\n\tu64 new_block = 0;\n\tu32 max_count;\n\tint new_count;\n\tint ret = 0;\n\n\t/* reached the end of the extent table with no blocks mapped.\n\t * there are three possibilities for adding: grow last extent,\n\t * add a new extent to the current extent table, and add a\n\t * continuation inode.  in last two cases need an allocator for\n\t * sbi->s_cluster_size\n\t */\n\n\t/* TODO: handle holes */\n\n\t/* should always have a terminator */\n\tif (extent_count < 1)\n\t\treturn -EIO;\n\n\t/* trivially grow current extent, if next block is not taken */\n\tterminator = entry + extent_count - 1;\n\tif (extent_count > 1) {\n\t\tentry = terminator-1;\n\t\tnew_block = be64_to_cpu(entry->e_cluster) +\n\t\t\tbe64_to_cpu(entry->e_blocks);\n\n\t\tif (omfs_allocate_block(inode->i_sb, new_block)) {\n\t\t\tbe64_add_cpu(&entry->e_blocks, 1);\n\t\t\tterminator->e_blocks = ~(cpu_to_be64(\n\t\t\t\tbe64_to_cpu(~terminator->e_blocks) + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmax_count = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\t/* TODO: add a continuation block here */\n\tif (be32_to_cpu(oe->e_extent_count) > max_count-1)\n\t\treturn -EIO;\n\n\t/* try to allocate a new cluster */\n\tret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,\n\t\t&new_block, &new_count);\n\tif (ret)\n\t\tgoto out_fail;\n\n\t/* copy terminator down an entry */\n\tentry = terminator;\n\tterminator++;\n\tmemcpy(terminator, entry, sizeof(struct omfs_extent_entry));\n\n\tentry->e_cluster = cpu_to_be64(new_block);\n\tentry->e_blocks = cpu_to_be64((u64) new_count);\n\n\tterminator->e_blocks = ~(cpu_to_be64(\n\t\tbe64_to_cpu(~terminator->e_blocks) + (u64) new_count));\n\n\t/* write in new entry */\n\tbe32_add_cpu(&oe->e_extent_count, 1);\n\nout:\n\t*ret_block = new_block;\nout_fail:\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_grow_extent(struct inode *inode, struct omfs_extent *oe,\n\t\t\tu64 *ret_block)\n{\n\tstruct omfs_extent_entry *terminator;\n\tstruct omfs_extent_entry *entry = &oe->e_entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tu32 extent_count = be32_to_cpu(oe->e_extent_count);\n\tu64 new_block = 0;\n\tu32 max_count;\n\tint new_count;\n\tint ret = 0;\n\n\t/* reached the end of the extent table with no blocks mapped.\n\t * there are three possibilities for adding: grow last extent,\n\t * add a new extent to the current extent table, and add a\n\t * continuation inode.  in last two cases need an allocator for\n\t * sbi->s_cluster_size\n\t */\n\n\t/* TODO: handle holes */\n\n\t/* should always have a terminator */\n\tif (extent_count < 1)\n\t\treturn -EIO;\n\n\t/* trivially grow current extent, if next block is not taken */\n\tterminator = entry + extent_count - 1;\n\tif (extent_count > 1) {\n\t\tentry = terminator-1;\n\t\tnew_block = be64_to_cpu(entry->e_cluster) +\n\t\t\tbe64_to_cpu(entry->e_blocks);\n\n\t\tif (omfs_allocate_block(inode->i_sb, new_block)) {\n\t\t\tbe64_add_cpu(&entry->e_blocks, 1);\n\t\t\tterminator->e_blocks = ~(cpu_to_be64(\n\t\t\t\tbe64_to_cpu(~terminator->e_blocks) + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmax_count = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\t/* TODO: add a continuation block here */\n\tif (be32_to_cpu(oe->e_extent_count) > max_count-1)\n\t\treturn -EIO;\n\n\t/* try to allocate a new cluster */\n\tret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,\n\t\t&new_block, &new_count);\n\tif (ret)\n\t\tgoto out_fail;\n\n\t/* copy terminator down an entry */\n\tentry = terminator;\n\tterminator++;\n\tmemcpy(terminator, entry, sizeof(struct omfs_extent_entry));\n\n\tentry->e_cluster = cpu_to_be64(new_block);\n\tentry->e_blocks = cpu_to_be64((u64) new_count);\n\n\tterminator->e_blocks = ~(cpu_to_be64(\n\t\tbe64_to_cpu(~terminator->e_blocks) + (u64) new_count));\n\n\t/* write in new entry */\n\tbe32_add_cpu(&oe->e_extent_count, 1);\n\nout:\n\t*ret_block = new_block;\nout_fail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_max_extents",
          "args": [
            "sbi",
            "OMFS_EXTENT_CONT"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "inode->i_sb",
            "next"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "offset"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_block",
          "args": [
            "inode",
            "entry",
            "block",
            "extent_count",
            "&remain"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "find_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "191-215",
          "snippet": "static sector_t find_block(struct inode *inode, struct omfs_extent_entry *ent,\n\t\t\tsector_t block, int count, int *left)\n{\n\t/* count > 1 because of terminator */\n\tsector_t searched = 0;\n\tfor (; count > 1; count--) {\n\t\tint numblocks = clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\tbe64_to_cpu(ent->e_blocks));\n\n\t\tif (block >= searched  &&\n\t\t    block < searched + numblocks) {\n\t\t\t/*\n\t\t\t * found it at cluster + (block - searched)\n\t\t\t * numblocks - (block - searched) is remainder\n\t\t\t */\n\t\t\t*left = numblocks - (block - searched);\n\t\t\treturn clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\t\tbe64_to_cpu(ent->e_cluster)) +\n\t\t\t\tblock - searched;\n\t\t}\n\t\tsearched += numblocks;\n\t\tent++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic sector_t find_block(struct inode *inode, struct omfs_extent_entry *ent,\n\t\t\tsector_t block, int count, int *left)\n{\n\t/* count > 1 because of terminator */\n\tsector_t searched = 0;\n\tfor (; count > 1; count--) {\n\t\tint numblocks = clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\tbe64_to_cpu(ent->e_blocks));\n\n\t\tif (block >= searched  &&\n\t\t    block < searched + numblocks) {\n\t\t\t/*\n\t\t\t * found it at cluster + (block - searched)\n\t\t\t * numblocks - (block - searched) is remainder\n\t\t\t */\n\t\t\t*left = numblocks - (block - searched);\n\t\t\treturn clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\t\tbe64_to_cpu(ent->e_cluster)) +\n\t\t\t\tblock - searched;\n\t\t}\n\t\tsearched += numblocks;\n\t\tent++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oe->e_next"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oe->e_extent_count"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_is_bad",
          "args": [
            "sbi",
            "(struct omfs_header *) bh->b_data",
            "next"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_is_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "316-328",
          "snippet": "int omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_get_block(struct inode *inode, sector_t block,\n\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct buffer_head *bh;\n\tsector_t next, offset;\n\tint ret;\n\tu64 uninitialized_var(new_block);\n\tu32 max_extents;\n\tint extent_count;\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tint max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint remain;\n\n\tret = -EIO;\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\tnext = inode->i_ino;\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\toffset = find_block(inode, entry, block, extent_count, &remain);\n\t\tif (offset > 0) {\n\t\t\tret = 0;\n\t\t\tmap_bh(bh_result, inode->i_sb, offset);\n\t\t\tif (remain > max_blocks)\n\t\t\t\tremain = max_blocks;\n\t\t\tbh_result->b_size = (remain << inode->i_blkbits);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tif (create) {\n\t\tret = omfs_grow_extent(inode, oe, &new_block);\n\t\tif (ret == 0) {\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\t\tclus_to_blk(sbi, new_block));\n\t\t}\n\t}\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "find_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "191-215",
    "snippet": "static sector_t find_block(struct inode *inode, struct omfs_extent_entry *ent,\n\t\t\tsector_t block, int count, int *left)\n{\n\t/* count > 1 because of terminator */\n\tsector_t searched = 0;\n\tfor (; count > 1; count--) {\n\t\tint numblocks = clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\tbe64_to_cpu(ent->e_blocks));\n\n\t\tif (block >= searched  &&\n\t\t    block < searched + numblocks) {\n\t\t\t/*\n\t\t\t * found it at cluster + (block - searched)\n\t\t\t * numblocks - (block - searched) is remainder\n\t\t\t */\n\t\t\t*left = numblocks - (block - searched);\n\t\t\treturn clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\t\tbe64_to_cpu(ent->e_cluster)) +\n\t\t\t\tblock - searched;\n\t\t}\n\t\tsearched += numblocks;\n\t\tent++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clus_to_blk",
          "args": [
            "OMFS_SB(inode->i_sb)",
            "be64_to_cpu(ent->e_cluster)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "clus_to_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "29-32",
          "snippet": "static inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ent->e_cluster"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ent->e_blocks"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic sector_t find_block(struct inode *inode, struct omfs_extent_entry *ent,\n\t\t\tsector_t block, int count, int *left)\n{\n\t/* count > 1 because of terminator */\n\tsector_t searched = 0;\n\tfor (; count > 1; count--) {\n\t\tint numblocks = clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\tbe64_to_cpu(ent->e_blocks));\n\n\t\tif (block >= searched  &&\n\t\t    block < searched + numblocks) {\n\t\t\t/*\n\t\t\t * found it at cluster + (block - searched)\n\t\t\t * numblocks - (block - searched) is remainder\n\t\t\t */\n\t\t\t*left = numblocks - (block - searched);\n\t\t\treturn clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\t\tbe64_to_cpu(ent->e_cluster)) +\n\t\t\t\tblock - searched;\n\t\t}\n\t\tsearched += numblocks;\n\t\tent++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_grow_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "116-185",
    "snippet": "static int omfs_grow_extent(struct inode *inode, struct omfs_extent *oe,\n\t\t\tu64 *ret_block)\n{\n\tstruct omfs_extent_entry *terminator;\n\tstruct omfs_extent_entry *entry = &oe->e_entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tu32 extent_count = be32_to_cpu(oe->e_extent_count);\n\tu64 new_block = 0;\n\tu32 max_count;\n\tint new_count;\n\tint ret = 0;\n\n\t/* reached the end of the extent table with no blocks mapped.\n\t * there are three possibilities for adding: grow last extent,\n\t * add a new extent to the current extent table, and add a\n\t * continuation inode.  in last two cases need an allocator for\n\t * sbi->s_cluster_size\n\t */\n\n\t/* TODO: handle holes */\n\n\t/* should always have a terminator */\n\tif (extent_count < 1)\n\t\treturn -EIO;\n\n\t/* trivially grow current extent, if next block is not taken */\n\tterminator = entry + extent_count - 1;\n\tif (extent_count > 1) {\n\t\tentry = terminator-1;\n\t\tnew_block = be64_to_cpu(entry->e_cluster) +\n\t\t\tbe64_to_cpu(entry->e_blocks);\n\n\t\tif (omfs_allocate_block(inode->i_sb, new_block)) {\n\t\t\tbe64_add_cpu(&entry->e_blocks, 1);\n\t\t\tterminator->e_blocks = ~(cpu_to_be64(\n\t\t\t\tbe64_to_cpu(~terminator->e_blocks) + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmax_count = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\t/* TODO: add a continuation block here */\n\tif (be32_to_cpu(oe->e_extent_count) > max_count-1)\n\t\treturn -EIO;\n\n\t/* try to allocate a new cluster */\n\tret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,\n\t\t&new_block, &new_count);\n\tif (ret)\n\t\tgoto out_fail;\n\n\t/* copy terminator down an entry */\n\tentry = terminator;\n\tterminator++;\n\tmemcpy(terminator, entry, sizeof(struct omfs_extent_entry));\n\n\tentry->e_cluster = cpu_to_be64(new_block);\n\tentry->e_blocks = cpu_to_be64((u64) new_count);\n\n\tterminator->e_blocks = ~(cpu_to_be64(\n\t\tbe64_to_cpu(~terminator->e_blocks) + (u64) new_count));\n\n\t/* write in new entry */\n\tbe32_add_cpu(&oe->e_extent_count, 1);\n\nout:\n\t*ret_block = new_block;\nout_fail:\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&oe->e_extent_count",
            "1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "be64_to_cpu(~terminator->e_blocks) + (u64) new_count"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "~terminator->e_blocks"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "(u64) new_count"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "new_block"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "terminator",
            "entry",
            "sizeof(struct omfs_extent_entry)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_allocate_range",
          "args": [
            "inode->i_sb",
            "1",
            "sbi->s_clustersize",
            "&new_block",
            "&new_count"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_allocate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "129-169",
          "snippet": "int omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oe->e_extent_count"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_max_extents",
          "args": [
            "sbi",
            "OMFS_EXTENT_START"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "be64_to_cpu(~terminator->e_blocks) + 1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "~terminator->e_blocks"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&entry->e_blocks",
            "1"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_allocate_block",
          "args": [
            "inode->i_sb",
            "new_block"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_allocate_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "90-120",
          "snippet": "int omfs_allocate_block(struct super_block *sb, u64 block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tunsigned int map, bit;\n\tint ret = 0;\n\tu64 tmp;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tif (map >= sbi->s_imap_size || test_and_set_bit(bit, sbi->s_imap[map]))\n\t\tgoto out;\n\n\tif (sbi->s_bitmap_ino > 0) {\n\t\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tret = 1;\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint omfs_allocate_block(struct super_block *sb, u64 block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tunsigned int map, bit;\n\tint ret = 0;\n\tu64 tmp;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tif (map >= sbi->s_imap_size || test_and_set_bit(bit, sbi->s_imap[map]))\n\t\tgoto out;\n\n\tif (sbi->s_bitmap_ino > 0) {\n\t\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tret = 1;\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "entry->e_blocks"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "entry->e_cluster"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oe->e_extent_count"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int omfs_grow_extent(struct inode *inode, struct omfs_extent *oe,\n\t\t\tu64 *ret_block)\n{\n\tstruct omfs_extent_entry *terminator;\n\tstruct omfs_extent_entry *entry = &oe->e_entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tu32 extent_count = be32_to_cpu(oe->e_extent_count);\n\tu64 new_block = 0;\n\tu32 max_count;\n\tint new_count;\n\tint ret = 0;\n\n\t/* reached the end of the extent table with no blocks mapped.\n\t * there are three possibilities for adding: grow last extent,\n\t * add a new extent to the current extent table, and add a\n\t * continuation inode.  in last two cases need an allocator for\n\t * sbi->s_cluster_size\n\t */\n\n\t/* TODO: handle holes */\n\n\t/* should always have a terminator */\n\tif (extent_count < 1)\n\t\treturn -EIO;\n\n\t/* trivially grow current extent, if next block is not taken */\n\tterminator = entry + extent_count - 1;\n\tif (extent_count > 1) {\n\t\tentry = terminator-1;\n\t\tnew_block = be64_to_cpu(entry->e_cluster) +\n\t\t\tbe64_to_cpu(entry->e_blocks);\n\n\t\tif (omfs_allocate_block(inode->i_sb, new_block)) {\n\t\t\tbe64_add_cpu(&entry->e_blocks, 1);\n\t\t\tterminator->e_blocks = ~(cpu_to_be64(\n\t\t\t\tbe64_to_cpu(~terminator->e_blocks) + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmax_count = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\t/* TODO: add a continuation block here */\n\tif (be32_to_cpu(oe->e_extent_count) > max_count-1)\n\t\treturn -EIO;\n\n\t/* try to allocate a new cluster */\n\tret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,\n\t\t&new_block, &new_count);\n\tif (ret)\n\t\tgoto out_fail;\n\n\t/* copy terminator down an entry */\n\tentry = terminator;\n\tterminator++;\n\tmemcpy(terminator, entry, sizeof(struct omfs_extent_entry));\n\n\tentry->e_cluster = cpu_to_be64(new_block);\n\tentry->e_blocks = cpu_to_be64((u64) new_count);\n\n\tterminator->e_blocks = ~(cpu_to_be64(\n\t\tbe64_to_cpu(~terminator->e_blocks) + (u64) new_count));\n\n\t/* write in new entry */\n\tbe32_add_cpu(&oe->e_extent_count, 1);\n\nout:\n\t*ret_block = new_block;\nout_fail:\n\treturn ret;\n}"
  },
  {
    "function_name": "omfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "106-110",
    "snippet": "static void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_shrink_inode",
          "args": [
            "inode"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "31-104",
          "snippet": "int omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}"
  },
  {
    "function_name": "omfs_shrink_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "31-104",
    "snippet": "int omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_max_extents",
          "args": [
            "sbi",
            "OMFS_EXTENT_CONT"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "inode->i_sb",
            "next"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_clear_range",
          "args": [
            "inode->i_sb",
            "last",
            "sbi->s_mirrors"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_clear_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "174-193",
          "snippet": "int omfs_clear_range(struct super_block *sb, u64 block, int count)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint omfs_clear_range(struct super_block *sb, u64 block, int count)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_make_empty_table",
          "args": [
            "bh",
            "(char *) oe - bh->b_data"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_make_empty_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "20-29",
          "snippet": "void omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "entry->e_blocks"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "entry->e_cluster"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oe->e_next"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oe->e_extent_count"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_is_bad",
          "args": [
            "sbi",
            "(struct omfs_header *) bh->b_data",
            "next"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_is_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "316-328",
          "snippet": "int omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "omfs_make_empty_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "20-29",
    "snippet": "void omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0ULL"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0ULL"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0x22"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0ULL"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}"
  },
  {
    "function_name": "omfs_max_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
    "lines": "13-18",
    "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
  }
]