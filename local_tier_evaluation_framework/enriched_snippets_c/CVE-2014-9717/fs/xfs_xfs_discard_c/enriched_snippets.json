[
  {
    "function_name": "xfs_discard_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
    "lines": "212-239",
    "snippet": "int\nxfs_discard_extents(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\terror = 0;\n\n\tlist_for_each_entry(busyp, list, list) {\n\t\ttrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t busyp->length);\n\n\t\terror = blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\n\t\t\t\tXFS_FSB_TO_BB(mp, busyp->length),\n\t\t\t\tGFP_NOFS, 0);\n\t\tif (error && error != -EOPNOTSUPP) {\n\t\t\txfs_info(mp,\n\t \"discard failed for extent [0x%llu,%u], error %d\",\n\t\t\t\t (unsigned long long)busyp->bno,\n\t\t\t\t busyp->length,\n\t\t\t\t error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_info",
          "args": [
            "mp",
            "\"discard failed for extent [0x%llu,%u], error %d\"",
            "(unsigned long long)busyp->bno",
            "busyp->length",
            "error"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "mp->m_ddev_targp->bt_bdev",
            "XFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno)",
            "XFS_FSB_TO_BB(mp, busyp->length)",
            "GFP_NOFS",
            "0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "busyp->length"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "busyp->agno",
            "busyp->bno"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_discard_extent",
          "args": [
            "mp",
            "busyp->agno",
            "busyp->bno",
            "busyp->length"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "busyp",
            "list",
            "list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_discard_extents(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\terror = 0;\n\n\tlist_for_each_entry(busyp, list, list) {\n\t\ttrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t busyp->length);\n\n\t\terror = blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\n\t\t\t\tXFS_FSB_TO_BB(mp, busyp->length),\n\t\t\t\tGFP_NOFS, 0);\n\t\tif (error && error != -EOPNOTSUPP) {\n\t\t\txfs_info(mp,\n\t \"discard failed for extent [0x%llu,%u], error %d\",\n\t\t\t\t (unsigned long long)busyp->bno,\n\t\t\t\t busyp->length,\n\t\t\t\t error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
    "lines": "154-210",
    "snippet": "int\nxfs_ioc_trim(\n\tstruct xfs_mount\t\t*mp,\n\tstruct fstrim_range __user\t*urange)\n{\n\tstruct request_queue\t*q = bdev_get_queue(mp->m_ddev_targp->bt_bdev);\n\tunsigned int\t\tgranularity = q->limits.discard_granularity;\n\tstruct fstrim_range\trange;\n\txfs_daddr_t\t\tstart, end, minlen;\n\txfs_agnumber_t\t\tstart_agno, end_agno, agno;\n\t__uint64_t\t\tblocks_trimmed = 0;\n\tint\t\t\terror, last_error = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, urange, sizeof(range)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Truncating down the len isn't actually quite correct, but using\n\t * BBTOB would mean we trivially get overflows for values\n\t * of ULLONG_MAX or slightly lower.  And ULLONG_MAX is the default\n\t * used by the fstrim application.  In the end it really doesn't\n\t * matter as trimming blocks is an advisory interface.\n\t */\n\tif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\n\t    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)) ||\n\t    range.len < mp->m_sb.sb_blocksize)\n\t\treturn -EINVAL;\n\n\tstart = BTOBB(range.start);\n\tend = start + BTOBBT(range.len) - 1;\n\tminlen = BTOBB(max_t(u64, granularity, range.minlen));\n\n\tif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\n\t\tend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)- 1;\n\n\tstart_agno = xfs_daddr_to_agno(mp, start);\n\tend_agno = xfs_daddr_to_agno(mp, end);\n\n\tfor (agno = start_agno; agno <= end_agno; agno++) {\n\t\terror = xfs_trim_extents(mp, agno, start, end, minlen,\n\t\t\t\t\t  &blocks_trimmed);\n\t\tif (error)\n\t\t\tlast_error = error;\n\t}\n\n\tif (last_error)\n\t\treturn last_error;\n\n\trange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\n\tif (copy_to_user(urange, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "urange",
            "&range",
            "sizeof(range)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "blocks_trimmed"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trim_extents",
          "args": [
            "mp",
            "agno",
            "start",
            "end",
            "minlen",
            "&blocks_trimmed"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trim_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
          "lines": "35-143",
          "snippet": "STATIC int\nxfs_trim_extents(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\t__uint64_t\t\t*blocks_trimmed)\n{\n\tstruct block_device\t*bdev = mp->m_ddev_targp->bt_bdev;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\terror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\n\tif (error || !agbp)\n\t\tgoto out_put_perag;\n\n\tcur = xfs_allocbt_init_cursor(mp, NULL, agbp, agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * Force out the log.  This means any transactions that might have freed\n\t * space before we took the AGF buffer lock are now on disk, and the\n\t * volatile disk cache is flushed.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Look up the longest btree in the AGF and start with it.\n\t */\n\terror = xfs_alloc_lookup_ge(cur, 0,\n\t\t\t    be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest), &i);\n\tif (error)\n\t\tgoto out_del_cursor;\n\n\t/*\n\t * Loop until we are done with all extents that are large\n\t * enough to be worth discarding.\n\t */\n\twhile (i) {\n\t\txfs_agblock_t\tfbno;\n\t\txfs_extlen_t\tflen;\n\t\txfs_daddr_t\tdbno;\n\t\txfs_extlen_t\tdlen;\n\n\t\terror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, out_del_cursor);\n\t\tASSERT(flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest));\n\n\t\t/*\n\t\t * use daddr format for all range/len calculations as that is\n\t\t * the format the range/len variables are supplied in by\n\t\t * userspace.\n\t\t */\n\t\tdbno = XFS_AGB_TO_DADDR(mp, agno, fbno);\n\t\tdlen = XFS_FSB_TO_BB(mp, flen);\n\n\t\t/*\n\t\t * Too small?  Give up.\n\t\t */\n\t\tif (dlen < minlen) {\n\t\t\ttrace_xfs_discard_toosmall(mp, agno, fbno, flen);\n\t\t\tgoto out_del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * If the extent is entirely outside of the range we are\n\t\t * supposed to discard skip it.  Do not bother to trim\n\t\t * down partially overlapping ranges for now.\n\t\t */\n\t\tif (dbno + dlen < start || dbno > end) {\n\t\t\ttrace_xfs_discard_exclude(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\t/*\n\t\t * If any blocks in the range are still busy, skip the\n\t\t * discard and try again the next time.\n\t\t */\n\t\tif (xfs_extent_busy_search(mp, agno, fbno, flen)) {\n\t\t\ttrace_xfs_discard_busy(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\ttrace_xfs_discard_extent(mp, agno, fbno, flen);\n\t\terror = blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\t*blocks_trimmed += flen;\n\nnext_extent:\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t}\n\nout_del_cursor:\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\txfs_buf_relse(agbp);\nout_put_perag:\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_trim_extents(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\t__uint64_t\t\t*blocks_trimmed)\n{\n\tstruct block_device\t*bdev = mp->m_ddev_targp->bt_bdev;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\terror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\n\tif (error || !agbp)\n\t\tgoto out_put_perag;\n\n\tcur = xfs_allocbt_init_cursor(mp, NULL, agbp, agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * Force out the log.  This means any transactions that might have freed\n\t * space before we took the AGF buffer lock are now on disk, and the\n\t * volatile disk cache is flushed.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Look up the longest btree in the AGF and start with it.\n\t */\n\terror = xfs_alloc_lookup_ge(cur, 0,\n\t\t\t    be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest), &i);\n\tif (error)\n\t\tgoto out_del_cursor;\n\n\t/*\n\t * Loop until we are done with all extents that are large\n\t * enough to be worth discarding.\n\t */\n\twhile (i) {\n\t\txfs_agblock_t\tfbno;\n\t\txfs_extlen_t\tflen;\n\t\txfs_daddr_t\tdbno;\n\t\txfs_extlen_t\tdlen;\n\n\t\terror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, out_del_cursor);\n\t\tASSERT(flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest));\n\n\t\t/*\n\t\t * use daddr format for all range/len calculations as that is\n\t\t * the format the range/len variables are supplied in by\n\t\t * userspace.\n\t\t */\n\t\tdbno = XFS_AGB_TO_DADDR(mp, agno, fbno);\n\t\tdlen = XFS_FSB_TO_BB(mp, flen);\n\n\t\t/*\n\t\t * Too small?  Give up.\n\t\t */\n\t\tif (dlen < minlen) {\n\t\t\ttrace_xfs_discard_toosmall(mp, agno, fbno, flen);\n\t\t\tgoto out_del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * If the extent is entirely outside of the range we are\n\t\t * supposed to discard skip it.  Do not bother to trim\n\t\t * down partially overlapping ranges for now.\n\t\t */\n\t\tif (dbno + dlen < start || dbno > end) {\n\t\t\ttrace_xfs_discard_exclude(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\t/*\n\t\t * If any blocks in the range are still busy, skip the\n\t\t * discard and try again the next time.\n\t\t */\n\t\tif (xfs_extent_busy_search(mp, agno, fbno, flen)) {\n\t\t\ttrace_xfs_discard_busy(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\ttrace_xfs_discard_extent(mp, agno, fbno, flen);\n\t\terror = blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\t*blocks_trimmed += flen;\n\nnext_extent:\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t}\n\nout_del_cursor:\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\txfs_buf_relse(agbp);\nout_put_perag:\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_daddr_to_agno",
          "args": [
            "mp",
            "end"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_daddr_to_agno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.h",
          "lines": "288-294",
          "snippet": "static inline xfs_agnumber_t\nxfs_daddr_to_agno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\tdo_div(ld, mp->m_sb.sb_agblocks);\n\treturn (xfs_agnumber_t) ld;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_agnumber_t\nxfs_daddr_to_agno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\tdo_div(ld, mp->m_sb.sb_agblocks);\n\treturn (xfs_agnumber_t) ld;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "max_t(u64, granularity, range.minlen)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "granularity",
            "range.minlen"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBBT",
          "args": [
            "range.len"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "range.start"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "XFS_ALLOC_AG_MAX_USABLE(mp)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_AG_MAX_USABLE",
          "args": [
            "mp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "urange",
            "sizeof(range)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "mp->m_ddev_targp->bt_bdev"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_ioc_trim(\n\tstruct xfs_mount\t\t*mp,\n\tstruct fstrim_range __user\t*urange)\n{\n\tstruct request_queue\t*q = bdev_get_queue(mp->m_ddev_targp->bt_bdev);\n\tunsigned int\t\tgranularity = q->limits.discard_granularity;\n\tstruct fstrim_range\trange;\n\txfs_daddr_t\t\tstart, end, minlen;\n\txfs_agnumber_t\t\tstart_agno, end_agno, agno;\n\t__uint64_t\t\tblocks_trimmed = 0;\n\tint\t\t\terror, last_error = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, urange, sizeof(range)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Truncating down the len isn't actually quite correct, but using\n\t * BBTOB would mean we trivially get overflows for values\n\t * of ULLONG_MAX or slightly lower.  And ULLONG_MAX is the default\n\t * used by the fstrim application.  In the end it really doesn't\n\t * matter as trimming blocks is an advisory interface.\n\t */\n\tif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\n\t    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)) ||\n\t    range.len < mp->m_sb.sb_blocksize)\n\t\treturn -EINVAL;\n\n\tstart = BTOBB(range.start);\n\tend = start + BTOBBT(range.len) - 1;\n\tminlen = BTOBB(max_t(u64, granularity, range.minlen));\n\n\tif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\n\t\tend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)- 1;\n\n\tstart_agno = xfs_daddr_to_agno(mp, start);\n\tend_agno = xfs_daddr_to_agno(mp, end);\n\n\tfor (agno = start_agno; agno <= end_agno; agno++) {\n\t\terror = xfs_trim_extents(mp, agno, start, end, minlen,\n\t\t\t\t\t  &blocks_trimmed);\n\t\tif (error)\n\t\t\tlast_error = error;\n\t}\n\n\tif (last_error)\n\t\treturn last_error;\n\n\trange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\n\tif (copy_to_user(urange, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_trim_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
    "lines": "35-143",
    "snippet": "STATIC int\nxfs_trim_extents(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\t__uint64_t\t\t*blocks_trimmed)\n{\n\tstruct block_device\t*bdev = mp->m_ddev_targp->bt_bdev;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\terror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\n\tif (error || !agbp)\n\t\tgoto out_put_perag;\n\n\tcur = xfs_allocbt_init_cursor(mp, NULL, agbp, agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * Force out the log.  This means any transactions that might have freed\n\t * space before we took the AGF buffer lock are now on disk, and the\n\t * volatile disk cache is flushed.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Look up the longest btree in the AGF and start with it.\n\t */\n\terror = xfs_alloc_lookup_ge(cur, 0,\n\t\t\t    be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest), &i);\n\tif (error)\n\t\tgoto out_del_cursor;\n\n\t/*\n\t * Loop until we are done with all extents that are large\n\t * enough to be worth discarding.\n\t */\n\twhile (i) {\n\t\txfs_agblock_t\tfbno;\n\t\txfs_extlen_t\tflen;\n\t\txfs_daddr_t\tdbno;\n\t\txfs_extlen_t\tdlen;\n\n\t\terror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, out_del_cursor);\n\t\tASSERT(flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest));\n\n\t\t/*\n\t\t * use daddr format for all range/len calculations as that is\n\t\t * the format the range/len variables are supplied in by\n\t\t * userspace.\n\t\t */\n\t\tdbno = XFS_AGB_TO_DADDR(mp, agno, fbno);\n\t\tdlen = XFS_FSB_TO_BB(mp, flen);\n\n\t\t/*\n\t\t * Too small?  Give up.\n\t\t */\n\t\tif (dlen < minlen) {\n\t\t\ttrace_xfs_discard_toosmall(mp, agno, fbno, flen);\n\t\t\tgoto out_del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * If the extent is entirely outside of the range we are\n\t\t * supposed to discard skip it.  Do not bother to trim\n\t\t * down partially overlapping ranges for now.\n\t\t */\n\t\tif (dbno + dlen < start || dbno > end) {\n\t\t\ttrace_xfs_discard_exclude(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\t/*\n\t\t * If any blocks in the range are still busy, skip the\n\t\t * discard and try again the next time.\n\t\t */\n\t\tif (xfs_extent_busy_search(mp, agno, fbno, flen)) {\n\t\t\ttrace_xfs_discard_busy(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\ttrace_xfs_discard_extent(mp, agno, fbno, flen);\n\t\terror = blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\t*blocks_trimmed += flen;\n\nnext_extent:\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t}\n\nout_del_cursor:\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\txfs_buf_relse(agbp);\nout_put_perag:\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "agbp"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "bdev",
            "dbno",
            "dlen",
            "GFP_NOFS",
            "0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_discard_extent",
          "args": [
            "mp",
            "agno",
            "fbno",
            "flen"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_discard_busy",
          "args": [
            "mp",
            "agno",
            "fbno",
            "flen"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_search",
          "args": [
            "mp",
            "agno",
            "fbno",
            "flen"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "104-143",
          "snippet": "int\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_discard_exclude",
          "args": [
            "mp",
            "agno",
            "fbno",
            "flen"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_discard_toosmall",
          "args": [
            "mp",
            "agno",
            "fbno",
            "flen"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "flen"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "fbno"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(agbp)->agf_longest"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "out_del_cursor"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "cur",
            "&fbno",
            "&flen",
            "&i"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_ge",
          "args": [
            "cur",
            "0",
            "be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest)",
            "&i"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_ge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "71-81",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(agbp)->agf_longest"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "mp",
            "NULL",
            "agbp",
            "agno",
            "XFS_BTNUM_CNT"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agf",
          "args": [
            "mp",
            "NULL",
            "agno",
            "0",
            "&agbp"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2310-2364",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_trim_extents(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_daddr_t\t\tstart,\n\txfs_daddr_t\t\tend,\n\txfs_daddr_t\t\tminlen,\n\t__uint64_t\t\t*blocks_trimmed)\n{\n\tstruct block_device\t*bdev = mp->m_ddev_targp->bt_bdev;\n\tstruct xfs_btree_cur\t*cur;\n\tstruct xfs_buf\t\t*agbp;\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tpag = xfs_perag_get(mp, agno);\n\n\terror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\n\tif (error || !agbp)\n\t\tgoto out_put_perag;\n\n\tcur = xfs_allocbt_init_cursor(mp, NULL, agbp, agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * Force out the log.  This means any transactions that might have freed\n\t * space before we took the AGF buffer lock are now on disk, and the\n\t * volatile disk cache is flushed.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Look up the longest btree in the AGF and start with it.\n\t */\n\terror = xfs_alloc_lookup_ge(cur, 0,\n\t\t\t    be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest), &i);\n\tif (error)\n\t\tgoto out_del_cursor;\n\n\t/*\n\t * Loop until we are done with all extents that are large\n\t * enough to be worth discarding.\n\t */\n\twhile (i) {\n\t\txfs_agblock_t\tfbno;\n\t\txfs_extlen_t\tflen;\n\t\txfs_daddr_t\tdbno;\n\t\txfs_extlen_t\tdlen;\n\n\t\terror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, out_del_cursor);\n\t\tASSERT(flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest));\n\n\t\t/*\n\t\t * use daddr format for all range/len calculations as that is\n\t\t * the format the range/len variables are supplied in by\n\t\t * userspace.\n\t\t */\n\t\tdbno = XFS_AGB_TO_DADDR(mp, agno, fbno);\n\t\tdlen = XFS_FSB_TO_BB(mp, flen);\n\n\t\t/*\n\t\t * Too small?  Give up.\n\t\t */\n\t\tif (dlen < minlen) {\n\t\t\ttrace_xfs_discard_toosmall(mp, agno, fbno, flen);\n\t\t\tgoto out_del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * If the extent is entirely outside of the range we are\n\t\t * supposed to discard skip it.  Do not bother to trim\n\t\t * down partially overlapping ranges for now.\n\t\t */\n\t\tif (dbno + dlen < start || dbno > end) {\n\t\t\ttrace_xfs_discard_exclude(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\t/*\n\t\t * If any blocks in the range are still busy, skip the\n\t\t * discard and try again the next time.\n\t\t */\n\t\tif (xfs_extent_busy_search(mp, agno, fbno, flen)) {\n\t\t\ttrace_xfs_discard_busy(mp, agno, fbno, flen);\n\t\t\tgoto next_extent;\n\t\t}\n\n\t\ttrace_xfs_discard_extent(mp, agno, fbno, flen);\n\t\terror = blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t\t*blocks_trimmed += flen;\n\nnext_extent:\n\t\terror = xfs_btree_decrement(cur, 0, &i);\n\t\tif (error)\n\t\t\tgoto out_del_cursor;\n\t}\n\nout_del_cursor:\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\txfs_buf_relse(agbp);\nout_put_perag:\n\txfs_perag_put(pag);\n\treturn error;\n}"
  }
]