[
  {
    "function_name": "cifs_set_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/inode.c",
    "lines": "37-2429",
    "snippet": "static void cifs_set_ops(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &cifs_file_inode_ops;\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_direct_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_direct_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_strict_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_strict_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tinode->i_fop = &cifs_file_nobrl_ops;\n\t\telse { /* not direct, send byte range locks */\n\t\t\tinode->i_fop = &cifs_file_ops;\n\t\t}\n\n\t\t/* check if server can support readpages */\n\t\tif (cifs_sb_master_tcon(cifs_sb)->ses->server->maxBuf <\n\t\t\t\tPAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops_smallbuf;\n\t\telse\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops;\n\t\tbreak;\n\tcase S_IFDIR:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (IS_AUTOMOUNT(inode)) {\n\t\t\tinode->i_op = &cifs_dfs_referral_inode_operations;\n\t\t} else {\n#else /* NO DFS support, treat as a directory */\n\t\t{\n#endif\n\t\t\tinode->i_op = &cifs_dir_inode_ops;\n\t\t\tinode->i_fop = &cifs_dir_ops;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &cifs_symlink_inode_ops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n\n/* check inode attributes against fattr. If they don't match, tag the\n * inode for cache invalidation\n */\nstatic void\ncifs_revalidate_cache(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\n\tcifs_dbg(FYI, \"%s: revalidating inode %llu\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is new\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t/* don't bother with revalidation if we have an oplock */\n\tif (CIFS_CACHE_READ(cifs_i)) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is oplocked\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t /* revalidate if mtime or size have changed */\n\tif (timespec_equal(&inode->i_mtime, &fattr->cf_mtime) &&\n\t    cifs_i->server_eof == fattr->cf_eof) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is unchanged\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\tcifs_dbg(FYI, \"%s: invalidating inode %llu mapping\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\tset_bit(CIFS_INO_INVALID_MAPPING, &cifs_i->flags);\n}\n\n/*\n * copy nlink to the inode, unless it wasn't provided.  Provide\n * sane values if we don't have an existing one and none was provided\n */\nstatic void\ncifs_nlink_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\t/*\n\t * if we're in a situation where we can't trust what we\n\t * got from the server (readdir, some non-unix cases)\n\t * fake reasonable values\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_UNKNOWN_NLINK) {\n\t\t/* only provide fake values on a new inode */\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY)\n\t\t\t\tset_nlink(inode, 2);\n\t\t\telse\n\t\t\t\tset_nlink(inode, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* we trust the server, so update it */\n\tset_nlink(inode, fattr->cf_nlink);\n}\n\n/* populate an inode with info from a cifs_fattr struct */\nvoid\ncifs_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tcifs_revalidate_cache(inode, fattr);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_atime = fattr->cf_atime;\n\tinode->i_mtime = fattr->cf_mtime;\n\tinode->i_ctime = fattr->cf_ctime;\n\tinode->i_rdev = fattr->cf_rdev;\n\tcifs_nlink_fattr_to_inode(inode, fattr);\n\tinode->i_uid = fattr->cf_uid;\n\tinode->i_gid = fattr->cf_gid;\n\n\t/* if dynperm is set, don't clobber existing mode */\n\tif (inode->i_state & I_NEW ||\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM))\n\t\tinode->i_mode = fattr->cf_mode;\n\n\tcifs_i->cifsAttrs = fattr->cf_cifsattrs;\n\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\tcifs_i->time = 0;\n\telse\n\t\tcifs_i->time = jiffies;\n\n\tif (fattr->cf_flags & CIFS_FATTR_DELETE_PENDING)\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\telse\n\t\tclear_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\n\tcifs_i->server_eof = fattr->cf_eof;\n\t/*\n\t * Can't safely change the file size here if the client is writing to\n\t * it due to potential races.\n\t */\n\tif (is_size_safe_to_change(cifs_i, fattr->cf_eof)) {\n\t\ti_size_write(inode, fattr->cf_eof);\n\n\t\t/*\n\t\t * i_blocks is not related to (i_size / i_blksize),\n\t\t * but instead 512 byte (2**9) size is required for\n\t\t * calculating num blocks.\n\t\t */\n\t\tinode->i_blocks = (512 - 1 + fattr->cf_bytes) >> 9;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (fattr->cf_flags & CIFS_FATTR_DFS_REFERRAL)\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\tif (inode->i_state & I_NEW)\n\t\tcifs_set_ops(inode);\n}\n\nvoid\ncifs_fill_uniqueid(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\treturn;\n\n\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n}\n\n/* Fill a cifs_fattr struct with info from FILE_UNIX_BASIC_INFO. */\nvoid\ncifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,\n\t\t\t struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_uniqueid = le64_to_cpu(info->UniqueId);\n\tfattr->cf_bytes = le64_to_cpu(info->NumOfBytes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastModificationTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->LastStatusChange);\n\tfattr->cf_mode = le64_to_cpu(info->Permissions);\n\n\t/*\n\t * Since we set the inode type below we need to mask off\n\t * to avoid strange results if bits set above.\n\t */\n\tfattr->cf_mode &= ~S_IFMT;\n\tswitch (le32_to_cpu(info->Type)) {\n\tcase UNIX_FILE:\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tbreak;\n\tcase UNIX_SYMLINK:\n\t\tfattr->cf_mode |= S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tcase UNIX_DIR:\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\tbreak;\n\tcase UNIX_CHARDEV:\n\t\tfattr->cf_mode |= S_IFCHR;\n\t\tfattr->cf_dtype = DT_CHR;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_BLOCKDEV:\n\t\tfattr->cf_mode |= S_IFBLK;\n\t\tfattr->cf_dtype = DT_BLK;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_FIFO:\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\tbreak;\n\tcase UNIX_SOCKET:\n\t\tfattr->cf_mode |= S_IFSOCK;\n\t\tfattr->cf_dtype = DT_SOCK;\n\t\tbreak;\n\tdefault:\n\t\t/* safest to call it a file if we do not know */\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tcifs_dbg(FYI, \"unknown type %d\\n\", le32_to_cpu(info->Type));\n\t\tbreak;\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)) {\n\t\tu64 id = le64_to_cpu(info->Uid);\n\t\tif (id < ((uid_t)-1)) {\n\t\t\tkuid_t uid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid))\n\t\t\t\tfattr->cf_uid = uid;\n\t\t}\n\t}\n\t\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)) {\n\t\tu64 id = le64_to_cpu(info->Gid);\n\t\tif (id < ((gid_t)-1)) {\n\t\t\tkgid_t gid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid))\n\t\t\t\tfattr->cf_gid = gid;\n\t\t}\n\t}\n\n\tfattr->cf_nlink = le64_to_cpu(info->Nlinks);\n}\n\n/*\n * Fill a cifs_fattr struct with fake inode info.\n *\n * Needed to setup cifs_fattr data for the directory which is the\n * junction to the new submount (ie to setup the fake directory\n * which represents a DFS referral).\n */\nstatic void\ncifs_create_dfs_fattr(struct cifs_fattr *fattr, struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"creating fake fattr for DFS referral\\n\");\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tfattr->cf_atime = CURRENT_TIME;\n\tfattr->cf_ctime = CURRENT_TIME;\n\tfattr->cf_mtime = CURRENT_TIME;\n\tfattr->cf_nlink = 2;\n\tfattr->cf_flags |= CIFS_FATTR_DFS_REFERRAL;\n}\n\nstatic int\ncifs_get_file_info_unix(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBUnixQFileInfo(xid, tcon, cfile->fid.netfid, &find_data);\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t}\n\n\tcifs_fattr_to_inode(inode, &fattr);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\t     const unsigned char *full_path,\n\t\t\t     struct super_block *sb, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/* could have done a find first instead but this returns more info */\n\trc = CIFSSMBUnixQPathInfo(xid, tcon, full_path, &find_data,\n\t\t\t\t  cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else {\n\t\treturn rc;\n\t}\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\tint tmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t     full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (*pinode == NULL) {\n\t\t/* get new inode */\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\t/* we already have inode, update it */\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_sfu_type(struct cifs_fattr *fattr, const char *path,\n\t      struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n\tint rc;\n\t__u32 oplock;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tchar buf[24];\n\tunsigned int bytes_read;\n\tchar *pbuf;\n\tint buf_type = CIFS_NO_BUFFER;\n\n\tpbuf = buf;\n\n\tfattr->cf_mode &= ~S_IFMT;\n\n\tif (fattr->cf_eof == 0) {\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\treturn 0;\n\t} else if (fattr->cf_eof < 8) {\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\treturn -EINVAL;\t /* EOPNOTSUPP? */\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"check sfu type of %s, open rc = %d\\n\", path, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/* Read header */\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = 24;\n\n\trc = tcon->ses->server->ops->sync_read(xid, &fid, &io_parms,\n\t\t\t\t\t&bytes_read, &pbuf, &buf_type);\n\tif ((rc == 0) && (bytes_read >= 8)) {\n\t\tif (memcmp(\"IntxBLK\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Block device\\n\");\n\t\t\tfattr->cf_mode |= S_IFBLK;\n\t\t\tfattr->cf_dtype = DT_BLK;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxCHR\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Char device\\n\");\n\t\t\tfattr->cf_mode |= S_IFCHR;\n\t\t\tfattr->cf_dtype = DT_CHR;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxLNK\", pbuf, 7) == 0) {\n\t\t\tcifs_dbg(FYI, \"Symlink\\n\");\n\t\t\tfattr->cf_mode |= S_IFLNK;\n\t\t\tfattr->cf_dtype = DT_LNK;\n\t\t} else {\n\t\t\tfattr->cf_mode |= S_IFREG; /* file? */\n\t\t\tfattr->cf_dtype = DT_REG;\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tfattr->cf_mode |= S_IFREG; /* then it is a file */\n\t\tfattr->cf_dtype = DT_REG;\n\t\trc = -EOPNOTSUPP; /* or some unknown SFU type */\n\t}\n\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)  /* SETFILEBITS valid bits */\n\n/*\n * Fetch mode bits as provided by SFU.\n *\n * FIXME: Doesn't this clobber the type bit we got from cifs_sfu_type ?\n */\nstatic int cifs_sfu_mode(struct cifs_fattr *fattr, const unsigned char *path,\n\t\t\t struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n#ifdef CONFIG_CIFS_XATTR\n\tssize_t rc;\n\tchar ea_value[4];\n\t__u32 mode;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (tcon->ses->server->ops->query_all_EAs == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = tcon->ses->server->ops->query_all_EAs(xid, tcon, path,\n\t\t\t\"SETFILEBITS\", ea_value, 4 /* size of buf */,\n\t\t\tcifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\tcifs_put_tlink(tlink);\n\tif (rc < 0)\n\t\treturn (int)rc;\n\telse if (rc > 3) {\n\t\tmode = le32_to_cpu(*((__le32 *)ea_value));\n\t\tfattr->cf_mode &= ~SFBITS_MASK;\n\t\tcifs_dbg(FYI, \"special bits 0%o org mode 0%o\\n\",\n\t\t\t mode, fattr->cf_mode);\n\t\tfattr->cf_mode = (mode & SFBITS_MASK) | fattr->cf_mode;\n\t\tcifs_dbg(FYI, \"special mode bits 0%o\\n\", mode);\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\n/* Fill a cifs_fattr struct with info from FILE_ALL_INFO */\nstatic void\ncifs_all_info_to_fattr(struct cifs_fattr *fattr, FILE_ALL_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb, bool adjust_tz,\n\t\t       bool symlink)\n{\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->Attributes);\n\tif (info->DeletePending)\n\t\tfattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;\n\n\tif (info->LastAccessTime)\n\t\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\telse\n\t\tfattr->cf_atime = CURRENT_TIME;\n\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tif (adjust_tz) {\n\t\tfattr->cf_ctime.tv_sec += tcon->ses->server->timeAdj;\n\t\tfattr->cf_mtime.tv_sec += tcon->ses->server->timeAdj;\n\t}\n\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\n\tfattr->cf_nlink = le32_to_cpu(info->NumberOfLinks);\n\n\tif (symlink) {\n\t\tfattr->cf_mode = S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t} else if (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\t/*\n\t\t * Server can return wrong NumberOfLinks value for directories\n\t\t * when Unix extensions are disabled - fake it.\n\t\t */\n\t\tif (!tcon->unix_ext)\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\n\t\t/* clear write bits if ATTR_READONLY is set */\n\t\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\t\tfattr->cf_mode &= ~(S_IWUGO);\n\n\t\t/*\n\t\t * Don't accept zero nlink from non-unix servers unless\n\t\t * delete is pending.  Instead mark it as unknown.\n\t\t */\n\t\tif ((fattr->cf_nlink < 1) && !tcon->unix_ext &&\n\t\t    !info->DeletePending) {\n\t\t\tcifs_dbg(1, \"bogus file nlink value %u\\n\",\n\t\t\t\tfattr->cf_nlink);\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t\t}\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n}\n\nstatic int\ncifs_get_file_info(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_ALL_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (!server->ops->query_file_info)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\trc = server->ops->query_file_info(xid, tcon, &cfile->fid, &find_data);\n\tswitch (rc) {\n\tcase 0:\n\t\tcifs_all_info_to_fattr(&fattr, &find_data, cifs_sb, false,\n\t\t\t\t       false);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EOPNOTSUPP:\n\tcase -EINVAL:\n\t\t/*\n\t\t * FIXME: legacy server -- fall back to path-based call?\n\t\t * for now, just skip revalidating and mark inode for\n\t\t * immediate reval.\n\t\t */\n\t\trc = 0;\n\t\tCIFS_I(inode)->time = 0;\n\tdefault:\n\t\tgoto cgfi_exit;\n\t}\n\n\t/*\n\t * don't bother with SFU junk here -- just mark inode as needing\n\t * revalidation.\n\t */\n\tfattr.cf_uniqueid = CIFS_I(inode)->uniqueid;\n\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\tcifs_fattr_to_inode(inode, &fattr);\ncgfi_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_get_inode_info(struct inode **inode, const char *full_path,\n\t\t    FILE_ALL_INFO *data, struct super_block *sb, int xid,\n\t\t    const struct cifs_fid *fid)\n{\n\tbool validinum = false;\n\t__u16 srchflgs;\n\tint rc = 0, tmprc = ENOSYS;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *buf = NULL;\n\tbool adjust_tz = false;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_search_info *srchinf = NULL;\n\tbool symlink = false;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\tif ((data == NULL) && (*inode != NULL)) {\n\t\tif (CIFS_CACHE_READ(CIFS_I(*inode))) {\n\t\t\tcifs_dbg(FYI, \"No need to revalidate cached inode sizes\\n\");\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n\n\t/* if inode info is not passed, get it from server */\n\tif (data == NULL) {\n\t\tif (!server->ops->query_path_info) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\t\tif (buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tdata = (FILE_ALL_INFO *)buf;\n\t\trc = server->ops->query_path_info(xid, tcon, cifs_sb, full_path,\n\t\t\t\t\t\t  data, &adjust_tz, &symlink);\n\t}\n\n\tif (!rc) {\n\t\tcifs_all_info_to_fattr(&fattr, data, cifs_sb, adjust_tz,\n\t\t\t\t       symlink);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else if (rc == -EACCES && backup_cred(cifs_sb)) {\n\t\t\tsrchinf = kzalloc(sizeof(struct cifs_search_info),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (srchinf == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto cgii_exit;\n\t\t\t}\n\n\t\t\tsrchinf->endOfSearch = false;\n\t\t\tsrchinf->info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\n\t\t\tsrchflgs = CIFS_SEARCH_CLOSE_ALWAYS |\n\t\t\t\t\tCIFS_SEARCH_CLOSE_AT_END |\n\t\t\t\t\tCIFS_SEARCH_BACKUP_SEARCH;\n\n\t\t\trc = CIFSFindFirst(xid, tcon, full_path,\n\t\t\t\tcifs_sb, NULL, srchflgs, srchinf, false);\n\t\t\tif (!rc) {\n\t\t\t\tdata =\n\t\t\t\t(FILE_ALL_INFO *)srchinf->srch_entries_start;\n\n\t\t\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t(FILE_DIRECTORY_INFO *)data, cifs_sb);\n\t\t\t\tfattr.cf_uniqueid = le64_to_cpu(\n\t\t\t\t((SEARCH_ID_FULL_DIR_INFO *)data)->UniqueId);\n\t\t\t\tvalidinum = true;\n\n\t\t\t\tcifs_buf_release(srchinf->ntwrk_buf_start);\n\t\t\t}\n\t\t\tkfree(srchinf);\n\t} else\n\t\tgoto cgii_exit;\n\n\t/*\n\t * If an inode wasn't passed in, then get the inode number\n\t *\n\t * Is an i_ino of zero legal? Can we use that to check if the server\n\t * supports returning inode numbers?  Are there other sanity checks we\n\t * can use to ensure that the server is really filling in that field?\n\t */\n\tif (*inode == NULL) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\t\tif (validinum == false) {\n\t\t\t\tif (server->ops->get_srv_inum)\n\t\t\t\t\ttmprc = server->ops->get_srv_inum(xid,\n\t\t\t\t\t\ttcon, cifs_sb, full_path,\n\t\t\t\t\t\t&fattr.cf_uniqueid, data);\n\t\t\t\tif (tmprc) {\n\t\t\t\t\tcifs_dbg(FYI, \"GetSrvInodeNum rc %d\\n\",\n\t\t\t\t\t\t tmprc);\n\t\t\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\t\tcifs_autodisable_serverino(cifs_sb);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t} else\n\t\tfattr.cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\n\t/* query for SFU type info if supported and needed */\n\tif (fattr.cf_cifsattrs & ATTR_SYSTEM &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL) {\n\t\ttmprc = cifs_sfu_type(&fattr, full_path, cifs_sb, xid);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"cifs_sfu_type failed: %d\\n\", tmprc);\n\t}\n\n#ifdef CONFIG_CIFS_ACL\n\t/* fill in 0777 bits from ACL */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\trc = cifs_acl_to_fattr(cifs_sb, &fattr, *inode, full_path, fid);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: Getting ACL failed with error: %d\\n\",\n\t\t\t\t __func__, rc);\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n#endif /* CONFIG_CIFS_ACL */\n\n\t/* fill in remaining high mode bits e.g. SUID, VTX */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tcifs_sfu_mode(&fattr, full_path, cifs_sb, xid);\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (!*inode) {\n\t\t*inode = cifs_iget(sb, &fattr);\n\t\tif (!*inode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\tcifs_fattr_to_inode(*inode, &fattr);\n\t}\n\ncgii_exit:\n\tkfree(buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic const struct inode_operations cifs_ipc_inode_ops = {\n\t.lookup = cifs_lookup,\n};\n\nstatic int\ncifs_find_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\t/* don't match inode with different uniqueid */\n\tif (CIFS_I(inode)->uniqueid != fattr->cf_uniqueid)\n\t\treturn 0;\n\n\t/* use createtime like an i_generation field */\n\tif (CIFS_I(inode)->createtime != fattr->cf_createtime)\n\t\treturn 0;\n\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (fattr->cf_mode & S_IFMT))\n\t\treturn 0;\n\n\t/* if it's not a directory or has no dentries, then flag it */\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry))\n\t\tfattr->cf_flags |= CIFS_FATTR_INO_COLLISION;\n\n\treturn 1;\n}\n\nstatic int\ncifs_init_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\tCIFS_I(inode)->uniqueid = fattr->cf_uniqueid;\n\tCIFS_I(inode)->createtime = fattr->cf_createtime;\n\treturn 0;\n}\n\n/*\n * walk dentry list for an inode and report whether it has aliases that\n * are hashed. We use this to determine if a directory inode can actually\n * be used.\n */\nstatic bool\ninode_has_hashed_dentries(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (!d_unhashed(dentry) || IS_ROOT(dentry)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn false;\n}\n\n/* Given fattrs, get a corresponding inode */\nstruct inode *\ncifs_iget(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tunsigned long hash;\n\tstruct inode *inode;\n\nretry_iget5_locked:\n\tcifs_dbg(FYI, \"looking for uniqueid=%llu\\n\", fattr->cf_uniqueid);\n\n\t/* hash down to 32-bits on 32-bit arch */\n\thash = cifs_uniqueid_to_ino_t(fattr->cf_uniqueid);\n\n\tinode = iget5_locked(sb, hash, cifs_find_inode, cifs_init_inode, fattr);\n\tif (inode) {\n\t\t/* was there a potentially problematic inode collision? */\n\t\tif (fattr->cf_flags & CIFS_FATTR_INO_COLLISION) {\n\t\t\tfattr->cf_flags &= ~CIFS_FATTR_INO_COLLISION;\n\n\t\t\tif (inode_has_hashed_dentries(inode)) {\n\t\t\t\tcifs_autodisable_serverino(CIFS_SB(sb));\n\t\t\t\tiput(inode);\n\t\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\tgoto retry_iget5_locked;\n\t\t\t}\n\t\t}\n\n\t\tcifs_fattr_to_inode(inode, fattr);\n\t\tif (sb->s_flags & MS_NOATIME)\n\t\t\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tinode->i_ino = hash;\n#ifdef CONFIG_CIFS_FSCACHE\n\t\t\t/* initialize per-inode cache cookie pointer */\n\t\t\tCIFS_I(inode)->fscache = NULL;\n#endif\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\n/* gets root inode */\nstruct inode *cifs_root_iget(struct super_block *sb)\n{\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct inode *inode = NULL;\n\tlong rc;\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\txid = get_xid();\n\tif (tcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&inode, \"\", sb, xid);\n\t\t/* some servers mistakenly claim POSIX support */\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto iget_no_retry;\n\t\tcifs_dbg(VFS, \"server does not support POSIX extensions\");\n\t\ttcon->unix_ext = false;\n\t}\n\n\trc = cifs_get_inode_info(&inode, \"\", NULL, sb, xid, NULL);\n\niget_no_retry:\n\tif (!inode) {\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_FSCACHE\n\t/* populate tcon->resource_id */\n\ttcon->resource_id = CIFS_I(inode)->uniqueid;\n#endif\n\n\tif (rc && tcon->ipc) {\n\t\tcifs_dbg(FYI, \"ipc connection - fake read inode\\n\");\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_mode |= S_IFDIR;\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &cifs_ipc_inode_ops;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_uid = cifs_sb->mnt_uid;\n\t\tinode->i_gid = cifs_sb->mnt_gid;\n\t\tspin_unlock(&inode->i_lock);\n\t} else if (rc) {\n\t\tiget_failed(inode);\n\t\tinode = ERR_PTR(rc);\n\t}\n\nout:\n\t/* can not call macro free_xid here since in a void func\n\t * TODO: This is no longer true\n\t */\n\t_free_xid(xid);\n\treturn inode;\n}\n\nint\ncifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,\n\t\t   char *full_path, __u32 dosattr)\n{\n\tbool set_time = false;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct TCP_Server_Info *server;\n\tFILE_BASIC_INFO\tinfo_buf;\n\n\tif (attrs == NULL)\n\t\treturn -EINVAL;\n\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\n\tif (!server->ops->set_file_info)\n\t\treturn -ENOSYS;\n\n\tif (attrs->ia_valid & ATTR_ATIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastAccessTime =\n\t\t\tcpu_to_le64(cifs_UnixTimeToNT(attrs->ia_atime));\n\t} else\n\t\tinfo_buf.LastAccessTime = 0;\n\n\tif (attrs->ia_valid & ATTR_MTIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastWriteTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_mtime));\n\t} else\n\t\tinfo_buf.LastWriteTime = 0;\n\n\t/*\n\t * Samba throws this field away, but windows may actually use it.\n\t * Do not set ctime unless other time stamps are changed explicitly\n\t * (i.e. by utimes()) since we would then have a mix of client and\n\t * server times.\n\t */\n\tif (set_time && (attrs->ia_valid & ATTR_CTIME)) {\n\t\tcifs_dbg(FYI, \"CIFS - CTIME changed\\n\");\n\t\tinfo_buf.ChangeTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_ctime));\n\t} else\n\t\tinfo_buf.ChangeTime = 0;\n\n\tinfo_buf.CreationTime = 0;\t/* don't change */\n\tinfo_buf.Attributes = cpu_to_le32(dosattr);\n\n\treturn server->ops->set_file_info(inode, full_path, &info_buf, xid);\n}\n\n/*\n * Open the given file (if it isn't already), set the DELETE_ON_CLOSE bit\n * and rename it to a random name that hopefully won't conflict with\n * anything else.\n */\nint\ncifs_rename_pending_delete(const char *full_path, struct dentry *dentry,\n\t\t\t   const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\t__u32 dosattr, origattr;\n\tFILE_BASIC_INFO *info_buf = NULL;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/*\n\t * We cannot rename the file if the server doesn't support\n\t * CAP_INFOLEVEL_PASSTHRU\n\t */\n\tif (!(tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = DELETE | FILE_WRITE_ATTRIBUTES;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0)\n\t\tgoto out;\n\n\torigattr = cifsInode->cifsAttrs;\n\tif (origattr == 0)\n\t\torigattr |= ATTR_NORMAL;\n\n\tdosattr = origattr & ~ATTR_READONLY;\n\tif (dosattr == 0)\n\t\tdosattr |= ATTR_NORMAL;\n\tdosattr |= ATTR_HIDDEN;\n\n\t/* set ATTR_HIDDEN and clear ATTR_READONLY, but only if needed */\n\tif (dosattr != origattr) {\n\t\tinfo_buf = kzalloc(sizeof(*info_buf), GFP_KERNEL);\n\t\tif (info_buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_close;\n\t\t}\n\t\tinfo_buf->Attributes = cpu_to_le32(dosattr);\n\t\trc = CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid);\n\t\t/* although we would like to mark the file hidden\n \t\t   if that fails we will still try to rename it */\n\t\tif (!rc)\n\t\t\tcifsInode->cifsAttrs = dosattr;\n\t\telse\n\t\t\tdosattr = origattr; /* since not able to change them */\n\t}\n\n\t/* rename the file */\n\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid, NULL,\n\t\t\t\t   cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\tif (rc != 0) {\n\t\trc = -EBUSY;\n\t\tgoto undo_setattr;\n\t}\n\n\t/* try to set DELETE_ON_CLOSE */\n\tif (!test_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags)) {\n\t\trc = CIFSSMBSetFileDisposition(xid, tcon, true, fid.netfid,\n\t\t\t\t\t       current->tgid);\n\t\t/*\n\t\t * some samba versions return -ENOENT when we try to set the\n\t\t * file disposition here. Likely a samba bug, but work around\n\t\t * it for now. This means that some cifsXXX files may hang\n\t\t * around after they shouldn't.\n\t\t *\n\t\t * BB: remove this hack after more servers have the fix\n\t\t */\n\t\tif (rc == -ENOENT)\n\t\t\trc = 0;\n\t\telse if (rc != 0) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto undo_rename;\n\t\t}\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags);\n\t}\n\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tkfree(info_buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n\n\t/*\n\t * reset everything back to the original state. Don't bother\n\t * dealing with errors here since we can't do anything about\n\t * them anyway.\n\t */\nundo_rename:\n\tCIFSSMBRenameOpenFile(xid, tcon, fid.netfid, dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\nundo_setattr:\n\tif (dosattr != origattr) {\n\t\tinfo_buf->Attributes = cpu_to_le32(origattr);\n\t\tif (!CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid))\n\t\t\tcifsInode->cifsAttrs = origattr;\n\t}\n\n\tgoto out_close;\n}\n\n/* copied from fs/nfs/dir.c with small changes */\nstatic void\ncifs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * If dentry->d_inode is null (usually meaning the cached dentry\n * is a negative dentry) then we would attempt a standard SMB delete, but\n * if that fails we can not attempt the fall back mechanisms on EACCESS\n * but will return the EACCESS to the caller. Note that the VFS does not call\n * unlink on negative dentries currently.\n */\nint cifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifs_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct iattr *attrs = NULL;\n\t__u32 dosattr = 0, origattr = 0;\n\n\tcifs_dbg(FYI, \"cifs_unlink, dir=0x%p, dentry=0x%p\\n\", dir, dentry);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\txid = get_xid();\n\n\t/* Unlink can be called from rename so we can not take the\n\t * sb->s_vfs_rename_mutex here */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto unlink_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = CIFSPOSIXDelFile(xid, tcon, full_path,\n\t\t\tSMB_POSIX_UNLINK_FILE_TARGET, cifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\t\tcifs_dbg(FYI, \"posix del rc %d\\n\", rc);\n\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\tgoto psx_del_no_retry;\n\t}\n\nretry_std_delete:\n\tif (!server->ops->unlink) {\n\t\trc = -ENOSYS;\n\t\tgoto psx_del_no_retry;\n\t}\n\n\trc = server->ops->unlink(xid, tcon, full_path, cifs_sb);\n\npsx_del_no_retry:\n\tif (!rc) {\n\t\tif (inode)\n\t\t\tcifs_drop_nlink(inode);\n\t} else if (rc == -ENOENT) {\n\t\td_drop(dentry);\n\t} else if (rc == -EBUSY) {\n\t\tif (server->ops->rename_pending_delete) {\n\t\t\trc = server->ops->rename_pending_delete(full_path,\n\t\t\t\t\t\t\t\tdentry, xid);\n\t\t\tif (rc == 0)\n\t\t\t\tcifs_drop_nlink(inode);\n\t\t}\n\t} else if ((rc == -EACCES) && (dosattr == 0) && inode) {\n\t\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\t\tif (attrs == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_reval;\n\t\t}\n\n\t\t/* try to reset dos attributes */\n\t\tcifs_inode = CIFS_I(inode);\n\t\torigattr = cifs_inode->cifsAttrs;\n\t\tif (origattr == 0)\n\t\t\torigattr |= ATTR_NORMAL;\n\t\tdosattr = origattr & ~ATTR_READONLY;\n\t\tif (dosattr == 0)\n\t\t\tdosattr |= ATTR_NORMAL;\n\t\tdosattr |= ATTR_HIDDEN;\n\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\tif (rc != 0)\n\t\t\tgoto out_reval;\n\n\t\tgoto retry_std_delete;\n\t}\n\n\t/* undo the setattr if we errored out and it's needed */\n\tif (rc != 0 && dosattr != 0)\n\t\tcifs_set_file_info(inode, attrs, xid, full_path, origattr);\n\nout_reval:\n\tif (inode) {\n\t\tcifs_inode = CIFS_I(inode);\n\t\tcifs_inode->time = 0;\t/* will force revalidate to get info\n\t\t\t\t\t   when needed */\n\t\tinode->i_ctime = current_fs_time(sb);\n\t}\n\tdir->i_ctime = dir->i_mtime = current_fs_time(sb);\n\tcifs_inode = CIFS_I(dir);\n\tCIFS_I(dir)->time = 0;\t/* force revalidate of dir as well */\nunlink_out:\n\tkfree(full_path);\n\tkfree(attrs);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ncifs_mkdir_qinfo(struct inode *parent, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tstruct inode *inode = NULL;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, parent->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, parent->i_sb,\n\t\t\t\t\t xid, NULL);\n\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * setting nlink not necessary except in cases where we failed to get it\n\t * from the server or was set bogus. Also, since this is a brand new\n\t * inode, no need to grab the i_lock before setting the i_nlink.\n\t */\n\tif (inode->i_nlink < 2)\n\t\tset_nlink(inode, 2);\n\tmode &= ~current_umask();\n\t/* must turn on setgid bit if parent dir has it */\n\tif (parent->i_mode & S_ISGID)\n\t\tmode |= S_ISGID;\n\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode,\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (parent->i_mode & S_ISGID)\n\t\t\t\targs.gid = parent->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t       cifs_sb->local_nls,\n\t\t\t\t       cifs_remap(cifs_sb));\n\t} else {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t\t    (mode & S_IWUGO) == 0 && server->ops->mkdir_setinfo)\n\t\t\tserver->ops->mkdir_setinfo(inode, full_path, cifs_sb,\n\t\t\t\t\t\t   tcon, xid);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\tinode->i_mode = (mode | S_IFDIR);\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\tinode->i_uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\tinode->i_gid = parent->i_gid;\n\t\t\telse\n\t\t\t\tinode->i_gid = current_fsgid();\n\t\t}\n\t}\n\td_instantiate(dentry, inode);\n\treturn rc;\n}\n\nstatic int\ncifs_posix_mkdir(struct inode *inode, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tu32 oplock = 0;\n\tFILE_UNIX_BASIC_INFO *info = NULL;\n\tstruct inode *newinode = NULL;\n\tstruct cifs_fattr fattr;\n\n\tinfo = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (info == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tmode &= ~current_umask();\n\trc = CIFSPOSIXCreate(xid, tcon, SMB_O_DIRECTORY | SMB_O_CREAT, mode,\n\t\t\t     NULL /* netfid */, info, &oplock, full_path,\n\t\t\t     cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tif (rc == -EOPNOTSUPP)\n\t\tgoto posix_mkdir_out;\n\telse if (rc) {\n\t\tcifs_dbg(FYI, \"posix mkdir returned 0x%x\\n\", rc);\n\t\td_drop(dentry);\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tif (info->Type == cpu_to_le32(-1))\n\t\t/* no return info, go query for it */\n\t\tgoto posix_mkdir_get_info;\n\t/*\n\t * BB check (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID ) to see if\n\t * need to set uid/gid.\n\t */\n\n\tcifs_unix_basic_to_fattr(&fattr, info, cifs_sb);\n\tcifs_fill_uniqueid(inode->i_sb, &fattr);\n\tnewinode = cifs_iget(inode->i_sb, &fattr);\n\tif (!newinode)\n\t\tgoto posix_mkdir_get_info;\n\n\td_instantiate(dentry, newinode);\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tcifs_dbg(FYI, \"instantiated dentry %p %pd to inode %p\\n\",\n\t\t dentry, dentry, newinode);\n\n\tif (newinode->i_nlink != 2)\n\t\tcifs_dbg(FYI, \"unexpected number of links %d\\n\",\n\t\t\t newinode->i_nlink);\n#endif\n\nposix_mkdir_out:\n\tkfree(info);\n\treturn rc;\nposix_mkdir_get_info:\n\trc = cifs_mkdir_qinfo(inode, dentry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\n\tgoto posix_mkdir_out;\n}\n\nint cifs_mkdir(struct inode *inode, struct dentry *direntry, umode_t mode)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path;\n\n\tcifs_dbg(FYI, \"In cifs_mkdir, mode = 0x%hx inode = 0x%p\\n\",\n\t\t mode, inode);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mkdir_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_mkdir(inode, direntry, mode, full_path, cifs_sb,\n\t\t\t\t      tcon, xid);\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto mkdir_out;\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->mkdir) {\n\t\trc = -ENOSYS;\n\t\tgoto mkdir_out;\n\t}\n\n\t/* BB add setting the equivalent of mode via CreateX w/ACLs */\n\trc = server->ops->mkdir(xid, tcon, full_path, cifs_sb);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_mkdir returned 0x%x\\n\", rc);\n\t\td_drop(direntry);\n\t\tgoto mkdir_out;\n\t}\n\n\trc = cifs_mkdir_qinfo(inode, direntry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\nmkdir_out:\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tCIFS_I(inode)->time = 0;\n\tkfree(full_path);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint cifs_rmdir(struct inode *inode, struct dentry *direntry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path = NULL;\n\tstruct cifsInodeInfo *cifsInode;\n\n\tcifs_dbg(FYI, \"cifs_rmdir, inode = 0x%p\\n\", inode);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rmdir_exit;\n\t}\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rmdir) {\n\t\trc = -ENOSYS;\n\t\tcifs_put_tlink(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\n\trc = server->ops->rmdir(xid, tcon, full_path, cifs_sb);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tspin_lock(&direntry->d_inode->i_lock);\n\t\ti_size_write(direntry->d_inode, 0);\n\t\tclear_nlink(direntry->d_inode);\n\t\tspin_unlock(&direntry->d_inode->i_lock);\n\t}\n\n\tcifsInode = CIFS_I(direntry->d_inode);\n\t/* force revalidate to go get info when needed */\n\tcifsInode->time = 0;\n\n\tcifsInode = CIFS_I(inode);\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tcifsInode->time = 0;\n\n\tdirentry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =\n\t\tcurrent_fs_time(inode->i_sb);\n\nrmdir_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_do_rename(const unsigned int xid, struct dentry *from_dentry,\n\t       const char *from_path, struct dentry *to_dentry,\n\t       const char *to_path)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(from_dentry->d_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tint oplock, rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rename)\n\t\treturn -ENOSYS;\n\n\t/* try path-based rename first */\n\trc = server->ops->rename(xid, tcon, from_path, to_path, cifs_sb);\n\n\t/*\n\t * Don't bother with rename by filehandle unless file is busy and\n\t * source. Note that cross directory moves do not work with\n\t * rename by filehandle to various Windows servers.\n\t */\n\tif (rc == 0 || rc != -EBUSY)\n\t\tgoto do_rename_exit;\n\n\t/* open-file renames don't work across directories */\n\tif (to_dentry->d_parent != from_dentry->d_parent)\n\t\tgoto do_rename_exit;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\t/* open the file to be renamed -- we need DELETE perms */\n\toparms.desired_access = DELETE;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = from_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc == 0) {\n\t\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid,\n\t\t\t\t(const char *) to_dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\ndo_rename_exit:\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\ncifs_rename2(struct inode *source_dir, struct dentry *source_dentry,\n\t     struct inode *target_dir, struct dentry *target_dentry,\n\t     unsigned int flags)\n{\n\tchar *from_name = NULL;\n\tchar *to_name = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tFILE_UNIX_BASIC_INFO *info_buf_source = NULL;\n\tFILE_UNIX_BASIC_INFO *info_buf_target;\n\tunsigned int xid;\n\tint rc, tmprc;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(source_dir->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\t/*\n\t * we already have the rename sem so we do not need to\n\t * grab it again here to protect the path integrity\n\t */\n\tfrom_name = build_path_from_dentry(source_dentry);\n\tif (from_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\tto_name = build_path_from_dentry(target_dentry);\n\tif (to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\trc = cifs_do_rename(xid, source_dentry, from_name, target_dentry,\n\t\t\t    to_name);\n\n\t/*\n\t * No-replace is the natural behavior for CIFS, so skip unlink hacks.\n\t */\n\tif (flags & RENAME_NOREPLACE)\n\t\tgoto cifs_rename_exit;\n\n\tif (rc == -EEXIST && tcon->unix_ext) {\n\t\t/*\n\t\t * Are src and dst hardlinks of same inode? We can only tell\n\t\t * with unix extensions enabled.\n\t\t */\n\t\tinfo_buf_source =\n\t\t\tkmalloc(2 * sizeof(FILE_UNIX_BASIC_INFO),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (info_buf_source == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\n\t\tinfo_buf_target = info_buf_source + 1;\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, from_name,\n\t\t\t\t\t     info_buf_source,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tif (tmprc != 0)\n\t\t\tgoto unlink_target;\n\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, to_name,\n\t\t\t\t\t     info_buf_target,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\n\t\tif (tmprc == 0 && (info_buf_source->UniqueId ==\n\t\t\t\t   info_buf_target->UniqueId)) {\n\t\t\t/* same file, POSIX says that this is a noop */\n\t\t\trc = 0;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\t}\n\t/*\n\t * else ... BB we could add the same check for Windows by\n\t * checking the UniqueId via FILE_INTERNAL_INFO\n\t */\n\nunlink_target:\n\t/* Try unlinking the target dentry if it's not negative */\n\tif (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {\n\t\tif (d_is_dir(target_dentry))\n\t\t\ttmprc = cifs_rmdir(target_dir, target_dentry);\n\t\telse\n\t\t\ttmprc = cifs_unlink(target_dir, target_dentry);\n\t\tif (tmprc)\n\t\t\tgoto cifs_rename_exit;\n\t\trc = cifs_do_rename(xid, source_dentry, from_name,\n\t\t\t\t    target_dentry, to_name);\n\t}\n\n\t/* force revalidate to go get info when needed */\n\tCIFS_I(source_dir)->time = CIFS_I(target_dir)->time = 0;\n\n\tsource_dir->i_ctime = source_dir->i_mtime = target_dir->i_ctime =\n\t\ttarget_dir->i_mtime = current_fs_time(source_dir->i_sb);\n\ncifs_rename_exit:\n\tkfree(info_buf_source);\n\tkfree(from_name);\n\tkfree(to_name);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic bool\ncifs_inode_needs_reval(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (CIFS_CACHE_READ(cifs_i))\n\t\treturn false;\n\n\tif (!lookupCacheEnabled)\n\t\treturn true;\n\n\tif (cifs_i->time == 0)\n\t\treturn true;\n\n\tif (!cifs_sb->actimeo)\n\t\treturn true;\n\n\tif (!time_in_range(jiffies, cifs_i->time,\n\t\t\t\tcifs_i->time + cifs_sb->actimeo))\n\t\treturn true;\n\n\t/* hardlinked files w/ noserverino get \"special\" treatment */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) &&\n\t    S_ISREG(inode->i_mode) && inode->i_nlink != 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Zap the cache. Called when invalid_mapping flag is set.\n */\nint\ncifs_invalidate_mapping(struct inode *inode)\n{\n\tint rc = 0;\n\n\tif (inode->i_mapping && inode->i_mapping->nrpages != 0) {\n\t\trc = invalidate_inode_pages2(inode->i_mapping);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: could not invalidate inode %p\\n\",\n\t\t\t\t __func__, inode);\n\t}\n\n\tcifs_fscache_reset_inode_cookie(inode);\n\treturn rc;\n}\n\n/**\n * cifs_wait_bit_killable - helper for functions that are sleeping on bit locks\n * @word: long word containing the bit lock\n */\nstatic int\ncifs_wait_bit_killable(struct wait_bit_key *key)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tfreezable_schedule_unsafe();\n\treturn 0;\n}\n\nint\ncifs_revalidate_mapping(struct inode *inode)\n{\n\tint rc;\n\tunsigned long *flags = &CIFS_I(inode)->flags;\n\n\trc = wait_on_bit_lock_action(flags, CIFS_INO_LOCK, cifs_wait_bit_killable,\n\t\t\t\t     TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (test_and_clear_bit(CIFS_INO_INVALID_MAPPING, flags)) {\n\t\trc = cifs_invalidate_mapping(inode);\n\t\tif (rc)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, flags);\n\t}\n\n\tclear_bit_unlock(CIFS_INO_LOCK, flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(flags, CIFS_INO_LOCK);\n\n\treturn rc;\n}\n\nint\ncifs_zap_mapping(struct inode *inode)\n{\n\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_revalidate_file_attr(struct file *filp)\n{\n\tint rc = 0;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *) filp->private_data;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\tif (tlink_tcon(cfile->tlink)->unix_ext)\n\t\trc = cifs_get_file_info_unix(filp);\n\telse\n\t\trc = cifs_get_file_info(filp);\n\n\treturn rc;\n}\n\nint cifs_revalidate_dentry_attr(struct dentry *dentry)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *full_path = NULL;\n\n\tif (inode == NULL)\n\t\treturn -ENOENT;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\txid = get_xid();\n\n\t/* can not safely grab the rename sem here if rename calls revalidate\n\t   since that would deadlock */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"Update attributes: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld\\n\",\n\t\t full_path, inode, inode->i_count.counter,\n\t\t dentry, dentry->d_time, jiffies);\n\n\tif (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, sb, xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, sb,\n\t\t\t\t\t xid, NULL);\n\nout:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_revalidate_file(struct file *filp)\n{\n\tint rc;\n\tstruct inode *inode = file_inode(filp);\n\n\trc = cifs_revalidate_file_attr(filp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\n/* revalidate a dentry's inode attributes */\nint cifs_revalidate_dentry(struct dentry *dentry)\n{\n\tint rc;\n\tstruct inode *inode = dentry->d_inode;\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint rc;\n\n\t/*\n\t * We need to be sure that all dirty pages are written and the server\n\t * has actual ctime, mtime and file length.\n\t */\n\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t    inode->i_mapping->nrpages != 0) {\n\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\tif (rc) {\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = CIFS_MAX_MSGSIZE;\n\tstat->ino = CIFS_I(inode)->uniqueid;\n\n\t/*\n\t * If on a multiuser mount without unix extensions or cifsacl being\n\t * enabled, and the admin hasn't overridden them, set the ownership\n\t * to the fsuid/fsgid of the current process.\n\t */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER) &&\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t    !tcon->unix_ext) {\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID))\n\t\t\tstat->uid = current_fsuid();\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID))\n\t\t\tstat->gid = current_fsgid();\n\t}\n\treturn rc;\n}\n\nstatic int cifs_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\tint rc = 0;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn rc;\n}\n\nstatic void cifs_setsize(struct inode *inode, loff_t offset)\n{\n\tspin_lock(&inode->i_lock);\n\ti_size_write(inode, offset);\n\tspin_unlock(&inode->i_lock);\n\n\ttruncate_pagecache(inode, offset);\n}\n\nstatic int\ncifs_set_file_size(struct inode *inode, struct iattr *attrs,\n\t\t   unsigned int xid, char *full_path)\n{\n\tint rc;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_io_parms io_parms;\n\n\t/*\n\t * To avoid spurious oplock breaks from server, in the case of\n\t * inodes that we already have open, avoid doing path based\n\t * setting of file size if we can do it by handle.\n\t * This keeps our caching token (oplock) and avoids timeouts\n\t * when the local oplock break takes longer to flush\n\t * writebehind data than the SMB timeout for the SetPathInfo\n\t * request would allow\n\t */\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->set_file_size)\n\t\t\trc = server->ops->set_file_size(xid, tcon, open_file,\n\t\t\t\t\t\t\tattrs->ia_size, false);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifsFileInfo_put(open_file);\n\t\tcifs_dbg(FYI, \"SetFSize for attrs rc = %d\\n\", rc);\n\t\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = open_file->fid.netfid;\n\t\t\tio_parms.pid = open_file->pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written,\n\t\t\t\t\t  NULL, NULL, 1);\n\t\t\tcifs_dbg(FYI, \"Wrt seteof rc %d\\n\", rc);\n\t\t}\n\t} else\n\t\trc = -EINVAL;\n\n\tif (!rc)\n\t\tgoto set_size_out;\n\n\tif (tcon == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t\tserver = tcon->ses->server;\n\t}\n\n\t/*\n\t * Set file size by pathname rather than by handle either because no\n\t * valid, writeable file handle for it was found or because there was\n\t * an error setting it by handle.\n\t */\n\tif (server->ops->set_path_size)\n\t\trc = server->ops->set_path_size(xid, tcon, full_path,\n\t\t\t\t\t\tattrs->ia_size, cifs_sb, false);\n\telse\n\t\trc = -ENOSYS;\n\tcifs_dbg(FYI, \"SetEOF by path (setattrs) rc = %d\\n\", rc);\n\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t__u16 netfid;\n\t\tint oplock = 0;\n\n\t\trc = SMBLegacyOpen(xid, tcon, full_path, FILE_OPEN,\n\t\t\t\t   GENERIC_WRITE, CREATE_NOT_DIR, &netfid,\n\t\t\t\t   &oplock, NULL, cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\t\tif (rc == 0) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = netfid;\n\t\t\tio_parms.pid = current->tgid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written, NULL,\n\t\t\t\t\t  NULL,  1);\n\t\t\tcifs_dbg(FYI, \"wrt seteof rc %d\\n\", rc);\n\t\t\tCIFSSMBClose(xid, tcon, netfid);\n\t\t}\n\t}\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\nset_size_out:\n\tif (rc == 0) {\n\t\tcifsInode->server_eof = attrs->ia_size;\n\t\tcifs_setsize(inode, attrs->ia_size);\n\t\tcifs_truncate_page(inode->i_mapping, inode->i_size);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)\n{\n\tint rc;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_unix_set_info_args *args = NULL;\n\tstruct cifsFileInfo *open_file;\n\n\tcifs_dbg(FYI, \"setattr_unix on file %pd attrs->ia_valid=0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\txid = get_xid();\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\targs = kmalloc(sizeof(*args), GFP_KERNEL);\n\tif (args == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* set up the struct */\n\tif (attrs->ia_valid & ATTR_MODE)\n\t\targs->mode = attrs->ia_mode;\n\telse\n\t\targs->mode = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\targs->uid = attrs->ia_uid;\n\telse\n\t\targs->uid = INVALID_UID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\targs->gid = attrs->ia_gid;\n\telse\n\t\targs->gid = INVALID_GID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_ATIME)\n\t\targs->atime = cifs_UnixTimeToNT(attrs->ia_atime);\n\telse\n\t\targs->atime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_MTIME)\n\t\targs->mtime = cifs_UnixTimeToNT(attrs->ia_mtime);\n\telse\n\t\targs->mtime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_CTIME)\n\t\targs->ctime = cifs_UnixTimeToNT(attrs->ia_ctime);\n\telse\n\t\targs->ctime = NO_CHANGE_64;\n\n\targs->device = 0;\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\tu16 nfid = open_file->fid.netfid;\n\t\tu32 npid = open_file->pid;\n\t\tpTcon = tlink_tcon(open_file->tlink);\n\t\trc = CIFSSMBUnixSetFileInfo(xid, pTcon, args, nfid, npid);\n\t\tcifsFileInfo_put(open_file);\n\t} else {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink)) {\n\t\t\trc = PTR_ERR(tlink);\n\t\t\tgoto out;\n\t\t}\n\t\tpTcon = tlink_tcon(tlink);\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, args,\n\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tcifs_put_tlink(tlink);\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\n\t/* force revalidate when any of these times are set since some\n\t   of the fs types (eg ext3, fat) do not have fine enough\n\t   time granularity to match protocol, and we do not have a\n\t   a way (yet) to query the server fs's time granularity (and\n\t   whether it rounds times down).\n\t*/\n\tif (attrs->ia_valid & (ATTR_MTIME | ATTR_CTIME))\n\t\tcifsInode->time = 0;\nout:\n\tkfree(args);\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)\n{\n\tunsigned int xid;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tchar *full_path = NULL;\n\tint rc = -EACCES;\n\t__u32 dosattr = 0;\n\t__u64 mode = NO_CHANGE_64;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"setattr on file %pd attrs->iavalid 0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0) {\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto cifs_setattr_exit;\n\t}\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\tuid = attrs->ia_uid;\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\tgid = attrs->ia_gid;\n\n#ifdef CONFIG_CIFS_ACL\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\tif (uid_valid(uid) || gid_valid(gid)) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, NO_CHANGE_64,\n\t\t\t\t\t\t\tuid, gid);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting id failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t}\n\t} else\n#endif /* CONFIG_CIFS_ACL */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID))\n\t\tattrs->ia_valid &= ~(ATTR_UID | ATTR_GID);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\tif (attrs->ia_valid & ATTR_MODE) {\n\t\tmode = attrs->ia_mode;\n\t\trc = 0;\n#ifdef CONFIG_CIFS_ACL\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, mode,\n\t\t\t\t\t\tINVALID_UID, INVALID_GID);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting ACL failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_CIFS_ACL */\n\t\tif (((mode & S_IWUGO) == 0) &&\n\t\t    (cifsInode->cifsAttrs & ATTR_READONLY) == 0) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs | ATTR_READONLY;\n\n\t\t\t/* fix up mode if we're not using dynperm */\n\t\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM) == 0)\n\t\t\t\tattrs->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\t} else if ((mode & S_IWUGO) &&\n\t\t\t   (cifsInode->cifsAttrs & ATTR_READONLY)) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs & ~ATTR_READONLY;\n\t\t\t/* Attributes of 0 are ignored */\n\t\t\tif (dosattr == 0)\n\t\t\t\tdosattr |= ATTR_NORMAL;\n\n\t\t\t/* reset local inode permissions to normal */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t\tattrs->ia_mode &= ~(S_IALLUGO);\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_dir_mode;\n\t\t\t\telse\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_file_mode;\n\t\t\t}\n\t\t} else if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t/* ignore mode change - ATTR_READONLY hasn't changed */\n\t\t\tattrs->ia_valid &= ~ATTR_MODE;\n\t\t}\n\t}\n\n\tif (attrs->ia_valid & (ATTR_MTIME|ATTR_ATIME|ATTR_CTIME) ||\n\t    ((attrs->ia_valid & ATTR_MODE) && dosattr)) {\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\t/* BB: check for rc = -EOPNOTSUPP and switch to legacy mode */\n\n\t\t/* Even if error on time set, no sense failing the call if\n\t\tthe server would set the time to a reasonable value anyway,\n\t\tand this check ensures that we are not being called from\n\t\tsys_utimes in which case we ought to fail the call back to\n\t\tthe user when the server rejects the call */\n\t\tif ((rc) && (attrs->ia_valid &\n\t\t\t\t(ATTR_MODE | ATTR_GID | ATTR_UID | ATTR_SIZE)))\n\t\t\trc = 0;\n\t}\n\n\t/* do not need local check to inode_check_ok since the server does\n\t   that */\n\tif (rc)\n\t\tgoto cifs_setattr_exit;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\ncifs_setattr_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_setattr(struct dentry *direntry, struct iattr *attrs)\n{\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (pTcon->unix_ext)\n\t\treturn cifs_setattr_unix(direntry, attrs);\n\n\treturn cifs_setattr_nounix(direntry, attrs);\n\n\t/* BB: add cifs_setattr_legacy for really old servers */\n}\n\n#if 0\nvoid cifs_delete_inode(struct inode *inode)\n{\n\tcifs_dbg(FYI, \"In cifs_delete_inode, inode = 0x%p\\n\", inode);\n\t/* may have to add back in if and when safe distributed caching of\n\t   directories added e.g. via FindNotify */\n}\n#endif",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/freezer.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)  /* SETFILEBITS valid bits */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In cifs_delete_inode, inode = 0x%p\\n\"",
            "inode"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setattr_nounix",
          "args": [
            "direntry",
            "attrs"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setattr_unix",
          "args": [
            "direntry",
            "attrs"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attrs"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attrs->ia_size"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_file_info",
          "args": [
            "inode",
            "attrs",
            "xid",
            "full_path",
            "dosattr"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Setting ACL failed with error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_mode_to_cifs_acl",
          "args": [
            "inode",
            "full_path",
            "mode",
            "INVALID_UID",
            "INVALID_GID"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "id_mode_to_cifs_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "1051-1119",
          "snippet": "int\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Setting id failed with error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_set_file_size",
          "args": [
            "inode",
            "attrs",
            "xid",
            "full_path"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attrs"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"setattr on file %pd attrs->iavalid 0x%x\\n\"",
            "direntry",
            "attrs->ia_valid"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attrs->ia_size"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixSetPathInfo",
          "args": [
            "xid",
            "pTcon",
            "full_path",
            "args",
            "cifs_sb->local_nls",
            "cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixSetPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "6056-6132",
          "snippet": "int\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "open_file"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixSetFileInfo",
          "args": [
            "xid",
            "pTcon",
            "args",
            "nfid",
            "npid"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixSetFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5991-6054",
          "snippet": "int\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writable_file",
          "args": [
            "cifsInode",
            "true"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "find_writable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1753-1831",
          "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_UnixTimeToNT",
          "args": [
            "attrs->ia_ctime"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_UnixTimeToNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "951-956",
          "snippet": "u64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\n#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)\n\nu64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*args)",
            "GFP_KERNEL"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_set_file_size",
          "args": [
            "inode",
            "attrs",
            "xid",
            "full_path"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"setattr_unix on file %pd attrs->ia_valid=0x%x\\n\"",
            "direntry",
            "attrs->ia_valid"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_truncate_page",
          "args": [
            "inode->i_mapping",
            "inode->i_size"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_setsize",
          "args": [
            "inode",
            "attrs->ia_size"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "netfid"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"wrt seteof rc %d\\n\"",
            "rc"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBWrite",
          "args": [
            "xid",
            "&io_parms",
            "&bytes_written",
            "NULL",
            "NULL",
            "1"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1754-1879",
          "snippet": "int\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cifs_dbg(FYI, \"write at %lld %d bytes\\n\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMBLegacyOpen",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "FILE_OPEN",
            "GENERIC_WRITE",
            "CREATE_NOT_DIR",
            "&netfid",
            "&oplock",
            "NULL",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "SMBLegacyOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1164-1269",
          "snippet": "int\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetEOF by path (setattrs) rc = %d\\n\"",
            "rc"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_path_size",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "attrs->ia_size",
            "cifs_sb",
            "false"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Wrt seteof rc %d\\n\"",
            "rc"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SetFSize for attrs rc = %d\\n\"",
            "rc"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_file_size",
          "args": [
            "xid",
            "tcon",
            "open_file",
            "attrs->ia_size",
            "false"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_dentry_attr",
          "args": [
            "dentry"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_mapping",
          "args": [
            "inode"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_dentry_attr",
          "args": [
            "dentry"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_mapping",
          "args": [
            "inode"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_file_attr",
          "args": [
            "filp"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&inode",
            "full_path",
            "NULL",
            "sb",
            "xid",
            "NULL"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&inode",
            "full_path",
            "sb",
            "xid"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Update attributes: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld\\n\"",
            "full_path",
            "inode",
            "inode->i_count.counter",
            "dentry",
            "dentry->d_time",
            "jiffies"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_inode_needs_reval",
          "args": [
            "inode"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_file_info",
          "args": [
            "filp"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_file_info_unix",
          "args": [
            "filp"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_inode_needs_reval",
          "args": [
            "inode"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_mapping",
          "args": [
            "inode"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INO_INVALID_MAPPING",
            "&CIFS_I(inode)->flags"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "flags",
            "CIFS_INO_LOCK"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "CIFS_INO_LOCK",
            "flags"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_invalidate_mapping",
          "args": [
            "inode"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CIFS_INO_INVALID_MAPPING",
            "flags"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_lock_action",
          "args": [
            "flags",
            "CIFS_INO_LOCK",
            "cifs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule_unsafe",
          "args": [],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fscache_reset_inode_cookie",
          "args": [
            "inode"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_reset_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "109-126",
          "snippet": "void cifs_fscache_reset_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct fscache_cookie *old = cifsi->fscache;\n\n\tif (cifsi->fscache) {\n\t\t/* retire the current fscache cache and get a new one */\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\n\t\tcifsi->fscache = fscache_acquire_cookie(\n\t\t\t\t\tcifs_sb_master_tcon(cifs_sb)->fscache,\n\t\t\t\t\t&cifs_fscache_inode_object_def,\n\t\t\t\t\tcifsi, true);\n\t\tcifs_dbg(FYI, \"%s: new cookie 0x%p oldcookie 0x%p\\n\",\n\t\t\t __func__, cifsi->fscache, old);\n\t}\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_reset_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct fscache_cookie *old = cifsi->fscache;\n\n\tif (cifsi->fscache) {\n\t\t/* retire the current fscache cache and get a new one */\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\n\t\tcifsi->fscache = fscache_acquire_cookie(\n\t\t\t\t\tcifs_sb_master_tcon(cifs_sb)->fscache,\n\t\t\t\t\t&cifs_fscache_inode_object_def,\n\t\t\t\t\tcifsi, true);\n\t\tcifs_dbg(FYI, \"%s: new cookie 0x%p oldcookie 0x%p\\n\",\n\t\t\t __func__, cifsi->fscache, old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: could not invalidate inode %p\\n\"",
            "__func__",
            "inode"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "jiffies",
            "cifs_i->time",
            "cifs_i->time + cifs_sb->actimeo"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cifs_i"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "to_name"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "from_name"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info_buf_source"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "source_dir->i_sb"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_do_rename",
          "args": [
            "xid",
            "source_dentry",
            "from_name",
            "target_dentry",
            "to_name"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unlink",
          "args": [
            "target_dir",
            "target_dentry"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_rmdir",
          "args": [
            "target_dir",
            "target_dentry"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "target_dentry"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixQPathInfo",
          "args": [
            "xid",
            "tcon",
            "to_name",
            "info_buf_target",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixQPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4261-4342",
          "snippet": "int\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QPathInfo (Unix) the path %s\\n\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QPathInfo (Unix) the path %s\\n\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_do_rename",
          "args": [
            "xid",
            "source_dentry",
            "from_name",
            "target_dentry",
            "to_name"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBRenameOpenFile",
          "args": [
            "xid",
            "tcon",
            "fid.netfid",
            "(const char *) to_dentry->d_name.name",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBRenameOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2634-2714",
          "snippet": "int CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"Rename to File by handle\\n\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Rename (by file handle) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"Rename to File by handle\\n\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Rename (by file handle) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->rename",
          "args": [
            "xid",
            "tcon",
            "from_path",
            "to_path",
            "cifs_sb"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "direntry->d_inode"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->rmdir",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "cifs_sb"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_rmdir, inode = 0x%p\\n\"",
            "inode"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_mkdir_qinfo",
          "args": [
            "inode",
            "direntry",
            "mode",
            "full_path",
            "cifs_sb",
            "tcon",
            "xid"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "direntry"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_mkdir returned 0x%x\\n\"",
            "rc"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mkdir",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "cifs_sb"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_posix_mkdir",
          "args": [
            "inode",
            "direntry",
            "mode",
            "full_path",
            "cifs_sb",
            "tcon",
            "xid"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"In cifs_mkdir, mode = 0x%hx inode = 0x%p\\n\"",
            "mode",
            "inode"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_mkdir_qinfo",
          "args": [
            "inode",
            "dentry",
            "mode",
            "full_path",
            "cifs_sb",
            "tcon",
            "xid"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unexpected number of links %d\\n\"",
            "newinode->i_nlink"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"instantiated dentry %p %pd to inode %p\\n\"",
            "dentry",
            "dentry",
            "newinode"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "newinode"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_iget",
          "args": [
            "inode->i_sb",
            "&fattr"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_uniqueid",
          "args": [
            "inode->i_sb",
            "&fattr"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unix_basic_to_fattr",
          "args": [
            "&fattr",
            "info",
            "cifs_sb"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"posix mkdir returned 0x%x\\n\"",
            "rc"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSPOSIXCreate",
          "args": [
            "xid",
            "tcon",
            "SMB_O_DIRECTORY | SMB_O_CREAT",
            "mode",
            "NULL/* netfid */",
            "info",
            "&oplock",
            "full_path",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSPOSIXCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "997-1118",
          "snippet": "int\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(FILE_UNIX_BASIC_INFO)",
            "GFP_KERNEL"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mkdir_setinfo",
          "args": [
            "inode",
            "full_path",
            "cifs_sb",
            "tcon",
            "xid"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&inode",
            "full_path",
            "NULL",
            "parent->i_sb",
            "xid",
            "NULL"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&inode",
            "full_path",
            "parent->i_sb",
            "xid"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attrs"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "sb"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "sb"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_file_info",
          "args": [
            "inode",
            "attrs",
            "xid",
            "full_path",
            "origattr"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_file_info",
          "args": [
            "inode",
            "attrs",
            "xid",
            "full_path",
            "dosattr"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attrs)",
            "GFP_KERNEL"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->rename_pending_delete",
          "args": [
            "full_path",
            "dentry",
            "xid"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->unlink",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "cifs_sb"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"posix del rc %d\\n\"",
            "rc"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSPOSIXDelFile",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "SMB_POSIX_UNLINK_FILE_TARGET",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSPOSIXDelFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "785-859",
          "snippet": "int\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *fileName, __u16 type,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In POSIX delete\\n\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Posix delete returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *fileName, __u16 type,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In POSIX delete\\n\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Posix delete returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_unlink, dir=0x%p, dentry=0x%p\\n\"",
            "dir",
            "dentry"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetFileInfo",
          "args": [
            "xid",
            "tcon",
            "info_buf",
            "fid.netfid",
            "current->tgid"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5693-5755",
          "snippet": "int\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "origattr"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info_buf"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetFileDisposition",
          "args": [
            "xid",
            "tcon",
            "true",
            "fid.netfid",
            "current->tgid"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetFileDisposition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5757-5811",
          "snippet": "int\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set File Disposition (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetFileDisposition = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set File Disposition (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetFileDisposition = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CIFS_INO_DELETE_PENDING",
            "&cifsInode->flags"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dosattr"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*info_buf)",
            "GFP_KERNEL"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_file_info",
          "args": [
            "inode",
            "full_path",
            "&info_buf",
            "xid"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dosattr"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cifs_UnixTimeToNT(attrs->ia_ctime)"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"CIFS - CTIME changed\\n\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cifs_UnixTimeToNT(attrs->ia_mtime)"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cifs_UnixTimeToNT(attrs->ia_atime)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ipc connection - fake read inode\\n\""
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&inode",
            "\"\"",
            "NULL",
            "sb",
            "xid",
            "NULL"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"server does not support POSIX extensions\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&inode",
            "\"\"",
            "sb",
            "xid"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "ROOT_I"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_autodisable_serverino",
          "args": [
            "CIFS_SB(sb)"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_autodisable_serverino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "523-531",
          "snippet": "void\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_hashed_dentries",
          "args": [
            "inode"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "hash",
            "cifs_find_inode",
            "cifs_init_inode",
            "fattr"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_uniqueid_to_ino_t",
          "args": [
            "fattr->cf_uniqueid"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_uniqueid_to_ino_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.h",
          "lines": "41-45",
          "snippet": "static inline ino_t\ncifs_uniqueid_to_ino_t(u64 fileid)\n{\n\treturn (ino_t)hash_64(fileid, (sizeof(ino_t) * 8) - 1) + 1;\n}",
          "includes": [
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n\nstatic inline ino_t\ncifs_uniqueid_to_ino_t(u64 fileid)\n{\n\treturn (ino_t)hash_64(fileid, (sizeof(ino_t) * 8) - 1) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"looking for uniqueid=%llu\\n\"",
            "fattr->cf_uniqueid"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "dentry",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&inode->i_dentry"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "*inode",
            "&fattr"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_iget",
          "args": [
            "sb",
            "&fattr"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"check_mf_symlink: %d\\n\"",
            "tmprc"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mf_symlink",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "&fattr",
            "full_path"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "check_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "270-318",
          "snippet": "int\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t const unsigned char *path)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tif (!couldbe_mf_symlink(fattr))\n\t\t/* it's not a symlink */\n\t\treturn 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) /* not a symlink */\n\t\tgoto out;\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, NULL);\n\tif (rc == -EINVAL) {\n\t\t/* it's not a symlink */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t/* it is a symlink */\n\tfattr->cf_eof = link_len;\n\tfattr->cf_mode &= ~S_IFMT;\n\tfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\n\tfattr->cf_dtype = DT_LNK;\nout:\n\tkfree(buf);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nint\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t const unsigned char *path)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\n\tif (!couldbe_mf_symlink(fattr))\n\t\t/* it's not a symlink */\n\t\treturn 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0) /* not a symlink */\n\t\tgoto out;\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, NULL);\n\tif (rc == -EINVAL) {\n\t\t/* it's not a symlink */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t/* it is a symlink */\n\tfattr->cf_eof = link_len;\n\tfattr->cf_mode &= ~S_IFMT;\n\tfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\n\tfattr->cf_dtype = DT_LNK;\nout:\n\tkfree(buf);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sfu_mode",
          "args": [
            "&fattr",
            "full_path",
            "cifs_sb",
            "xid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Getting ACL failed with error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_acl_to_fattr",
          "args": [
            "cifs_sb",
            "&fattr",
            "*inode",
            "full_path",
            "fid"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_acl_to_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "1007-1048",
          "snippet": "int\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_sfu_type failed: %d\\n\"",
            "tmprc"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sfu_type",
          "args": [
            "&fattr",
            "full_path",
            "cifs_sb",
            "xid"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"GetSrvInodeNum rc %d\\n\"",
            "tmprc"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->get_srv_inum",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path",
            "&fattr.cf_uniqueid",
            "data"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "srchinf"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "srchinf->ntwrk_buf_start"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dir_info_to_fattr",
          "args": [
            "&fattr",
            "(FILE_DIRECTORY_INFO *)data",
            "cifs_sb"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dir_info_to_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "192-206",
          "snippet": "void\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSFindFirst",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "cifs_sb",
            "NULL",
            "srchflgs",
            "srchinf",
            "false"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSFindFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4345-4498",
          "snippet": "int\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifs_search_info)",
            "GFP_KERNEL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_create_dfs_fattr",
          "args": [
            "&fattr",
            "sb"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_all_info_to_fattr",
          "args": [
            "&fattr",
            "data",
            "cifs_sb",
            "adjust_tz",
            "symlink"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->query_path_info",
          "args": [
            "xid",
            "tcon",
            "cifs_sb",
            "full_path",
            "data",
            "&adjust_tz",
            "&symlink"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"No need to revalidate cached inode sizes\\n\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(*inode)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Getting info on %s\\n\"",
            "full_path"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "inode",
            "&fattr"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_create_dfs_fattr",
          "args": [
            "&fattr",
            "inode->i_sb"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_all_info_to_fattr",
          "args": [
            "&fattr",
            "&find_data",
            "cifs_sb",
            "false",
            "false"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->query_file_info",
          "args": [
            "xid",
            "tcon",
            "&cfile->fid",
            "&find_data"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "1",
            "\"bogus file nlink value %u\\n\"",
            "fattr->cf_nlink"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->NumberOfLinks"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_NTtimeToUnix",
          "args": [
            "info->LastWriteTime"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_NTtimeToUnix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "921-948",
          "snippet": "struct timespec\ncifs_NTtimeToUnix(__le64 ntutc)\n{\n\tstruct timespec ts;\n\t/* BB what about the timezone? BB */\n\n\t/* Subtract the NTFS time offset, then convert to 1s intervals. */\n\ts64 t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\n\tu64 abs_t;\n\n\t/*\n\t * Unfortunately can not use normal 64 bit division on 32 bit arch, but\n\t * the alternative, do_div, does not work with negative numbers so have\n\t * to special case them\n\t */\n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = (long)(do_div(abs_t, 10000000) * 100);\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = (long)do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\n#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)\n\nstruct timespec\ncifs_NTtimeToUnix(__le64 ntutc)\n{\n\tstruct timespec ts;\n\t/* BB what about the timezone? BB */\n\n\t/* Subtract the NTFS time offset, then convert to 1s intervals. */\n\ts64 t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\n\tu64 abs_t;\n\n\t/*\n\t * Unfortunately can not use normal 64 bit division on 32 bit arch, but\n\t * the alternative, do_div, does not work with negative numbers so have\n\t * to special case them\n\t */\n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = (long)(do_div(abs_t, 10000000) * 100);\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = (long)do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fattr",
            "0",
            "sizeof(*fattr)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"special mode bits 0%o\\n\"",
            "mode"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"special bits 0%o org mode 0%o\\n\"",
            "mode",
            "fattr->cf_mode"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->query_all_EAs",
          "args": [
            "xid",
            "tcon",
            "path",
            "\"SETFILEBITS\"",
            "ea_value",
            "4/* size of buf */",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Symlink\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"IntxLNK\"",
            "pbuf",
            "7"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "mjr",
            "mnr"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Char device\\n\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"IntxCHR\"",
            "pbuf",
            "8"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "mjr",
            "mnr"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Block device\\n\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"IntxBLK\"",
            "pbuf",
            "8"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->sync_read",
          "args": [
            "xid",
            "&fid",
            "&io_parms",
            "&bytes_read",
            "&pbuf",
            "&buf_type"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"check sfu type of %s, open rc = %d\\n\"",
            "path",
            "rc"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "*pinode",
            "&fattr"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_iget",
          "args": [
            "sb",
            "&fattr"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_uniqueid",
          "args": [
            "sb",
            "&fattr"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"check_mf_symlink: %d\\n\"",
            "tmprc"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_create_dfs_fattr",
          "args": [
            "&fattr",
            "sb"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unix_basic_to_fattr",
          "args": [
            "&fattr",
            "&find_data",
            "cifs_sb"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Getting info on %s\\n\"",
            "full_path"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "inode",
            "&fattr"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_create_dfs_fattr",
          "args": [
            "&fattr",
            "inode->i_sb"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unix_basic_to_fattr",
          "args": [
            "&fattr",
            "&find_data",
            "cifs_sb"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixQFileInfo",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.netfid",
            "&find_data"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixQFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4193-4259",
          "snippet": "int\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fattr",
            "0",
            "sizeof(*fattr)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"creating fake fattr for DFS referral\\n\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unknown type %d\\n\"",
            "le32_to_cpu(info->Type)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "le64_to_cpu(info->DevMajor)",
            "le64_to_cpu(info->DevMinor) & MINORMASK"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "le64_to_cpu(info->DevMajor)",
            "le64_to_cpu(info->DevMinor) & MINORMASK"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fattr",
            "0",
            "sizeof(*fattr)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_ops",
          "args": [
            "inode"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/inode.c",
          "lines": "37-2429",
          "snippet": "static void cifs_set_ops(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &cifs_file_inode_ops;\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_direct_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_direct_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_strict_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_strict_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tinode->i_fop = &cifs_file_nobrl_ops;\n\t\telse { /* not direct, send byte range locks */\n\t\t\tinode->i_fop = &cifs_file_ops;\n\t\t}\n\n\t\t/* check if server can support readpages */\n\t\tif (cifs_sb_master_tcon(cifs_sb)->ses->server->maxBuf <\n\t\t\t\tPAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops_smallbuf;\n\t\telse\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops;\n\t\tbreak;\n\tcase S_IFDIR:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (IS_AUTOMOUNT(inode)) {\n\t\t\tinode->i_op = &cifs_dfs_referral_inode_operations;\n\t\t} else {\n#else /* NO DFS support, treat as a directory */\n\t\t{\n#endif\n\t\t\tinode->i_op = &cifs_dir_inode_ops;\n\t\t\tinode->i_fop = &cifs_dir_ops;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &cifs_symlink_inode_ops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n\n/* check inode attributes against fattr. If they don't match, tag the\n * inode for cache invalidation\n */\nstatic void\ncifs_revalidate_cache(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\n\tcifs_dbg(FYI, \"%s: revalidating inode %llu\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is new\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t/* don't bother with revalidation if we have an oplock */\n\tif (CIFS_CACHE_READ(cifs_i)) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is oplocked\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t /* revalidate if mtime or size have changed */\n\tif (timespec_equal(&inode->i_mtime, &fattr->cf_mtime) &&\n\t    cifs_i->server_eof == fattr->cf_eof) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is unchanged\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\tcifs_dbg(FYI, \"%s: invalidating inode %llu mapping\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\tset_bit(CIFS_INO_INVALID_MAPPING, &cifs_i->flags);\n}\n\n/*\n * copy nlink to the inode, unless it wasn't provided.  Provide\n * sane values if we don't have an existing one and none was provided\n */\nstatic void\ncifs_nlink_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\t/*\n\t * if we're in a situation where we can't trust what we\n\t * got from the server (readdir, some non-unix cases)\n\t * fake reasonable values\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_UNKNOWN_NLINK) {\n\t\t/* only provide fake values on a new inode */\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY)\n\t\t\t\tset_nlink(inode, 2);\n\t\t\telse\n\t\t\t\tset_nlink(inode, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* we trust the server, so update it */\n\tset_nlink(inode, fattr->cf_nlink);\n}\n\n/* populate an inode with info from a cifs_fattr struct */\nvoid\ncifs_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tcifs_revalidate_cache(inode, fattr);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_atime = fattr->cf_atime;\n\tinode->i_mtime = fattr->cf_mtime;\n\tinode->i_ctime = fattr->cf_ctime;\n\tinode->i_rdev = fattr->cf_rdev;\n\tcifs_nlink_fattr_to_inode(inode, fattr);\n\tinode->i_uid = fattr->cf_uid;\n\tinode->i_gid = fattr->cf_gid;\n\n\t/* if dynperm is set, don't clobber existing mode */\n\tif (inode->i_state & I_NEW ||\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM))\n\t\tinode->i_mode = fattr->cf_mode;\n\n\tcifs_i->cifsAttrs = fattr->cf_cifsattrs;\n\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\tcifs_i->time = 0;\n\telse\n\t\tcifs_i->time = jiffies;\n\n\tif (fattr->cf_flags & CIFS_FATTR_DELETE_PENDING)\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\telse\n\t\tclear_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\n\tcifs_i->server_eof = fattr->cf_eof;\n\t/*\n\t * Can't safely change the file size here if the client is writing to\n\t * it due to potential races.\n\t */\n\tif (is_size_safe_to_change(cifs_i, fattr->cf_eof)) {\n\t\ti_size_write(inode, fattr->cf_eof);\n\n\t\t/*\n\t\t * i_blocks is not related to (i_size / i_blksize),\n\t\t * but instead 512 byte (2**9) size is required for\n\t\t * calculating num blocks.\n\t\t */\n\t\tinode->i_blocks = (512 - 1 + fattr->cf_bytes) >> 9;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (fattr->cf_flags & CIFS_FATTR_DFS_REFERRAL)\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\tif (inode->i_state & I_NEW)\n\t\tcifs_set_ops(inode);\n}\n\nvoid\ncifs_fill_uniqueid(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\treturn;\n\n\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n}\n\n/* Fill a cifs_fattr struct with info from FILE_UNIX_BASIC_INFO. */\nvoid\ncifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,\n\t\t\t struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_uniqueid = le64_to_cpu(info->UniqueId);\n\tfattr->cf_bytes = le64_to_cpu(info->NumOfBytes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastModificationTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->LastStatusChange);\n\tfattr->cf_mode = le64_to_cpu(info->Permissions);\n\n\t/*\n\t * Since we set the inode type below we need to mask off\n\t * to avoid strange results if bits set above.\n\t */\n\tfattr->cf_mode &= ~S_IFMT;\n\tswitch (le32_to_cpu(info->Type)) {\n\tcase UNIX_FILE:\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tbreak;\n\tcase UNIX_SYMLINK:\n\t\tfattr->cf_mode |= S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tcase UNIX_DIR:\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\tbreak;\n\tcase UNIX_CHARDEV:\n\t\tfattr->cf_mode |= S_IFCHR;\n\t\tfattr->cf_dtype = DT_CHR;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_BLOCKDEV:\n\t\tfattr->cf_mode |= S_IFBLK;\n\t\tfattr->cf_dtype = DT_BLK;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_FIFO:\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\tbreak;\n\tcase UNIX_SOCKET:\n\t\tfattr->cf_mode |= S_IFSOCK;\n\t\tfattr->cf_dtype = DT_SOCK;\n\t\tbreak;\n\tdefault:\n\t\t/* safest to call it a file if we do not know */\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tcifs_dbg(FYI, \"unknown type %d\\n\", le32_to_cpu(info->Type));\n\t\tbreak;\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)) {\n\t\tu64 id = le64_to_cpu(info->Uid);\n\t\tif (id < ((uid_t)-1)) {\n\t\t\tkuid_t uid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid))\n\t\t\t\tfattr->cf_uid = uid;\n\t\t}\n\t}\n\t\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)) {\n\t\tu64 id = le64_to_cpu(info->Gid);\n\t\tif (id < ((gid_t)-1)) {\n\t\t\tkgid_t gid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid))\n\t\t\t\tfattr->cf_gid = gid;\n\t\t}\n\t}\n\n\tfattr->cf_nlink = le64_to_cpu(info->Nlinks);\n}\n\n/*\n * Fill a cifs_fattr struct with fake inode info.\n *\n * Needed to setup cifs_fattr data for the directory which is the\n * junction to the new submount (ie to setup the fake directory\n * which represents a DFS referral).\n */\nstatic void\ncifs_create_dfs_fattr(struct cifs_fattr *fattr, struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"creating fake fattr for DFS referral\\n\");\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tfattr->cf_atime = CURRENT_TIME;\n\tfattr->cf_ctime = CURRENT_TIME;\n\tfattr->cf_mtime = CURRENT_TIME;\n\tfattr->cf_nlink = 2;\n\tfattr->cf_flags |= CIFS_FATTR_DFS_REFERRAL;\n}\n\nstatic int\ncifs_get_file_info_unix(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBUnixQFileInfo(xid, tcon, cfile->fid.netfid, &find_data);\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t}\n\n\tcifs_fattr_to_inode(inode, &fattr);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\t     const unsigned char *full_path,\n\t\t\t     struct super_block *sb, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/* could have done a find first instead but this returns more info */\n\trc = CIFSSMBUnixQPathInfo(xid, tcon, full_path, &find_data,\n\t\t\t\t  cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else {\n\t\treturn rc;\n\t}\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\tint tmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t     full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (*pinode == NULL) {\n\t\t/* get new inode */\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\t/* we already have inode, update it */\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_sfu_type(struct cifs_fattr *fattr, const char *path,\n\t      struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n\tint rc;\n\t__u32 oplock;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tchar buf[24];\n\tunsigned int bytes_read;\n\tchar *pbuf;\n\tint buf_type = CIFS_NO_BUFFER;\n\n\tpbuf = buf;\n\n\tfattr->cf_mode &= ~S_IFMT;\n\n\tif (fattr->cf_eof == 0) {\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\treturn 0;\n\t} else if (fattr->cf_eof < 8) {\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\treturn -EINVAL;\t /* EOPNOTSUPP? */\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"check sfu type of %s, open rc = %d\\n\", path, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/* Read header */\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = 24;\n\n\trc = tcon->ses->server->ops->sync_read(xid, &fid, &io_parms,\n\t\t\t\t\t&bytes_read, &pbuf, &buf_type);\n\tif ((rc == 0) && (bytes_read >= 8)) {\n\t\tif (memcmp(\"IntxBLK\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Block device\\n\");\n\t\t\tfattr->cf_mode |= S_IFBLK;\n\t\t\tfattr->cf_dtype = DT_BLK;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxCHR\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Char device\\n\");\n\t\t\tfattr->cf_mode |= S_IFCHR;\n\t\t\tfattr->cf_dtype = DT_CHR;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxLNK\", pbuf, 7) == 0) {\n\t\t\tcifs_dbg(FYI, \"Symlink\\n\");\n\t\t\tfattr->cf_mode |= S_IFLNK;\n\t\t\tfattr->cf_dtype = DT_LNK;\n\t\t} else {\n\t\t\tfattr->cf_mode |= S_IFREG; /* file? */\n\t\t\tfattr->cf_dtype = DT_REG;\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tfattr->cf_mode |= S_IFREG; /* then it is a file */\n\t\tfattr->cf_dtype = DT_REG;\n\t\trc = -EOPNOTSUPP; /* or some unknown SFU type */\n\t}\n\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)  /* SETFILEBITS valid bits */\n\n/*\n * Fetch mode bits as provided by SFU.\n *\n * FIXME: Doesn't this clobber the type bit we got from cifs_sfu_type ?\n */\nstatic int cifs_sfu_mode(struct cifs_fattr *fattr, const unsigned char *path,\n\t\t\t struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n#ifdef CONFIG_CIFS_XATTR\n\tssize_t rc;\n\tchar ea_value[4];\n\t__u32 mode;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (tcon->ses->server->ops->query_all_EAs == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = tcon->ses->server->ops->query_all_EAs(xid, tcon, path,\n\t\t\t\"SETFILEBITS\", ea_value, 4 /* size of buf */,\n\t\t\tcifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\tcifs_put_tlink(tlink);\n\tif (rc < 0)\n\t\treturn (int)rc;\n\telse if (rc > 3) {\n\t\tmode = le32_to_cpu(*((__le32 *)ea_value));\n\t\tfattr->cf_mode &= ~SFBITS_MASK;\n\t\tcifs_dbg(FYI, \"special bits 0%o org mode 0%o\\n\",\n\t\t\t mode, fattr->cf_mode);\n\t\tfattr->cf_mode = (mode & SFBITS_MASK) | fattr->cf_mode;\n\t\tcifs_dbg(FYI, \"special mode bits 0%o\\n\", mode);\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\n/* Fill a cifs_fattr struct with info from FILE_ALL_INFO */\nstatic void\ncifs_all_info_to_fattr(struct cifs_fattr *fattr, FILE_ALL_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb, bool adjust_tz,\n\t\t       bool symlink)\n{\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->Attributes);\n\tif (info->DeletePending)\n\t\tfattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;\n\n\tif (info->LastAccessTime)\n\t\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\telse\n\t\tfattr->cf_atime = CURRENT_TIME;\n\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tif (adjust_tz) {\n\t\tfattr->cf_ctime.tv_sec += tcon->ses->server->timeAdj;\n\t\tfattr->cf_mtime.tv_sec += tcon->ses->server->timeAdj;\n\t}\n\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\n\tfattr->cf_nlink = le32_to_cpu(info->NumberOfLinks);\n\n\tif (symlink) {\n\t\tfattr->cf_mode = S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t} else if (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\t/*\n\t\t * Server can return wrong NumberOfLinks value for directories\n\t\t * when Unix extensions are disabled - fake it.\n\t\t */\n\t\tif (!tcon->unix_ext)\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\n\t\t/* clear write bits if ATTR_READONLY is set */\n\t\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\t\tfattr->cf_mode &= ~(S_IWUGO);\n\n\t\t/*\n\t\t * Don't accept zero nlink from non-unix servers unless\n\t\t * delete is pending.  Instead mark it as unknown.\n\t\t */\n\t\tif ((fattr->cf_nlink < 1) && !tcon->unix_ext &&\n\t\t    !info->DeletePending) {\n\t\t\tcifs_dbg(1, \"bogus file nlink value %u\\n\",\n\t\t\t\tfattr->cf_nlink);\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t\t}\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n}\n\nstatic int\ncifs_get_file_info(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_ALL_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (!server->ops->query_file_info)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\trc = server->ops->query_file_info(xid, tcon, &cfile->fid, &find_data);\n\tswitch (rc) {\n\tcase 0:\n\t\tcifs_all_info_to_fattr(&fattr, &find_data, cifs_sb, false,\n\t\t\t\t       false);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EOPNOTSUPP:\n\tcase -EINVAL:\n\t\t/*\n\t\t * FIXME: legacy server -- fall back to path-based call?\n\t\t * for now, just skip revalidating and mark inode for\n\t\t * immediate reval.\n\t\t */\n\t\trc = 0;\n\t\tCIFS_I(inode)->time = 0;\n\tdefault:\n\t\tgoto cgfi_exit;\n\t}\n\n\t/*\n\t * don't bother with SFU junk here -- just mark inode as needing\n\t * revalidation.\n\t */\n\tfattr.cf_uniqueid = CIFS_I(inode)->uniqueid;\n\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\tcifs_fattr_to_inode(inode, &fattr);\ncgfi_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_get_inode_info(struct inode **inode, const char *full_path,\n\t\t    FILE_ALL_INFO *data, struct super_block *sb, int xid,\n\t\t    const struct cifs_fid *fid)\n{\n\tbool validinum = false;\n\t__u16 srchflgs;\n\tint rc = 0, tmprc = ENOSYS;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *buf = NULL;\n\tbool adjust_tz = false;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_search_info *srchinf = NULL;\n\tbool symlink = false;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\tif ((data == NULL) && (*inode != NULL)) {\n\t\tif (CIFS_CACHE_READ(CIFS_I(*inode))) {\n\t\t\tcifs_dbg(FYI, \"No need to revalidate cached inode sizes\\n\");\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n\n\t/* if inode info is not passed, get it from server */\n\tif (data == NULL) {\n\t\tif (!server->ops->query_path_info) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\t\tif (buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tdata = (FILE_ALL_INFO *)buf;\n\t\trc = server->ops->query_path_info(xid, tcon, cifs_sb, full_path,\n\t\t\t\t\t\t  data, &adjust_tz, &symlink);\n\t}\n\n\tif (!rc) {\n\t\tcifs_all_info_to_fattr(&fattr, data, cifs_sb, adjust_tz,\n\t\t\t\t       symlink);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else if (rc == -EACCES && backup_cred(cifs_sb)) {\n\t\t\tsrchinf = kzalloc(sizeof(struct cifs_search_info),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (srchinf == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto cgii_exit;\n\t\t\t}\n\n\t\t\tsrchinf->endOfSearch = false;\n\t\t\tsrchinf->info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\n\t\t\tsrchflgs = CIFS_SEARCH_CLOSE_ALWAYS |\n\t\t\t\t\tCIFS_SEARCH_CLOSE_AT_END |\n\t\t\t\t\tCIFS_SEARCH_BACKUP_SEARCH;\n\n\t\t\trc = CIFSFindFirst(xid, tcon, full_path,\n\t\t\t\tcifs_sb, NULL, srchflgs, srchinf, false);\n\t\t\tif (!rc) {\n\t\t\t\tdata =\n\t\t\t\t(FILE_ALL_INFO *)srchinf->srch_entries_start;\n\n\t\t\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t(FILE_DIRECTORY_INFO *)data, cifs_sb);\n\t\t\t\tfattr.cf_uniqueid = le64_to_cpu(\n\t\t\t\t((SEARCH_ID_FULL_DIR_INFO *)data)->UniqueId);\n\t\t\t\tvalidinum = true;\n\n\t\t\t\tcifs_buf_release(srchinf->ntwrk_buf_start);\n\t\t\t}\n\t\t\tkfree(srchinf);\n\t} else\n\t\tgoto cgii_exit;\n\n\t/*\n\t * If an inode wasn't passed in, then get the inode number\n\t *\n\t * Is an i_ino of zero legal? Can we use that to check if the server\n\t * supports returning inode numbers?  Are there other sanity checks we\n\t * can use to ensure that the server is really filling in that field?\n\t */\n\tif (*inode == NULL) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\t\tif (validinum == false) {\n\t\t\t\tif (server->ops->get_srv_inum)\n\t\t\t\t\ttmprc = server->ops->get_srv_inum(xid,\n\t\t\t\t\t\ttcon, cifs_sb, full_path,\n\t\t\t\t\t\t&fattr.cf_uniqueid, data);\n\t\t\t\tif (tmprc) {\n\t\t\t\t\tcifs_dbg(FYI, \"GetSrvInodeNum rc %d\\n\",\n\t\t\t\t\t\t tmprc);\n\t\t\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\t\tcifs_autodisable_serverino(cifs_sb);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t} else\n\t\tfattr.cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\n\t/* query for SFU type info if supported and needed */\n\tif (fattr.cf_cifsattrs & ATTR_SYSTEM &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL) {\n\t\ttmprc = cifs_sfu_type(&fattr, full_path, cifs_sb, xid);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"cifs_sfu_type failed: %d\\n\", tmprc);\n\t}\n\n#ifdef CONFIG_CIFS_ACL\n\t/* fill in 0777 bits from ACL */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\trc = cifs_acl_to_fattr(cifs_sb, &fattr, *inode, full_path, fid);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: Getting ACL failed with error: %d\\n\",\n\t\t\t\t __func__, rc);\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n#endif /* CONFIG_CIFS_ACL */\n\n\t/* fill in remaining high mode bits e.g. SUID, VTX */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tcifs_sfu_mode(&fattr, full_path, cifs_sb, xid);\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (!*inode) {\n\t\t*inode = cifs_iget(sb, &fattr);\n\t\tif (!*inode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\tcifs_fattr_to_inode(*inode, &fattr);\n\t}\n\ncgii_exit:\n\tkfree(buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic const struct inode_operations cifs_ipc_inode_ops = {\n\t.lookup = cifs_lookup,\n};\n\nstatic int\ncifs_find_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\t/* don't match inode with different uniqueid */\n\tif (CIFS_I(inode)->uniqueid != fattr->cf_uniqueid)\n\t\treturn 0;\n\n\t/* use createtime like an i_generation field */\n\tif (CIFS_I(inode)->createtime != fattr->cf_createtime)\n\t\treturn 0;\n\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (fattr->cf_mode & S_IFMT))\n\t\treturn 0;\n\n\t/* if it's not a directory or has no dentries, then flag it */\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry))\n\t\tfattr->cf_flags |= CIFS_FATTR_INO_COLLISION;\n\n\treturn 1;\n}\n\nstatic int\ncifs_init_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\tCIFS_I(inode)->uniqueid = fattr->cf_uniqueid;\n\tCIFS_I(inode)->createtime = fattr->cf_createtime;\n\treturn 0;\n}\n\n/*\n * walk dentry list for an inode and report whether it has aliases that\n * are hashed. We use this to determine if a directory inode can actually\n * be used.\n */\nstatic bool\ninode_has_hashed_dentries(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (!d_unhashed(dentry) || IS_ROOT(dentry)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn false;\n}\n\n/* Given fattrs, get a corresponding inode */\nstruct inode *\ncifs_iget(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tunsigned long hash;\n\tstruct inode *inode;\n\nretry_iget5_locked:\n\tcifs_dbg(FYI, \"looking for uniqueid=%llu\\n\", fattr->cf_uniqueid);\n\n\t/* hash down to 32-bits on 32-bit arch */\n\thash = cifs_uniqueid_to_ino_t(fattr->cf_uniqueid);\n\n\tinode = iget5_locked(sb, hash, cifs_find_inode, cifs_init_inode, fattr);\n\tif (inode) {\n\t\t/* was there a potentially problematic inode collision? */\n\t\tif (fattr->cf_flags & CIFS_FATTR_INO_COLLISION) {\n\t\t\tfattr->cf_flags &= ~CIFS_FATTR_INO_COLLISION;\n\n\t\t\tif (inode_has_hashed_dentries(inode)) {\n\t\t\t\tcifs_autodisable_serverino(CIFS_SB(sb));\n\t\t\t\tiput(inode);\n\t\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\tgoto retry_iget5_locked;\n\t\t\t}\n\t\t}\n\n\t\tcifs_fattr_to_inode(inode, fattr);\n\t\tif (sb->s_flags & MS_NOATIME)\n\t\t\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tinode->i_ino = hash;\n#ifdef CONFIG_CIFS_FSCACHE\n\t\t\t/* initialize per-inode cache cookie pointer */\n\t\t\tCIFS_I(inode)->fscache = NULL;\n#endif\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\n/* gets root inode */\nstruct inode *cifs_root_iget(struct super_block *sb)\n{\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct inode *inode = NULL;\n\tlong rc;\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\txid = get_xid();\n\tif (tcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&inode, \"\", sb, xid);\n\t\t/* some servers mistakenly claim POSIX support */\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto iget_no_retry;\n\t\tcifs_dbg(VFS, \"server does not support POSIX extensions\");\n\t\ttcon->unix_ext = false;\n\t}\n\n\trc = cifs_get_inode_info(&inode, \"\", NULL, sb, xid, NULL);\n\niget_no_retry:\n\tif (!inode) {\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_FSCACHE\n\t/* populate tcon->resource_id */\n\ttcon->resource_id = CIFS_I(inode)->uniqueid;\n#endif\n\n\tif (rc && tcon->ipc) {\n\t\tcifs_dbg(FYI, \"ipc connection - fake read inode\\n\");\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_mode |= S_IFDIR;\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &cifs_ipc_inode_ops;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_uid = cifs_sb->mnt_uid;\n\t\tinode->i_gid = cifs_sb->mnt_gid;\n\t\tspin_unlock(&inode->i_lock);\n\t} else if (rc) {\n\t\tiget_failed(inode);\n\t\tinode = ERR_PTR(rc);\n\t}\n\nout:\n\t/* can not call macro free_xid here since in a void func\n\t * TODO: This is no longer true\n\t */\n\t_free_xid(xid);\n\treturn inode;\n}\n\nint\ncifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,\n\t\t   char *full_path, __u32 dosattr)\n{\n\tbool set_time = false;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct TCP_Server_Info *server;\n\tFILE_BASIC_INFO\tinfo_buf;\n\n\tif (attrs == NULL)\n\t\treturn -EINVAL;\n\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\n\tif (!server->ops->set_file_info)\n\t\treturn -ENOSYS;\n\n\tif (attrs->ia_valid & ATTR_ATIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastAccessTime =\n\t\t\tcpu_to_le64(cifs_UnixTimeToNT(attrs->ia_atime));\n\t} else\n\t\tinfo_buf.LastAccessTime = 0;\n\n\tif (attrs->ia_valid & ATTR_MTIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastWriteTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_mtime));\n\t} else\n\t\tinfo_buf.LastWriteTime = 0;\n\n\t/*\n\t * Samba throws this field away, but windows may actually use it.\n\t * Do not set ctime unless other time stamps are changed explicitly\n\t * (i.e. by utimes()) since we would then have a mix of client and\n\t * server times.\n\t */\n\tif (set_time && (attrs->ia_valid & ATTR_CTIME)) {\n\t\tcifs_dbg(FYI, \"CIFS - CTIME changed\\n\");\n\t\tinfo_buf.ChangeTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_ctime));\n\t} else\n\t\tinfo_buf.ChangeTime = 0;\n\n\tinfo_buf.CreationTime = 0;\t/* don't change */\n\tinfo_buf.Attributes = cpu_to_le32(dosattr);\n\n\treturn server->ops->set_file_info(inode, full_path, &info_buf, xid);\n}\n\n/*\n * Open the given file (if it isn't already), set the DELETE_ON_CLOSE bit\n * and rename it to a random name that hopefully won't conflict with\n * anything else.\n */\nint\ncifs_rename_pending_delete(const char *full_path, struct dentry *dentry,\n\t\t\t   const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\t__u32 dosattr, origattr;\n\tFILE_BASIC_INFO *info_buf = NULL;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/*\n\t * We cannot rename the file if the server doesn't support\n\t * CAP_INFOLEVEL_PASSTHRU\n\t */\n\tif (!(tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = DELETE | FILE_WRITE_ATTRIBUTES;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0)\n\t\tgoto out;\n\n\torigattr = cifsInode->cifsAttrs;\n\tif (origattr == 0)\n\t\torigattr |= ATTR_NORMAL;\n\n\tdosattr = origattr & ~ATTR_READONLY;\n\tif (dosattr == 0)\n\t\tdosattr |= ATTR_NORMAL;\n\tdosattr |= ATTR_HIDDEN;\n\n\t/* set ATTR_HIDDEN and clear ATTR_READONLY, but only if needed */\n\tif (dosattr != origattr) {\n\t\tinfo_buf = kzalloc(sizeof(*info_buf), GFP_KERNEL);\n\t\tif (info_buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_close;\n\t\t}\n\t\tinfo_buf->Attributes = cpu_to_le32(dosattr);\n\t\trc = CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid);\n\t\t/* although we would like to mark the file hidden\n \t\t   if that fails we will still try to rename it */\n\t\tif (!rc)\n\t\t\tcifsInode->cifsAttrs = dosattr;\n\t\telse\n\t\t\tdosattr = origattr; /* since not able to change them */\n\t}\n\n\t/* rename the file */\n\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid, NULL,\n\t\t\t\t   cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\tif (rc != 0) {\n\t\trc = -EBUSY;\n\t\tgoto undo_setattr;\n\t}\n\n\t/* try to set DELETE_ON_CLOSE */\n\tif (!test_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags)) {\n\t\trc = CIFSSMBSetFileDisposition(xid, tcon, true, fid.netfid,\n\t\t\t\t\t       current->tgid);\n\t\t/*\n\t\t * some samba versions return -ENOENT when we try to set the\n\t\t * file disposition here. Likely a samba bug, but work around\n\t\t * it for now. This means that some cifsXXX files may hang\n\t\t * around after they shouldn't.\n\t\t *\n\t\t * BB: remove this hack after more servers have the fix\n\t\t */\n\t\tif (rc == -ENOENT)\n\t\t\trc = 0;\n\t\telse if (rc != 0) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto undo_rename;\n\t\t}\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags);\n\t}\n\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tkfree(info_buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n\n\t/*\n\t * reset everything back to the original state. Don't bother\n\t * dealing with errors here since we can't do anything about\n\t * them anyway.\n\t */\nundo_rename:\n\tCIFSSMBRenameOpenFile(xid, tcon, fid.netfid, dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\nundo_setattr:\n\tif (dosattr != origattr) {\n\t\tinfo_buf->Attributes = cpu_to_le32(origattr);\n\t\tif (!CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid))\n\t\t\tcifsInode->cifsAttrs = origattr;\n\t}\n\n\tgoto out_close;\n}\n\n/* copied from fs/nfs/dir.c with small changes */\nstatic void\ncifs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * If dentry->d_inode is null (usually meaning the cached dentry\n * is a negative dentry) then we would attempt a standard SMB delete, but\n * if that fails we can not attempt the fall back mechanisms on EACCESS\n * but will return the EACCESS to the caller. Note that the VFS does not call\n * unlink on negative dentries currently.\n */\nint cifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifs_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct iattr *attrs = NULL;\n\t__u32 dosattr = 0, origattr = 0;\n\n\tcifs_dbg(FYI, \"cifs_unlink, dir=0x%p, dentry=0x%p\\n\", dir, dentry);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\txid = get_xid();\n\n\t/* Unlink can be called from rename so we can not take the\n\t * sb->s_vfs_rename_mutex here */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto unlink_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = CIFSPOSIXDelFile(xid, tcon, full_path,\n\t\t\tSMB_POSIX_UNLINK_FILE_TARGET, cifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\t\tcifs_dbg(FYI, \"posix del rc %d\\n\", rc);\n\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\tgoto psx_del_no_retry;\n\t}\n\nretry_std_delete:\n\tif (!server->ops->unlink) {\n\t\trc = -ENOSYS;\n\t\tgoto psx_del_no_retry;\n\t}\n\n\trc = server->ops->unlink(xid, tcon, full_path, cifs_sb);\n\npsx_del_no_retry:\n\tif (!rc) {\n\t\tif (inode)\n\t\t\tcifs_drop_nlink(inode);\n\t} else if (rc == -ENOENT) {\n\t\td_drop(dentry);\n\t} else if (rc == -EBUSY) {\n\t\tif (server->ops->rename_pending_delete) {\n\t\t\trc = server->ops->rename_pending_delete(full_path,\n\t\t\t\t\t\t\t\tdentry, xid);\n\t\t\tif (rc == 0)\n\t\t\t\tcifs_drop_nlink(inode);\n\t\t}\n\t} else if ((rc == -EACCES) && (dosattr == 0) && inode) {\n\t\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\t\tif (attrs == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_reval;\n\t\t}\n\n\t\t/* try to reset dos attributes */\n\t\tcifs_inode = CIFS_I(inode);\n\t\torigattr = cifs_inode->cifsAttrs;\n\t\tif (origattr == 0)\n\t\t\torigattr |= ATTR_NORMAL;\n\t\tdosattr = origattr & ~ATTR_READONLY;\n\t\tif (dosattr == 0)\n\t\t\tdosattr |= ATTR_NORMAL;\n\t\tdosattr |= ATTR_HIDDEN;\n\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\tif (rc != 0)\n\t\t\tgoto out_reval;\n\n\t\tgoto retry_std_delete;\n\t}\n\n\t/* undo the setattr if we errored out and it's needed */\n\tif (rc != 0 && dosattr != 0)\n\t\tcifs_set_file_info(inode, attrs, xid, full_path, origattr);\n\nout_reval:\n\tif (inode) {\n\t\tcifs_inode = CIFS_I(inode);\n\t\tcifs_inode->time = 0;\t/* will force revalidate to get info\n\t\t\t\t\t   when needed */\n\t\tinode->i_ctime = current_fs_time(sb);\n\t}\n\tdir->i_ctime = dir->i_mtime = current_fs_time(sb);\n\tcifs_inode = CIFS_I(dir);\n\tCIFS_I(dir)->time = 0;\t/* force revalidate of dir as well */\nunlink_out:\n\tkfree(full_path);\n\tkfree(attrs);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ncifs_mkdir_qinfo(struct inode *parent, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tstruct inode *inode = NULL;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, parent->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, parent->i_sb,\n\t\t\t\t\t xid, NULL);\n\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * setting nlink not necessary except in cases where we failed to get it\n\t * from the server or was set bogus. Also, since this is a brand new\n\t * inode, no need to grab the i_lock before setting the i_nlink.\n\t */\n\tif (inode->i_nlink < 2)\n\t\tset_nlink(inode, 2);\n\tmode &= ~current_umask();\n\t/* must turn on setgid bit if parent dir has it */\n\tif (parent->i_mode & S_ISGID)\n\t\tmode |= S_ISGID;\n\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode,\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (parent->i_mode & S_ISGID)\n\t\t\t\targs.gid = parent->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t       cifs_sb->local_nls,\n\t\t\t\t       cifs_remap(cifs_sb));\n\t} else {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t\t    (mode & S_IWUGO) == 0 && server->ops->mkdir_setinfo)\n\t\t\tserver->ops->mkdir_setinfo(inode, full_path, cifs_sb,\n\t\t\t\t\t\t   tcon, xid);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\tinode->i_mode = (mode | S_IFDIR);\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\tinode->i_uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\tinode->i_gid = parent->i_gid;\n\t\t\telse\n\t\t\t\tinode->i_gid = current_fsgid();\n\t\t}\n\t}\n\td_instantiate(dentry, inode);\n\treturn rc;\n}\n\nstatic int\ncifs_posix_mkdir(struct inode *inode, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tu32 oplock = 0;\n\tFILE_UNIX_BASIC_INFO *info = NULL;\n\tstruct inode *newinode = NULL;\n\tstruct cifs_fattr fattr;\n\n\tinfo = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (info == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tmode &= ~current_umask();\n\trc = CIFSPOSIXCreate(xid, tcon, SMB_O_DIRECTORY | SMB_O_CREAT, mode,\n\t\t\t     NULL /* netfid */, info, &oplock, full_path,\n\t\t\t     cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tif (rc == -EOPNOTSUPP)\n\t\tgoto posix_mkdir_out;\n\telse if (rc) {\n\t\tcifs_dbg(FYI, \"posix mkdir returned 0x%x\\n\", rc);\n\t\td_drop(dentry);\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tif (info->Type == cpu_to_le32(-1))\n\t\t/* no return info, go query for it */\n\t\tgoto posix_mkdir_get_info;\n\t/*\n\t * BB check (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID ) to see if\n\t * need to set uid/gid.\n\t */\n\n\tcifs_unix_basic_to_fattr(&fattr, info, cifs_sb);\n\tcifs_fill_uniqueid(inode->i_sb, &fattr);\n\tnewinode = cifs_iget(inode->i_sb, &fattr);\n\tif (!newinode)\n\t\tgoto posix_mkdir_get_info;\n\n\td_instantiate(dentry, newinode);\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tcifs_dbg(FYI, \"instantiated dentry %p %pd to inode %p\\n\",\n\t\t dentry, dentry, newinode);\n\n\tif (newinode->i_nlink != 2)\n\t\tcifs_dbg(FYI, \"unexpected number of links %d\\n\",\n\t\t\t newinode->i_nlink);\n#endif\n\nposix_mkdir_out:\n\tkfree(info);\n\treturn rc;\nposix_mkdir_get_info:\n\trc = cifs_mkdir_qinfo(inode, dentry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\n\tgoto posix_mkdir_out;\n}\n\nint cifs_mkdir(struct inode *inode, struct dentry *direntry, umode_t mode)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path;\n\n\tcifs_dbg(FYI, \"In cifs_mkdir, mode = 0x%hx inode = 0x%p\\n\",\n\t\t mode, inode);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mkdir_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_mkdir(inode, direntry, mode, full_path, cifs_sb,\n\t\t\t\t      tcon, xid);\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto mkdir_out;\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->mkdir) {\n\t\trc = -ENOSYS;\n\t\tgoto mkdir_out;\n\t}\n\n\t/* BB add setting the equivalent of mode via CreateX w/ACLs */\n\trc = server->ops->mkdir(xid, tcon, full_path, cifs_sb);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_mkdir returned 0x%x\\n\", rc);\n\t\td_drop(direntry);\n\t\tgoto mkdir_out;\n\t}\n\n\trc = cifs_mkdir_qinfo(inode, direntry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\nmkdir_out:\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tCIFS_I(inode)->time = 0;\n\tkfree(full_path);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint cifs_rmdir(struct inode *inode, struct dentry *direntry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path = NULL;\n\tstruct cifsInodeInfo *cifsInode;\n\n\tcifs_dbg(FYI, \"cifs_rmdir, inode = 0x%p\\n\", inode);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rmdir_exit;\n\t}\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rmdir) {\n\t\trc = -ENOSYS;\n\t\tcifs_put_tlink(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\n\trc = server->ops->rmdir(xid, tcon, full_path, cifs_sb);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tspin_lock(&direntry->d_inode->i_lock);\n\t\ti_size_write(direntry->d_inode, 0);\n\t\tclear_nlink(direntry->d_inode);\n\t\tspin_unlock(&direntry->d_inode->i_lock);\n\t}\n\n\tcifsInode = CIFS_I(direntry->d_inode);\n\t/* force revalidate to go get info when needed */\n\tcifsInode->time = 0;\n\n\tcifsInode = CIFS_I(inode);\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tcifsInode->time = 0;\n\n\tdirentry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =\n\t\tcurrent_fs_time(inode->i_sb);\n\nrmdir_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_do_rename(const unsigned int xid, struct dentry *from_dentry,\n\t       const char *from_path, struct dentry *to_dentry,\n\t       const char *to_path)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(from_dentry->d_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tint oplock, rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rename)\n\t\treturn -ENOSYS;\n\n\t/* try path-based rename first */\n\trc = server->ops->rename(xid, tcon, from_path, to_path, cifs_sb);\n\n\t/*\n\t * Don't bother with rename by filehandle unless file is busy and\n\t * source. Note that cross directory moves do not work with\n\t * rename by filehandle to various Windows servers.\n\t */\n\tif (rc == 0 || rc != -EBUSY)\n\t\tgoto do_rename_exit;\n\n\t/* open-file renames don't work across directories */\n\tif (to_dentry->d_parent != from_dentry->d_parent)\n\t\tgoto do_rename_exit;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\t/* open the file to be renamed -- we need DELETE perms */\n\toparms.desired_access = DELETE;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = from_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc == 0) {\n\t\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid,\n\t\t\t\t(const char *) to_dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\ndo_rename_exit:\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\ncifs_rename2(struct inode *source_dir, struct dentry *source_dentry,\n\t     struct inode *target_dir, struct dentry *target_dentry,\n\t     unsigned int flags)\n{\n\tchar *from_name = NULL;\n\tchar *to_name = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tFILE_UNIX_BASIC_INFO *info_buf_source = NULL;\n\tFILE_UNIX_BASIC_INFO *info_buf_target;\n\tunsigned int xid;\n\tint rc, tmprc;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(source_dir->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\t/*\n\t * we already have the rename sem so we do not need to\n\t * grab it again here to protect the path integrity\n\t */\n\tfrom_name = build_path_from_dentry(source_dentry);\n\tif (from_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\tto_name = build_path_from_dentry(target_dentry);\n\tif (to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\trc = cifs_do_rename(xid, source_dentry, from_name, target_dentry,\n\t\t\t    to_name);\n\n\t/*\n\t * No-replace is the natural behavior for CIFS, so skip unlink hacks.\n\t */\n\tif (flags & RENAME_NOREPLACE)\n\t\tgoto cifs_rename_exit;\n\n\tif (rc == -EEXIST && tcon->unix_ext) {\n\t\t/*\n\t\t * Are src and dst hardlinks of same inode? We can only tell\n\t\t * with unix extensions enabled.\n\t\t */\n\t\tinfo_buf_source =\n\t\t\tkmalloc(2 * sizeof(FILE_UNIX_BASIC_INFO),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (info_buf_source == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\n\t\tinfo_buf_target = info_buf_source + 1;\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, from_name,\n\t\t\t\t\t     info_buf_source,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tif (tmprc != 0)\n\t\t\tgoto unlink_target;\n\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, to_name,\n\t\t\t\t\t     info_buf_target,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\n\t\tif (tmprc == 0 && (info_buf_source->UniqueId ==\n\t\t\t\t   info_buf_target->UniqueId)) {\n\t\t\t/* same file, POSIX says that this is a noop */\n\t\t\trc = 0;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\t}\n\t/*\n\t * else ... BB we could add the same check for Windows by\n\t * checking the UniqueId via FILE_INTERNAL_INFO\n\t */\n\nunlink_target:\n\t/* Try unlinking the target dentry if it's not negative */\n\tif (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {\n\t\tif (d_is_dir(target_dentry))\n\t\t\ttmprc = cifs_rmdir(target_dir, target_dentry);\n\t\telse\n\t\t\ttmprc = cifs_unlink(target_dir, target_dentry);\n\t\tif (tmprc)\n\t\t\tgoto cifs_rename_exit;\n\t\trc = cifs_do_rename(xid, source_dentry, from_name,\n\t\t\t\t    target_dentry, to_name);\n\t}\n\n\t/* force revalidate to go get info when needed */\n\tCIFS_I(source_dir)->time = CIFS_I(target_dir)->time = 0;\n\n\tsource_dir->i_ctime = source_dir->i_mtime = target_dir->i_ctime =\n\t\ttarget_dir->i_mtime = current_fs_time(source_dir->i_sb);\n\ncifs_rename_exit:\n\tkfree(info_buf_source);\n\tkfree(from_name);\n\tkfree(to_name);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic bool\ncifs_inode_needs_reval(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (CIFS_CACHE_READ(cifs_i))\n\t\treturn false;\n\n\tif (!lookupCacheEnabled)\n\t\treturn true;\n\n\tif (cifs_i->time == 0)\n\t\treturn true;\n\n\tif (!cifs_sb->actimeo)\n\t\treturn true;\n\n\tif (!time_in_range(jiffies, cifs_i->time,\n\t\t\t\tcifs_i->time + cifs_sb->actimeo))\n\t\treturn true;\n\n\t/* hardlinked files w/ noserverino get \"special\" treatment */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) &&\n\t    S_ISREG(inode->i_mode) && inode->i_nlink != 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Zap the cache. Called when invalid_mapping flag is set.\n */\nint\ncifs_invalidate_mapping(struct inode *inode)\n{\n\tint rc = 0;\n\n\tif (inode->i_mapping && inode->i_mapping->nrpages != 0) {\n\t\trc = invalidate_inode_pages2(inode->i_mapping);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: could not invalidate inode %p\\n\",\n\t\t\t\t __func__, inode);\n\t}\n\n\tcifs_fscache_reset_inode_cookie(inode);\n\treturn rc;\n}\n\n/**\n * cifs_wait_bit_killable - helper for functions that are sleeping on bit locks\n * @word: long word containing the bit lock\n */\nstatic int\ncifs_wait_bit_killable(struct wait_bit_key *key)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tfreezable_schedule_unsafe();\n\treturn 0;\n}\n\nint\ncifs_revalidate_mapping(struct inode *inode)\n{\n\tint rc;\n\tunsigned long *flags = &CIFS_I(inode)->flags;\n\n\trc = wait_on_bit_lock_action(flags, CIFS_INO_LOCK, cifs_wait_bit_killable,\n\t\t\t\t     TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (test_and_clear_bit(CIFS_INO_INVALID_MAPPING, flags)) {\n\t\trc = cifs_invalidate_mapping(inode);\n\t\tif (rc)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, flags);\n\t}\n\n\tclear_bit_unlock(CIFS_INO_LOCK, flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(flags, CIFS_INO_LOCK);\n\n\treturn rc;\n}\n\nint\ncifs_zap_mapping(struct inode *inode)\n{\n\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_revalidate_file_attr(struct file *filp)\n{\n\tint rc = 0;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *) filp->private_data;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\tif (tlink_tcon(cfile->tlink)->unix_ext)\n\t\trc = cifs_get_file_info_unix(filp);\n\telse\n\t\trc = cifs_get_file_info(filp);\n\n\treturn rc;\n}\n\nint cifs_revalidate_dentry_attr(struct dentry *dentry)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *full_path = NULL;\n\n\tif (inode == NULL)\n\t\treturn -ENOENT;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\txid = get_xid();\n\n\t/* can not safely grab the rename sem here if rename calls revalidate\n\t   since that would deadlock */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"Update attributes: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld\\n\",\n\t\t full_path, inode, inode->i_count.counter,\n\t\t dentry, dentry->d_time, jiffies);\n\n\tif (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, sb, xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, sb,\n\t\t\t\t\t xid, NULL);\n\nout:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_revalidate_file(struct file *filp)\n{\n\tint rc;\n\tstruct inode *inode = file_inode(filp);\n\n\trc = cifs_revalidate_file_attr(filp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\n/* revalidate a dentry's inode attributes */\nint cifs_revalidate_dentry(struct dentry *dentry)\n{\n\tint rc;\n\tstruct inode *inode = dentry->d_inode;\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint rc;\n\n\t/*\n\t * We need to be sure that all dirty pages are written and the server\n\t * has actual ctime, mtime and file length.\n\t */\n\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t    inode->i_mapping->nrpages != 0) {\n\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\tif (rc) {\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = CIFS_MAX_MSGSIZE;\n\tstat->ino = CIFS_I(inode)->uniqueid;\n\n\t/*\n\t * If on a multiuser mount without unix extensions or cifsacl being\n\t * enabled, and the admin hasn't overridden them, set the ownership\n\t * to the fsuid/fsgid of the current process.\n\t */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER) &&\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t    !tcon->unix_ext) {\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID))\n\t\t\tstat->uid = current_fsuid();\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID))\n\t\t\tstat->gid = current_fsgid();\n\t}\n\treturn rc;\n}\n\nstatic int cifs_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\tint rc = 0;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn rc;\n}\n\nstatic void cifs_setsize(struct inode *inode, loff_t offset)\n{\n\tspin_lock(&inode->i_lock);\n\ti_size_write(inode, offset);\n\tspin_unlock(&inode->i_lock);\n\n\ttruncate_pagecache(inode, offset);\n}\n\nstatic int\ncifs_set_file_size(struct inode *inode, struct iattr *attrs,\n\t\t   unsigned int xid, char *full_path)\n{\n\tint rc;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_io_parms io_parms;\n\n\t/*\n\t * To avoid spurious oplock breaks from server, in the case of\n\t * inodes that we already have open, avoid doing path based\n\t * setting of file size if we can do it by handle.\n\t * This keeps our caching token (oplock) and avoids timeouts\n\t * when the local oplock break takes longer to flush\n\t * writebehind data than the SMB timeout for the SetPathInfo\n\t * request would allow\n\t */\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->set_file_size)\n\t\t\trc = server->ops->set_file_size(xid, tcon, open_file,\n\t\t\t\t\t\t\tattrs->ia_size, false);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifsFileInfo_put(open_file);\n\t\tcifs_dbg(FYI, \"SetFSize for attrs rc = %d\\n\", rc);\n\t\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = open_file->fid.netfid;\n\t\t\tio_parms.pid = open_file->pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written,\n\t\t\t\t\t  NULL, NULL, 1);\n\t\t\tcifs_dbg(FYI, \"Wrt seteof rc %d\\n\", rc);\n\t\t}\n\t} else\n\t\trc = -EINVAL;\n\n\tif (!rc)\n\t\tgoto set_size_out;\n\n\tif (tcon == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t\tserver = tcon->ses->server;\n\t}\n\n\t/*\n\t * Set file size by pathname rather than by handle either because no\n\t * valid, writeable file handle for it was found or because there was\n\t * an error setting it by handle.\n\t */\n\tif (server->ops->set_path_size)\n\t\trc = server->ops->set_path_size(xid, tcon, full_path,\n\t\t\t\t\t\tattrs->ia_size, cifs_sb, false);\n\telse\n\t\trc = -ENOSYS;\n\tcifs_dbg(FYI, \"SetEOF by path (setattrs) rc = %d\\n\", rc);\n\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t__u16 netfid;\n\t\tint oplock = 0;\n\n\t\trc = SMBLegacyOpen(xid, tcon, full_path, FILE_OPEN,\n\t\t\t\t   GENERIC_WRITE, CREATE_NOT_DIR, &netfid,\n\t\t\t\t   &oplock, NULL, cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\t\tif (rc == 0) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = netfid;\n\t\t\tio_parms.pid = current->tgid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written, NULL,\n\t\t\t\t\t  NULL,  1);\n\t\t\tcifs_dbg(FYI, \"wrt seteof rc %d\\n\", rc);\n\t\t\tCIFSSMBClose(xid, tcon, netfid);\n\t\t}\n\t}\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\nset_size_out:\n\tif (rc == 0) {\n\t\tcifsInode->server_eof = attrs->ia_size;\n\t\tcifs_setsize(inode, attrs->ia_size);\n\t\tcifs_truncate_page(inode->i_mapping, inode->i_size);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)\n{\n\tint rc;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_unix_set_info_args *args = NULL;\n\tstruct cifsFileInfo *open_file;\n\n\tcifs_dbg(FYI, \"setattr_unix on file %pd attrs->ia_valid=0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\txid = get_xid();\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\targs = kmalloc(sizeof(*args), GFP_KERNEL);\n\tif (args == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* set up the struct */\n\tif (attrs->ia_valid & ATTR_MODE)\n\t\targs->mode = attrs->ia_mode;\n\telse\n\t\targs->mode = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\targs->uid = attrs->ia_uid;\n\telse\n\t\targs->uid = INVALID_UID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\targs->gid = attrs->ia_gid;\n\telse\n\t\targs->gid = INVALID_GID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_ATIME)\n\t\targs->atime = cifs_UnixTimeToNT(attrs->ia_atime);\n\telse\n\t\targs->atime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_MTIME)\n\t\targs->mtime = cifs_UnixTimeToNT(attrs->ia_mtime);\n\telse\n\t\targs->mtime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_CTIME)\n\t\targs->ctime = cifs_UnixTimeToNT(attrs->ia_ctime);\n\telse\n\t\targs->ctime = NO_CHANGE_64;\n\n\targs->device = 0;\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\tu16 nfid = open_file->fid.netfid;\n\t\tu32 npid = open_file->pid;\n\t\tpTcon = tlink_tcon(open_file->tlink);\n\t\trc = CIFSSMBUnixSetFileInfo(xid, pTcon, args, nfid, npid);\n\t\tcifsFileInfo_put(open_file);\n\t} else {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink)) {\n\t\t\trc = PTR_ERR(tlink);\n\t\t\tgoto out;\n\t\t}\n\t\tpTcon = tlink_tcon(tlink);\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, args,\n\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tcifs_put_tlink(tlink);\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\n\t/* force revalidate when any of these times are set since some\n\t   of the fs types (eg ext3, fat) do not have fine enough\n\t   time granularity to match protocol, and we do not have a\n\t   a way (yet) to query the server fs's time granularity (and\n\t   whether it rounds times down).\n\t*/\n\tif (attrs->ia_valid & (ATTR_MTIME | ATTR_CTIME))\n\t\tcifsInode->time = 0;\nout:\n\tkfree(args);\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)\n{\n\tunsigned int xid;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tchar *full_path = NULL;\n\tint rc = -EACCES;\n\t__u32 dosattr = 0;\n\t__u64 mode = NO_CHANGE_64;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"setattr on file %pd attrs->iavalid 0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0) {\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto cifs_setattr_exit;\n\t}\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\tuid = attrs->ia_uid;\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\tgid = attrs->ia_gid;\n\n#ifdef CONFIG_CIFS_ACL\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\tif (uid_valid(uid) || gid_valid(gid)) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, NO_CHANGE_64,\n\t\t\t\t\t\t\tuid, gid);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting id failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t}\n\t} else\n#endif /* CONFIG_CIFS_ACL */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID))\n\t\tattrs->ia_valid &= ~(ATTR_UID | ATTR_GID);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\tif (attrs->ia_valid & ATTR_MODE) {\n\t\tmode = attrs->ia_mode;\n\t\trc = 0;\n#ifdef CONFIG_CIFS_ACL\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, mode,\n\t\t\t\t\t\tINVALID_UID, INVALID_GID);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting ACL failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_CIFS_ACL */\n\t\tif (((mode & S_IWUGO) == 0) &&\n\t\t    (cifsInode->cifsAttrs & ATTR_READONLY) == 0) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs | ATTR_READONLY;\n\n\t\t\t/* fix up mode if we're not using dynperm */\n\t\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM) == 0)\n\t\t\t\tattrs->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\t} else if ((mode & S_IWUGO) &&\n\t\t\t   (cifsInode->cifsAttrs & ATTR_READONLY)) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs & ~ATTR_READONLY;\n\t\t\t/* Attributes of 0 are ignored */\n\t\t\tif (dosattr == 0)\n\t\t\t\tdosattr |= ATTR_NORMAL;\n\n\t\t\t/* reset local inode permissions to normal */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t\tattrs->ia_mode &= ~(S_IALLUGO);\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_dir_mode;\n\t\t\t\telse\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_file_mode;\n\t\t\t}\n\t\t} else if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t/* ignore mode change - ATTR_READONLY hasn't changed */\n\t\t\tattrs->ia_valid &= ~ATTR_MODE;\n\t\t}\n\t}\n\n\tif (attrs->ia_valid & (ATTR_MTIME|ATTR_ATIME|ATTR_CTIME) ||\n\t    ((attrs->ia_valid & ATTR_MODE) && dosattr)) {\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\t/* BB: check for rc = -EOPNOTSUPP and switch to legacy mode */\n\n\t\t/* Even if error on time set, no sense failing the call if\n\t\tthe server would set the time to a reasonable value anyway,\n\t\tand this check ensures that we are not being called from\n\t\tsys_utimes in which case we ought to fail the call back to\n\t\tthe user when the server rejects the call */\n\t\tif ((rc) && (attrs->ia_valid &\n\t\t\t\t(ATTR_MODE | ATTR_GID | ATTR_UID | ATTR_SIZE)))\n\t\t\trc = 0;\n\t}\n\n\t/* do not need local check to inode_check_ok since the server does\n\t   that */\n\tif (rc)\n\t\tgoto cifs_setattr_exit;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\ncifs_setattr_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_setattr(struct dentry *direntry, struct iattr *attrs)\n{\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (pTcon->unix_ext)\n\t\treturn cifs_setattr_unix(direntry, attrs);\n\n\treturn cifs_setattr_nounix(direntry, attrs);\n\n\t/* BB: add cifs_setattr_legacy for really old servers */\n}\n\n#if 0\nvoid cifs_delete_inode(struct inode *inode)\n{\n\tcifs_dbg(FYI, \"In cifs_delete_inode, inode = 0x%p\\n\", inode);\n\t/* may have to add back in if and when safe distributed caching of\n\t   directories added e.g. via FindNotify */\n}\n#endif",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_size_safe_to_change",
          "args": [
            "cifs_i",
            "fattr->cf_eof"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "is_size_safe_to_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3675-3697",
          "snippet": "bool is_size_safe_to_change(struct cifsInodeInfo *cifsInode, __u64 end_of_file)\n{\n\tif (!cifsInode)\n\t\treturn true;\n\n\tif (is_inode_writable(cifsInode)) {\n\t\t/* This inode is open for write at least once */\n\t\tstruct cifs_sb_info *cifs_sb;\n\n\t\tcifs_sb = CIFS_SB(cifsInode->vfs_inode.i_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\t/* since no page cache to corrupt on directio\n\t\t\twe can change size safely */\n\t\t\treturn true;\n\t\t}\n\n\t\tif (i_size_read(&cifsInode->vfs_inode) < end_of_file)\n\t\t\treturn true;\n\n\t\treturn false;\n\t} else\n\t\treturn true;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nbool is_size_safe_to_change(struct cifsInodeInfo *cifsInode, __u64 end_of_file)\n{\n\tif (!cifsInode)\n\t\treturn true;\n\n\tif (is_inode_writable(cifsInode)) {\n\t\t/* This inode is open for write at least once */\n\t\tstruct cifs_sb_info *cifs_sb;\n\n\t\tcifs_sb = CIFS_SB(cifsInode->vfs_inode.i_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\t/* since no page cache to corrupt on directio\n\t\t\twe can change size safely */\n\t\t\treturn true;\n\t\t}\n\n\t\tif (i_size_read(&cifsInode->vfs_inode) < end_of_file)\n\t\t\treturn true;\n\n\t\treturn false;\n\t} else\n\t\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INO_DELETE_PENDING",
            "&cifs_i->flags"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_nlink_fattr_to_inode",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_cache",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: invalidating inode %llu mapping\\n\"",
            "__func__",
            "cifs_i->uniqueid"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: inode %llu is unchanged\\n\"",
            "__func__",
            "cifs_i->uniqueid"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_mtime",
            "&fattr->cf_mtime"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: inode %llu is oplocked\\n\"",
            "__func__",
            "cifs_i->uniqueid"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cifs_i"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: inode %llu is new\\n\"",
            "__func__",
            "cifs_i->uniqueid"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: revalidating inode %llu\\n\"",
            "__func__",
            "cifs_i->uniqueid"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_AUTOMOUNT",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/freezer.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)  /* SETFILEBITS valid bits */\n\nstatic void cifs_set_ops(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &cifs_file_inode_ops;\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_direct_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_direct_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_strict_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_strict_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tinode->i_fop = &cifs_file_nobrl_ops;\n\t\telse { /* not direct, send byte range locks */\n\t\t\tinode->i_fop = &cifs_file_ops;\n\t\t}\n\n\t\t/* check if server can support readpages */\n\t\tif (cifs_sb_master_tcon(cifs_sb)->ses->server->maxBuf <\n\t\t\t\tPAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops_smallbuf;\n\t\telse\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops;\n\t\tbreak;\n\tcase S_IFDIR:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (IS_AUTOMOUNT(inode)) {\n\t\t\tinode->i_op = &cifs_dfs_referral_inode_operations;\n\t\t} else {\n#else /* NO DFS support, treat as a directory */\n\t\t{\n#endif\n\t\t\tinode->i_op = &cifs_dir_inode_ops;\n\t\t\tinode->i_fop = &cifs_dir_ops;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &cifs_symlink_inode_ops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n\n/* check inode attributes against fattr. If they don't match, tag the\n * inode for cache invalidation\n */\nstatic void\ncifs_revalidate_cache(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\n\tcifs_dbg(FYI, \"%s: revalidating inode %llu\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is new\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t/* don't bother with revalidation if we have an oplock */\n\tif (CIFS_CACHE_READ(cifs_i)) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is oplocked\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t /* revalidate if mtime or size have changed */\n\tif (timespec_equal(&inode->i_mtime, &fattr->cf_mtime) &&\n\t    cifs_i->server_eof == fattr->cf_eof) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is unchanged\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\tcifs_dbg(FYI, \"%s: invalidating inode %llu mapping\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\tset_bit(CIFS_INO_INVALID_MAPPING, &cifs_i->flags);\n}\n\n/*\n * copy nlink to the inode, unless it wasn't provided.  Provide\n * sane values if we don't have an existing one and none was provided\n */\nstatic void\ncifs_nlink_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\t/*\n\t * if we're in a situation where we can't trust what we\n\t * got from the server (readdir, some non-unix cases)\n\t * fake reasonable values\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_UNKNOWN_NLINK) {\n\t\t/* only provide fake values on a new inode */\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY)\n\t\t\t\tset_nlink(inode, 2);\n\t\t\telse\n\t\t\t\tset_nlink(inode, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* we trust the server, so update it */\n\tset_nlink(inode, fattr->cf_nlink);\n}\n\n/* populate an inode with info from a cifs_fattr struct */\nvoid\ncifs_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tcifs_revalidate_cache(inode, fattr);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_atime = fattr->cf_atime;\n\tinode->i_mtime = fattr->cf_mtime;\n\tinode->i_ctime = fattr->cf_ctime;\n\tinode->i_rdev = fattr->cf_rdev;\n\tcifs_nlink_fattr_to_inode(inode, fattr);\n\tinode->i_uid = fattr->cf_uid;\n\tinode->i_gid = fattr->cf_gid;\n\n\t/* if dynperm is set, don't clobber existing mode */\n\tif (inode->i_state & I_NEW ||\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM))\n\t\tinode->i_mode = fattr->cf_mode;\n\n\tcifs_i->cifsAttrs = fattr->cf_cifsattrs;\n\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\tcifs_i->time = 0;\n\telse\n\t\tcifs_i->time = jiffies;\n\n\tif (fattr->cf_flags & CIFS_FATTR_DELETE_PENDING)\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\telse\n\t\tclear_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\n\tcifs_i->server_eof = fattr->cf_eof;\n\t/*\n\t * Can't safely change the file size here if the client is writing to\n\t * it due to potential races.\n\t */\n\tif (is_size_safe_to_change(cifs_i, fattr->cf_eof)) {\n\t\ti_size_write(inode, fattr->cf_eof);\n\n\t\t/*\n\t\t * i_blocks is not related to (i_size / i_blksize),\n\t\t * but instead 512 byte (2**9) size is required for\n\t\t * calculating num blocks.\n\t\t */\n\t\tinode->i_blocks = (512 - 1 + fattr->cf_bytes) >> 9;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (fattr->cf_flags & CIFS_FATTR_DFS_REFERRAL)\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\tif (inode->i_state & I_NEW)\n\t\tcifs_set_ops(inode);\n}\n\nvoid\ncifs_fill_uniqueid(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\treturn;\n\n\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n}\n\n/* Fill a cifs_fattr struct with info from FILE_UNIX_BASIC_INFO. */\nvoid\ncifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,\n\t\t\t struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_uniqueid = le64_to_cpu(info->UniqueId);\n\tfattr->cf_bytes = le64_to_cpu(info->NumOfBytes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastModificationTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->LastStatusChange);\n\tfattr->cf_mode = le64_to_cpu(info->Permissions);\n\n\t/*\n\t * Since we set the inode type below we need to mask off\n\t * to avoid strange results if bits set above.\n\t */\n\tfattr->cf_mode &= ~S_IFMT;\n\tswitch (le32_to_cpu(info->Type)) {\n\tcase UNIX_FILE:\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tbreak;\n\tcase UNIX_SYMLINK:\n\t\tfattr->cf_mode |= S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tcase UNIX_DIR:\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\tbreak;\n\tcase UNIX_CHARDEV:\n\t\tfattr->cf_mode |= S_IFCHR;\n\t\tfattr->cf_dtype = DT_CHR;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_BLOCKDEV:\n\t\tfattr->cf_mode |= S_IFBLK;\n\t\tfattr->cf_dtype = DT_BLK;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_FIFO:\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\tbreak;\n\tcase UNIX_SOCKET:\n\t\tfattr->cf_mode |= S_IFSOCK;\n\t\tfattr->cf_dtype = DT_SOCK;\n\t\tbreak;\n\tdefault:\n\t\t/* safest to call it a file if we do not know */\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tcifs_dbg(FYI, \"unknown type %d\\n\", le32_to_cpu(info->Type));\n\t\tbreak;\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)) {\n\t\tu64 id = le64_to_cpu(info->Uid);\n\t\tif (id < ((uid_t)-1)) {\n\t\t\tkuid_t uid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid))\n\t\t\t\tfattr->cf_uid = uid;\n\t\t}\n\t}\n\t\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)) {\n\t\tu64 id = le64_to_cpu(info->Gid);\n\t\tif (id < ((gid_t)-1)) {\n\t\t\tkgid_t gid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid))\n\t\t\t\tfattr->cf_gid = gid;\n\t\t}\n\t}\n\n\tfattr->cf_nlink = le64_to_cpu(info->Nlinks);\n}\n\n/*\n * Fill a cifs_fattr struct with fake inode info.\n *\n * Needed to setup cifs_fattr data for the directory which is the\n * junction to the new submount (ie to setup the fake directory\n * which represents a DFS referral).\n */\nstatic void\ncifs_create_dfs_fattr(struct cifs_fattr *fattr, struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"creating fake fattr for DFS referral\\n\");\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\tfattr->cf_atime = CURRENT_TIME;\n\tfattr->cf_ctime = CURRENT_TIME;\n\tfattr->cf_mtime = CURRENT_TIME;\n\tfattr->cf_nlink = 2;\n\tfattr->cf_flags |= CIFS_FATTR_DFS_REFERRAL;\n}\n\nstatic int\ncifs_get_file_info_unix(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBUnixQFileInfo(xid, tcon, cfile->fid.netfid, &find_data);\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t}\n\n\tcifs_fattr_to_inode(inode, &fattr);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\t     const unsigned char *full_path,\n\t\t\t     struct super_block *sb, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/* could have done a find first instead but this returns more info */\n\trc = CIFSSMBUnixQPathInfo(xid, tcon, full_path, &find_data,\n\t\t\t\t  cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else {\n\t\treturn rc;\n\t}\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\tint tmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t     full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (*pinode == NULL) {\n\t\t/* get new inode */\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\t/* we already have inode, update it */\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_sfu_type(struct cifs_fattr *fattr, const char *path,\n\t      struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n\tint rc;\n\t__u32 oplock;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms;\n\tchar buf[24];\n\tunsigned int bytes_read;\n\tchar *pbuf;\n\tint buf_type = CIFS_NO_BUFFER;\n\n\tpbuf = buf;\n\n\tfattr->cf_mode &= ~S_IFMT;\n\n\tif (fattr->cf_eof == 0) {\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\treturn 0;\n\t} else if (fattr->cf_eof < 8) {\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\treturn -EINVAL;\t /* EOPNOTSUPP? */\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_READ;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"check sfu type of %s, open rc = %d\\n\", path, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/* Read header */\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = 24;\n\n\trc = tcon->ses->server->ops->sync_read(xid, &fid, &io_parms,\n\t\t\t\t\t&bytes_read, &pbuf, &buf_type);\n\tif ((rc == 0) && (bytes_read >= 8)) {\n\t\tif (memcmp(\"IntxBLK\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Block device\\n\");\n\t\t\tfattr->cf_mode |= S_IFBLK;\n\t\t\tfattr->cf_dtype = DT_BLK;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxCHR\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Char device\\n\");\n\t\t\tfattr->cf_mode |= S_IFCHR;\n\t\t\tfattr->cf_dtype = DT_CHR;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t/* we have enough to decode dev num */\n\t\t\t\t__u64 mjr; /* major */\n\t\t\t\t__u64 mnr; /* minor */\n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxLNK\", pbuf, 7) == 0) {\n\t\t\tcifs_dbg(FYI, \"Symlink\\n\");\n\t\t\tfattr->cf_mode |= S_IFLNK;\n\t\t\tfattr->cf_dtype = DT_LNK;\n\t\t} else {\n\t\t\tfattr->cf_mode |= S_IFREG; /* file? */\n\t\t\tfattr->cf_dtype = DT_REG;\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tfattr->cf_mode |= S_IFREG; /* then it is a file */\n\t\tfattr->cf_dtype = DT_REG;\n\t\trc = -EOPNOTSUPP; /* or some unknown SFU type */\n\t}\n\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)  /* SETFILEBITS valid bits */\n\n/*\n * Fetch mode bits as provided by SFU.\n *\n * FIXME: Doesn't this clobber the type bit we got from cifs_sfu_type ?\n */\nstatic int cifs_sfu_mode(struct cifs_fattr *fattr, const unsigned char *path,\n\t\t\t struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n#ifdef CONFIG_CIFS_XATTR\n\tssize_t rc;\n\tchar ea_value[4];\n\t__u32 mode;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (tcon->ses->server->ops->query_all_EAs == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = tcon->ses->server->ops->query_all_EAs(xid, tcon, path,\n\t\t\t\"SETFILEBITS\", ea_value, 4 /* size of buf */,\n\t\t\tcifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\tcifs_put_tlink(tlink);\n\tif (rc < 0)\n\t\treturn (int)rc;\n\telse if (rc > 3) {\n\t\tmode = le32_to_cpu(*((__le32 *)ea_value));\n\t\tfattr->cf_mode &= ~SFBITS_MASK;\n\t\tcifs_dbg(FYI, \"special bits 0%o org mode 0%o\\n\",\n\t\t\t mode, fattr->cf_mode);\n\t\tfattr->cf_mode = (mode & SFBITS_MASK) | fattr->cf_mode;\n\t\tcifs_dbg(FYI, \"special mode bits 0%o\\n\", mode);\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\n/* Fill a cifs_fattr struct with info from FILE_ALL_INFO */\nstatic void\ncifs_all_info_to_fattr(struct cifs_fattr *fattr, FILE_ALL_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb, bool adjust_tz,\n\t\t       bool symlink)\n{\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->Attributes);\n\tif (info->DeletePending)\n\t\tfattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;\n\n\tif (info->LastAccessTime)\n\t\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\telse\n\t\tfattr->cf_atime = CURRENT_TIME;\n\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tif (adjust_tz) {\n\t\tfattr->cf_ctime.tv_sec += tcon->ses->server->timeAdj;\n\t\tfattr->cf_mtime.tv_sec += tcon->ses->server->timeAdj;\n\t}\n\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\n\tfattr->cf_nlink = le32_to_cpu(info->NumberOfLinks);\n\n\tif (symlink) {\n\t\tfattr->cf_mode = S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t} else if (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\t/*\n\t\t * Server can return wrong NumberOfLinks value for directories\n\t\t * when Unix extensions are disabled - fake it.\n\t\t */\n\t\tif (!tcon->unix_ext)\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\n\t\t/* clear write bits if ATTR_READONLY is set */\n\t\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\t\tfattr->cf_mode &= ~(S_IWUGO);\n\n\t\t/*\n\t\t * Don't accept zero nlink from non-unix servers unless\n\t\t * delete is pending.  Instead mark it as unknown.\n\t\t */\n\t\tif ((fattr->cf_nlink < 1) && !tcon->unix_ext &&\n\t\t    !info->DeletePending) {\n\t\t\tcifs_dbg(1, \"bogus file nlink value %u\\n\",\n\t\t\t\tfattr->cf_nlink);\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t\t}\n\t}\n\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n}\n\nstatic int\ncifs_get_file_info(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_ALL_INFO find_data;\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (!server->ops->query_file_info)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\trc = server->ops->query_file_info(xid, tcon, &cfile->fid, &find_data);\n\tswitch (rc) {\n\tcase 0:\n\t\tcifs_all_info_to_fattr(&fattr, &find_data, cifs_sb, false,\n\t\t\t\t       false);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\tcifs_create_dfs_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EOPNOTSUPP:\n\tcase -EINVAL:\n\t\t/*\n\t\t * FIXME: legacy server -- fall back to path-based call?\n\t\t * for now, just skip revalidating and mark inode for\n\t\t * immediate reval.\n\t\t */\n\t\trc = 0;\n\t\tCIFS_I(inode)->time = 0;\n\tdefault:\n\t\tgoto cgfi_exit;\n\t}\n\n\t/*\n\t * don't bother with SFU junk here -- just mark inode as needing\n\t * revalidation.\n\t */\n\tfattr.cf_uniqueid = CIFS_I(inode)->uniqueid;\n\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\tcifs_fattr_to_inode(inode, &fattr);\ncgfi_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_get_inode_info(struct inode **inode, const char *full_path,\n\t\t    FILE_ALL_INFO *data, struct super_block *sb, int xid,\n\t\t    const struct cifs_fid *fid)\n{\n\tbool validinum = false;\n\t__u16 srchflgs;\n\tint rc = 0, tmprc = ENOSYS;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *buf = NULL;\n\tbool adjust_tz = false;\n\tstruct cifs_fattr fattr;\n\tstruct cifs_search_info *srchinf = NULL;\n\tbool symlink = false;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\tif ((data == NULL) && (*inode != NULL)) {\n\t\tif (CIFS_CACHE_READ(CIFS_I(*inode))) {\n\t\t\tcifs_dbg(FYI, \"No need to revalidate cached inode sizes\\n\");\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n\n\t/* if inode info is not passed, get it from server */\n\tif (data == NULL) {\n\t\tif (!server->ops->query_path_info) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\t\tif (buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cgii_exit;\n\t\t}\n\t\tdata = (FILE_ALL_INFO *)buf;\n\t\trc = server->ops->query_path_info(xid, tcon, cifs_sb, full_path,\n\t\t\t\t\t\t  data, &adjust_tz, &symlink);\n\t}\n\n\tif (!rc) {\n\t\tcifs_all_info_to_fattr(&fattr, data, cifs_sb, adjust_tz,\n\t\t\t\t       symlink);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_dfs_fattr(&fattr, sb);\n\t\trc = 0;\n\t} else if (rc == -EACCES && backup_cred(cifs_sb)) {\n\t\t\tsrchinf = kzalloc(sizeof(struct cifs_search_info),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (srchinf == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto cgii_exit;\n\t\t\t}\n\n\t\t\tsrchinf->endOfSearch = false;\n\t\t\tsrchinf->info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\n\t\t\tsrchflgs = CIFS_SEARCH_CLOSE_ALWAYS |\n\t\t\t\t\tCIFS_SEARCH_CLOSE_AT_END |\n\t\t\t\t\tCIFS_SEARCH_BACKUP_SEARCH;\n\n\t\t\trc = CIFSFindFirst(xid, tcon, full_path,\n\t\t\t\tcifs_sb, NULL, srchflgs, srchinf, false);\n\t\t\tif (!rc) {\n\t\t\t\tdata =\n\t\t\t\t(FILE_ALL_INFO *)srchinf->srch_entries_start;\n\n\t\t\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t(FILE_DIRECTORY_INFO *)data, cifs_sb);\n\t\t\t\tfattr.cf_uniqueid = le64_to_cpu(\n\t\t\t\t((SEARCH_ID_FULL_DIR_INFO *)data)->UniqueId);\n\t\t\t\tvalidinum = true;\n\n\t\t\t\tcifs_buf_release(srchinf->ntwrk_buf_start);\n\t\t\t}\n\t\t\tkfree(srchinf);\n\t} else\n\t\tgoto cgii_exit;\n\n\t/*\n\t * If an inode wasn't passed in, then get the inode number\n\t *\n\t * Is an i_ino of zero legal? Can we use that to check if the server\n\t * supports returning inode numbers?  Are there other sanity checks we\n\t * can use to ensure that the server is really filling in that field?\n\t */\n\tif (*inode == NULL) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\t\tif (validinum == false) {\n\t\t\t\tif (server->ops->get_srv_inum)\n\t\t\t\t\ttmprc = server->ops->get_srv_inum(xid,\n\t\t\t\t\t\ttcon, cifs_sb, full_path,\n\t\t\t\t\t\t&fattr.cf_uniqueid, data);\n\t\t\t\tif (tmprc) {\n\t\t\t\t\tcifs_dbg(FYI, \"GetSrvInodeNum rc %d\\n\",\n\t\t\t\t\t\t tmprc);\n\t\t\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\t\tcifs_autodisable_serverino(cifs_sb);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t} else\n\t\tfattr.cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\n\t/* query for SFU type info if supported and needed */\n\tif (fattr.cf_cifsattrs & ATTR_SYSTEM &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL) {\n\t\ttmprc = cifs_sfu_type(&fattr, full_path, cifs_sb, xid);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"cifs_sfu_type failed: %d\\n\", tmprc);\n\t}\n\n#ifdef CONFIG_CIFS_ACL\n\t/* fill in 0777 bits from ACL */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\trc = cifs_acl_to_fattr(cifs_sb, &fattr, *inode, full_path, fid);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: Getting ACL failed with error: %d\\n\",\n\t\t\t\t __func__, rc);\n\t\t\tgoto cgii_exit;\n\t\t}\n\t}\n#endif /* CONFIG_CIFS_ACL */\n\n\t/* fill in remaining high mode bits e.g. SUID, VTX */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tcifs_sfu_mode(&fattr, full_path, cifs_sb, xid);\n\n\t/* check for Minshall+French symlinks */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, &fattr,\n\t\t\t\t\t full_path);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (!*inode) {\n\t\t*inode = cifs_iget(sb, &fattr);\n\t\tif (!*inode)\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\tcifs_fattr_to_inode(*inode, &fattr);\n\t}\n\ncgii_exit:\n\tkfree(buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic const struct inode_operations cifs_ipc_inode_ops = {\n\t.lookup = cifs_lookup,\n};\n\nstatic int\ncifs_find_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\t/* don't match inode with different uniqueid */\n\tif (CIFS_I(inode)->uniqueid != fattr->cf_uniqueid)\n\t\treturn 0;\n\n\t/* use createtime like an i_generation field */\n\tif (CIFS_I(inode)->createtime != fattr->cf_createtime)\n\t\treturn 0;\n\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (fattr->cf_mode & S_IFMT))\n\t\treturn 0;\n\n\t/* if it's not a directory or has no dentries, then flag it */\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry))\n\t\tfattr->cf_flags |= CIFS_FATTR_INO_COLLISION;\n\n\treturn 1;\n}\n\nstatic int\ncifs_init_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = (struct cifs_fattr *) opaque;\n\n\tCIFS_I(inode)->uniqueid = fattr->cf_uniqueid;\n\tCIFS_I(inode)->createtime = fattr->cf_createtime;\n\treturn 0;\n}\n\n/*\n * walk dentry list for an inode and report whether it has aliases that\n * are hashed. We use this to determine if a directory inode can actually\n * be used.\n */\nstatic bool\ninode_has_hashed_dentries(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (!d_unhashed(dentry) || IS_ROOT(dentry)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn false;\n}\n\n/* Given fattrs, get a corresponding inode */\nstruct inode *\ncifs_iget(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tunsigned long hash;\n\tstruct inode *inode;\n\nretry_iget5_locked:\n\tcifs_dbg(FYI, \"looking for uniqueid=%llu\\n\", fattr->cf_uniqueid);\n\n\t/* hash down to 32-bits on 32-bit arch */\n\thash = cifs_uniqueid_to_ino_t(fattr->cf_uniqueid);\n\n\tinode = iget5_locked(sb, hash, cifs_find_inode, cifs_init_inode, fattr);\n\tif (inode) {\n\t\t/* was there a potentially problematic inode collision? */\n\t\tif (fattr->cf_flags & CIFS_FATTR_INO_COLLISION) {\n\t\t\tfattr->cf_flags &= ~CIFS_FATTR_INO_COLLISION;\n\n\t\t\tif (inode_has_hashed_dentries(inode)) {\n\t\t\t\tcifs_autodisable_serverino(CIFS_SB(sb));\n\t\t\t\tiput(inode);\n\t\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\tgoto retry_iget5_locked;\n\t\t\t}\n\t\t}\n\n\t\tcifs_fattr_to_inode(inode, fattr);\n\t\tif (sb->s_flags & MS_NOATIME)\n\t\t\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tinode->i_ino = hash;\n#ifdef CONFIG_CIFS_FSCACHE\n\t\t\t/* initialize per-inode cache cookie pointer */\n\t\t\tCIFS_I(inode)->fscache = NULL;\n#endif\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\n/* gets root inode */\nstruct inode *cifs_root_iget(struct super_block *sb)\n{\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct inode *inode = NULL;\n\tlong rc;\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\txid = get_xid();\n\tif (tcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&inode, \"\", sb, xid);\n\t\t/* some servers mistakenly claim POSIX support */\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto iget_no_retry;\n\t\tcifs_dbg(VFS, \"server does not support POSIX extensions\");\n\t\ttcon->unix_ext = false;\n\t}\n\n\trc = cifs_get_inode_info(&inode, \"\", NULL, sb, xid, NULL);\n\niget_no_retry:\n\tif (!inode) {\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_FSCACHE\n\t/* populate tcon->resource_id */\n\ttcon->resource_id = CIFS_I(inode)->uniqueid;\n#endif\n\n\tif (rc && tcon->ipc) {\n\t\tcifs_dbg(FYI, \"ipc connection - fake read inode\\n\");\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_mode |= S_IFDIR;\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &cifs_ipc_inode_ops;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_uid = cifs_sb->mnt_uid;\n\t\tinode->i_gid = cifs_sb->mnt_gid;\n\t\tspin_unlock(&inode->i_lock);\n\t} else if (rc) {\n\t\tiget_failed(inode);\n\t\tinode = ERR_PTR(rc);\n\t}\n\nout:\n\t/* can not call macro free_xid here since in a void func\n\t * TODO: This is no longer true\n\t */\n\t_free_xid(xid);\n\treturn inode;\n}\n\nint\ncifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,\n\t\t   char *full_path, __u32 dosattr)\n{\n\tbool set_time = false;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct TCP_Server_Info *server;\n\tFILE_BASIC_INFO\tinfo_buf;\n\n\tif (attrs == NULL)\n\t\treturn -EINVAL;\n\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\n\tif (!server->ops->set_file_info)\n\t\treturn -ENOSYS;\n\n\tif (attrs->ia_valid & ATTR_ATIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastAccessTime =\n\t\t\tcpu_to_le64(cifs_UnixTimeToNT(attrs->ia_atime));\n\t} else\n\t\tinfo_buf.LastAccessTime = 0;\n\n\tif (attrs->ia_valid & ATTR_MTIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastWriteTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_mtime));\n\t} else\n\t\tinfo_buf.LastWriteTime = 0;\n\n\t/*\n\t * Samba throws this field away, but windows may actually use it.\n\t * Do not set ctime unless other time stamps are changed explicitly\n\t * (i.e. by utimes()) since we would then have a mix of client and\n\t * server times.\n\t */\n\tif (set_time && (attrs->ia_valid & ATTR_CTIME)) {\n\t\tcifs_dbg(FYI, \"CIFS - CTIME changed\\n\");\n\t\tinfo_buf.ChangeTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_ctime));\n\t} else\n\t\tinfo_buf.ChangeTime = 0;\n\n\tinfo_buf.CreationTime = 0;\t/* don't change */\n\tinfo_buf.Attributes = cpu_to_le32(dosattr);\n\n\treturn server->ops->set_file_info(inode, full_path, &info_buf, xid);\n}\n\n/*\n * Open the given file (if it isn't already), set the DELETE_ON_CLOSE bit\n * and rename it to a random name that hopefully won't conflict with\n * anything else.\n */\nint\ncifs_rename_pending_delete(const char *full_path, struct dentry *dentry,\n\t\t\t   const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\t__u32 dosattr, origattr;\n\tFILE_BASIC_INFO *info_buf = NULL;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t/*\n\t * We cannot rename the file if the server doesn't support\n\t * CAP_INFOLEVEL_PASSTHRU\n\t */\n\tif (!(tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = DELETE | FILE_WRITE_ATTRIBUTES;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0)\n\t\tgoto out;\n\n\torigattr = cifsInode->cifsAttrs;\n\tif (origattr == 0)\n\t\torigattr |= ATTR_NORMAL;\n\n\tdosattr = origattr & ~ATTR_READONLY;\n\tif (dosattr == 0)\n\t\tdosattr |= ATTR_NORMAL;\n\tdosattr |= ATTR_HIDDEN;\n\n\t/* set ATTR_HIDDEN and clear ATTR_READONLY, but only if needed */\n\tif (dosattr != origattr) {\n\t\tinfo_buf = kzalloc(sizeof(*info_buf), GFP_KERNEL);\n\t\tif (info_buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_close;\n\t\t}\n\t\tinfo_buf->Attributes = cpu_to_le32(dosattr);\n\t\trc = CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid);\n\t\t/* although we would like to mark the file hidden\n \t\t   if that fails we will still try to rename it */\n\t\tif (!rc)\n\t\t\tcifsInode->cifsAttrs = dosattr;\n\t\telse\n\t\t\tdosattr = origattr; /* since not able to change them */\n\t}\n\n\t/* rename the file */\n\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid, NULL,\n\t\t\t\t   cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\tif (rc != 0) {\n\t\trc = -EBUSY;\n\t\tgoto undo_setattr;\n\t}\n\n\t/* try to set DELETE_ON_CLOSE */\n\tif (!test_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags)) {\n\t\trc = CIFSSMBSetFileDisposition(xid, tcon, true, fid.netfid,\n\t\t\t\t\t       current->tgid);\n\t\t/*\n\t\t * some samba versions return -ENOENT when we try to set the\n\t\t * file disposition here. Likely a samba bug, but work around\n\t\t * it for now. This means that some cifsXXX files may hang\n\t\t * around after they shouldn't.\n\t\t *\n\t\t * BB: remove this hack after more servers have the fix\n\t\t */\n\t\tif (rc == -ENOENT)\n\t\t\trc = 0;\n\t\telse if (rc != 0) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto undo_rename;\n\t\t}\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags);\n\t}\n\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tkfree(info_buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n\n\t/*\n\t * reset everything back to the original state. Don't bother\n\t * dealing with errors here since we can't do anything about\n\t * them anyway.\n\t */\nundo_rename:\n\tCIFSSMBRenameOpenFile(xid, tcon, fid.netfid, dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\nundo_setattr:\n\tif (dosattr != origattr) {\n\t\tinfo_buf->Attributes = cpu_to_le32(origattr);\n\t\tif (!CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid))\n\t\t\tcifsInode->cifsAttrs = origattr;\n\t}\n\n\tgoto out_close;\n}\n\n/* copied from fs/nfs/dir.c with small changes */\nstatic void\ncifs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * If dentry->d_inode is null (usually meaning the cached dentry\n * is a negative dentry) then we would attempt a standard SMB delete, but\n * if that fails we can not attempt the fall back mechanisms on EACCESS\n * but will return the EACCESS to the caller. Note that the VFS does not call\n * unlink on negative dentries currently.\n */\nint cifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cifs_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct iattr *attrs = NULL;\n\t__u32 dosattr = 0, origattr = 0;\n\n\tcifs_dbg(FYI, \"cifs_unlink, dir=0x%p, dentry=0x%p\\n\", dir, dentry);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\txid = get_xid();\n\n\t/* Unlink can be called from rename so we can not take the\n\t * sb->s_vfs_rename_mutex here */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto unlink_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = CIFSPOSIXDelFile(xid, tcon, full_path,\n\t\t\tSMB_POSIX_UNLINK_FILE_TARGET, cifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\t\tcifs_dbg(FYI, \"posix del rc %d\\n\", rc);\n\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\tgoto psx_del_no_retry;\n\t}\n\nretry_std_delete:\n\tif (!server->ops->unlink) {\n\t\trc = -ENOSYS;\n\t\tgoto psx_del_no_retry;\n\t}\n\n\trc = server->ops->unlink(xid, tcon, full_path, cifs_sb);\n\npsx_del_no_retry:\n\tif (!rc) {\n\t\tif (inode)\n\t\t\tcifs_drop_nlink(inode);\n\t} else if (rc == -ENOENT) {\n\t\td_drop(dentry);\n\t} else if (rc == -EBUSY) {\n\t\tif (server->ops->rename_pending_delete) {\n\t\t\trc = server->ops->rename_pending_delete(full_path,\n\t\t\t\t\t\t\t\tdentry, xid);\n\t\t\tif (rc == 0)\n\t\t\t\tcifs_drop_nlink(inode);\n\t\t}\n\t} else if ((rc == -EACCES) && (dosattr == 0) && inode) {\n\t\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\t\tif (attrs == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_reval;\n\t\t}\n\n\t\t/* try to reset dos attributes */\n\t\tcifs_inode = CIFS_I(inode);\n\t\torigattr = cifs_inode->cifsAttrs;\n\t\tif (origattr == 0)\n\t\t\torigattr |= ATTR_NORMAL;\n\t\tdosattr = origattr & ~ATTR_READONLY;\n\t\tif (dosattr == 0)\n\t\t\tdosattr |= ATTR_NORMAL;\n\t\tdosattr |= ATTR_HIDDEN;\n\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\tif (rc != 0)\n\t\t\tgoto out_reval;\n\n\t\tgoto retry_std_delete;\n\t}\n\n\t/* undo the setattr if we errored out and it's needed */\n\tif (rc != 0 && dosattr != 0)\n\t\tcifs_set_file_info(inode, attrs, xid, full_path, origattr);\n\nout_reval:\n\tif (inode) {\n\t\tcifs_inode = CIFS_I(inode);\n\t\tcifs_inode->time = 0;\t/* will force revalidate to get info\n\t\t\t\t\t   when needed */\n\t\tinode->i_ctime = current_fs_time(sb);\n\t}\n\tdir->i_ctime = dir->i_mtime = current_fs_time(sb);\n\tcifs_inode = CIFS_I(dir);\n\tCIFS_I(dir)->time = 0;\t/* force revalidate of dir as well */\nunlink_out:\n\tkfree(full_path);\n\tkfree(attrs);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ncifs_mkdir_qinfo(struct inode *parent, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tstruct inode *inode = NULL;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, parent->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, parent->i_sb,\n\t\t\t\t\t xid, NULL);\n\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * setting nlink not necessary except in cases where we failed to get it\n\t * from the server or was set bogus. Also, since this is a brand new\n\t * inode, no need to grab the i_lock before setting the i_nlink.\n\t */\n\tif (inode->i_nlink < 2)\n\t\tset_nlink(inode, 2);\n\tmode &= ~current_umask();\n\t/* must turn on setgid bit if parent dir has it */\n\tif (parent->i_mode & S_ISGID)\n\t\tmode |= S_ISGID;\n\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode,\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (parent->i_mode & S_ISGID)\n\t\t\t\targs.gid = parent->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t       cifs_sb->local_nls,\n\t\t\t\t       cifs_remap(cifs_sb));\n\t} else {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t\t    (mode & S_IWUGO) == 0 && server->ops->mkdir_setinfo)\n\t\t\tserver->ops->mkdir_setinfo(inode, full_path, cifs_sb,\n\t\t\t\t\t\t   tcon, xid);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\tinode->i_mode = (mode | S_IFDIR);\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\tinode->i_uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\tinode->i_gid = parent->i_gid;\n\t\t\telse\n\t\t\t\tinode->i_gid = current_fsgid();\n\t\t}\n\t}\n\td_instantiate(dentry, inode);\n\treturn rc;\n}\n\nstatic int\ncifs_posix_mkdir(struct inode *inode, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tu32 oplock = 0;\n\tFILE_UNIX_BASIC_INFO *info = NULL;\n\tstruct inode *newinode = NULL;\n\tstruct cifs_fattr fattr;\n\n\tinfo = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (info == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tmode &= ~current_umask();\n\trc = CIFSPOSIXCreate(xid, tcon, SMB_O_DIRECTORY | SMB_O_CREAT, mode,\n\t\t\t     NULL /* netfid */, info, &oplock, full_path,\n\t\t\t     cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tif (rc == -EOPNOTSUPP)\n\t\tgoto posix_mkdir_out;\n\telse if (rc) {\n\t\tcifs_dbg(FYI, \"posix mkdir returned 0x%x\\n\", rc);\n\t\td_drop(dentry);\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tif (info->Type == cpu_to_le32(-1))\n\t\t/* no return info, go query for it */\n\t\tgoto posix_mkdir_get_info;\n\t/*\n\t * BB check (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID ) to see if\n\t * need to set uid/gid.\n\t */\n\n\tcifs_unix_basic_to_fattr(&fattr, info, cifs_sb);\n\tcifs_fill_uniqueid(inode->i_sb, &fattr);\n\tnewinode = cifs_iget(inode->i_sb, &fattr);\n\tif (!newinode)\n\t\tgoto posix_mkdir_get_info;\n\n\td_instantiate(dentry, newinode);\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tcifs_dbg(FYI, \"instantiated dentry %p %pd to inode %p\\n\",\n\t\t dentry, dentry, newinode);\n\n\tif (newinode->i_nlink != 2)\n\t\tcifs_dbg(FYI, \"unexpected number of links %d\\n\",\n\t\t\t newinode->i_nlink);\n#endif\n\nposix_mkdir_out:\n\tkfree(info);\n\treturn rc;\nposix_mkdir_get_info:\n\trc = cifs_mkdir_qinfo(inode, dentry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\n\tgoto posix_mkdir_out;\n}\n\nint cifs_mkdir(struct inode *inode, struct dentry *direntry, umode_t mode)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path;\n\n\tcifs_dbg(FYI, \"In cifs_mkdir, mode = 0x%hx inode = 0x%p\\n\",\n\t\t mode, inode);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mkdir_out;\n\t}\n\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_mkdir(inode, direntry, mode, full_path, cifs_sb,\n\t\t\t\t      tcon, xid);\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto mkdir_out;\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->mkdir) {\n\t\trc = -ENOSYS;\n\t\tgoto mkdir_out;\n\t}\n\n\t/* BB add setting the equivalent of mode via CreateX w/ACLs */\n\trc = server->ops->mkdir(xid, tcon, full_path, cifs_sb);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_mkdir returned 0x%x\\n\", rc);\n\t\td_drop(direntry);\n\t\tgoto mkdir_out;\n\t}\n\n\trc = cifs_mkdir_qinfo(inode, direntry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\nmkdir_out:\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tCIFS_I(inode)->time = 0;\n\tkfree(full_path);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint cifs_rmdir(struct inode *inode, struct dentry *direntry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *full_path = NULL;\n\tstruct cifsInodeInfo *cifsInode;\n\n\tcifs_dbg(FYI, \"cifs_rmdir, inode = 0x%p\\n\", inode);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rmdir_exit;\n\t}\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rmdir) {\n\t\trc = -ENOSYS;\n\t\tcifs_put_tlink(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\n\trc = server->ops->rmdir(xid, tcon, full_path, cifs_sb);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tspin_lock(&direntry->d_inode->i_lock);\n\t\ti_size_write(direntry->d_inode, 0);\n\t\tclear_nlink(direntry->d_inode);\n\t\tspin_unlock(&direntry->d_inode->i_lock);\n\t}\n\n\tcifsInode = CIFS_I(direntry->d_inode);\n\t/* force revalidate to go get info when needed */\n\tcifsInode->time = 0;\n\n\tcifsInode = CIFS_I(inode);\n\t/*\n\t * Force revalidate to get parent dir info when needed since cached\n\t * attributes are invalid now.\n\t */\n\tcifsInode->time = 0;\n\n\tdirentry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =\n\t\tcurrent_fs_time(inode->i_sb);\n\nrmdir_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_do_rename(const unsigned int xid, struct dentry *from_dentry,\n\t       const char *from_path, struct dentry *to_dentry,\n\t       const char *to_path)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(from_dentry->d_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tint oplock, rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rename)\n\t\treturn -ENOSYS;\n\n\t/* try path-based rename first */\n\trc = server->ops->rename(xid, tcon, from_path, to_path, cifs_sb);\n\n\t/*\n\t * Don't bother with rename by filehandle unless file is busy and\n\t * source. Note that cross directory moves do not work with\n\t * rename by filehandle to various Windows servers.\n\t */\n\tif (rc == 0 || rc != -EBUSY)\n\t\tgoto do_rename_exit;\n\n\t/* open-file renames don't work across directories */\n\tif (to_dentry->d_parent != from_dentry->d_parent)\n\t\tgoto do_rename_exit;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\t/* open the file to be renamed -- we need DELETE perms */\n\toparms.desired_access = DELETE;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = from_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc == 0) {\n\t\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid,\n\t\t\t\t(const char *) to_dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\ndo_rename_exit:\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\ncifs_rename2(struct inode *source_dir, struct dentry *source_dentry,\n\t     struct inode *target_dir, struct dentry *target_dentry,\n\t     unsigned int flags)\n{\n\tchar *from_name = NULL;\n\tchar *to_name = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tFILE_UNIX_BASIC_INFO *info_buf_source = NULL;\n\tFILE_UNIX_BASIC_INFO *info_buf_target;\n\tunsigned int xid;\n\tint rc, tmprc;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(source_dir->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\t/*\n\t * we already have the rename sem so we do not need to\n\t * grab it again here to protect the path integrity\n\t */\n\tfrom_name = build_path_from_dentry(source_dentry);\n\tif (from_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\tto_name = build_path_from_dentry(target_dentry);\n\tif (to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_rename_exit;\n\t}\n\n\trc = cifs_do_rename(xid, source_dentry, from_name, target_dentry,\n\t\t\t    to_name);\n\n\t/*\n\t * No-replace is the natural behavior for CIFS, so skip unlink hacks.\n\t */\n\tif (flags & RENAME_NOREPLACE)\n\t\tgoto cifs_rename_exit;\n\n\tif (rc == -EEXIST && tcon->unix_ext) {\n\t\t/*\n\t\t * Are src and dst hardlinks of same inode? We can only tell\n\t\t * with unix extensions enabled.\n\t\t */\n\t\tinfo_buf_source =\n\t\t\tkmalloc(2 * sizeof(FILE_UNIX_BASIC_INFO),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (info_buf_source == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\n\t\tinfo_buf_target = info_buf_source + 1;\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, from_name,\n\t\t\t\t\t     info_buf_source,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tif (tmprc != 0)\n\t\t\tgoto unlink_target;\n\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, to_name,\n\t\t\t\t\t     info_buf_target,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\n\t\tif (tmprc == 0 && (info_buf_source->UniqueId ==\n\t\t\t\t   info_buf_target->UniqueId)) {\n\t\t\t/* same file, POSIX says that this is a noop */\n\t\t\trc = 0;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\t}\n\t/*\n\t * else ... BB we could add the same check for Windows by\n\t * checking the UniqueId via FILE_INTERNAL_INFO\n\t */\n\nunlink_target:\n\t/* Try unlinking the target dentry if it's not negative */\n\tif (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {\n\t\tif (d_is_dir(target_dentry))\n\t\t\ttmprc = cifs_rmdir(target_dir, target_dentry);\n\t\telse\n\t\t\ttmprc = cifs_unlink(target_dir, target_dentry);\n\t\tif (tmprc)\n\t\t\tgoto cifs_rename_exit;\n\t\trc = cifs_do_rename(xid, source_dentry, from_name,\n\t\t\t\t    target_dentry, to_name);\n\t}\n\n\t/* force revalidate to go get info when needed */\n\tCIFS_I(source_dir)->time = CIFS_I(target_dir)->time = 0;\n\n\tsource_dir->i_ctime = source_dir->i_mtime = target_dir->i_ctime =\n\t\ttarget_dir->i_mtime = current_fs_time(source_dir->i_sb);\n\ncifs_rename_exit:\n\tkfree(info_buf_source);\n\tkfree(from_name);\n\tkfree(to_name);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic bool\ncifs_inode_needs_reval(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (CIFS_CACHE_READ(cifs_i))\n\t\treturn false;\n\n\tif (!lookupCacheEnabled)\n\t\treturn true;\n\n\tif (cifs_i->time == 0)\n\t\treturn true;\n\n\tif (!cifs_sb->actimeo)\n\t\treturn true;\n\n\tif (!time_in_range(jiffies, cifs_i->time,\n\t\t\t\tcifs_i->time + cifs_sb->actimeo))\n\t\treturn true;\n\n\t/* hardlinked files w/ noserverino get \"special\" treatment */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) &&\n\t    S_ISREG(inode->i_mode) && inode->i_nlink != 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Zap the cache. Called when invalid_mapping flag is set.\n */\nint\ncifs_invalidate_mapping(struct inode *inode)\n{\n\tint rc = 0;\n\n\tif (inode->i_mapping && inode->i_mapping->nrpages != 0) {\n\t\trc = invalidate_inode_pages2(inode->i_mapping);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: could not invalidate inode %p\\n\",\n\t\t\t\t __func__, inode);\n\t}\n\n\tcifs_fscache_reset_inode_cookie(inode);\n\treturn rc;\n}\n\n/**\n * cifs_wait_bit_killable - helper for functions that are sleeping on bit locks\n * @word: long word containing the bit lock\n */\nstatic int\ncifs_wait_bit_killable(struct wait_bit_key *key)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tfreezable_schedule_unsafe();\n\treturn 0;\n}\n\nint\ncifs_revalidate_mapping(struct inode *inode)\n{\n\tint rc;\n\tunsigned long *flags = &CIFS_I(inode)->flags;\n\n\trc = wait_on_bit_lock_action(flags, CIFS_INO_LOCK, cifs_wait_bit_killable,\n\t\t\t\t     TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (test_and_clear_bit(CIFS_INO_INVALID_MAPPING, flags)) {\n\t\trc = cifs_invalidate_mapping(inode);\n\t\tif (rc)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, flags);\n\t}\n\n\tclear_bit_unlock(CIFS_INO_LOCK, flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(flags, CIFS_INO_LOCK);\n\n\treturn rc;\n}\n\nint\ncifs_zap_mapping(struct inode *inode)\n{\n\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_revalidate_file_attr(struct file *filp)\n{\n\tint rc = 0;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *) filp->private_data;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\tif (tlink_tcon(cfile->tlink)->unix_ext)\n\t\trc = cifs_get_file_info_unix(filp);\n\telse\n\t\trc = cifs_get_file_info(filp);\n\n\treturn rc;\n}\n\nint cifs_revalidate_dentry_attr(struct dentry *dentry)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *full_path = NULL;\n\n\tif (inode == NULL)\n\t\treturn -ENOENT;\n\n\tif (!cifs_inode_needs_reval(inode))\n\t\treturn rc;\n\n\txid = get_xid();\n\n\t/* can not safely grab the rename sem here if rename calls revalidate\n\t   since that would deadlock */\n\tfull_path = build_path_from_dentry(dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"Update attributes: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld\\n\",\n\t\t full_path, inode, inode->i_count.counter,\n\t\t dentry, dentry->d_time, jiffies);\n\n\tif (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, sb, xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, sb,\n\t\t\t\t\t xid, NULL);\n\nout:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_revalidate_file(struct file *filp)\n{\n\tint rc;\n\tstruct inode *inode = file_inode(filp);\n\n\trc = cifs_revalidate_file_attr(filp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\n/* revalidate a dentry's inode attributes */\nint cifs_revalidate_dentry(struct dentry *dentry)\n{\n\tint rc;\n\tstruct inode *inode = dentry->d_inode;\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint rc;\n\n\t/*\n\t * We need to be sure that all dirty pages are written and the server\n\t * has actual ctime, mtime and file length.\n\t */\n\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t    inode->i_mapping->nrpages != 0) {\n\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\tif (rc) {\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = CIFS_MAX_MSGSIZE;\n\tstat->ino = CIFS_I(inode)->uniqueid;\n\n\t/*\n\t * If on a multiuser mount without unix extensions or cifsacl being\n\t * enabled, and the admin hasn't overridden them, set the ownership\n\t * to the fsuid/fsgid of the current process.\n\t */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER) &&\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t    !tcon->unix_ext) {\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID))\n\t\t\tstat->uid = current_fsuid();\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID))\n\t\t\tstat->gid = current_fsgid();\n\t}\n\treturn rc;\n}\n\nstatic int cifs_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\tint rc = 0;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn rc;\n}\n\nstatic void cifs_setsize(struct inode *inode, loff_t offset)\n{\n\tspin_lock(&inode->i_lock);\n\ti_size_write(inode, offset);\n\tspin_unlock(&inode->i_lock);\n\n\ttruncate_pagecache(inode, offset);\n}\n\nstatic int\ncifs_set_file_size(struct inode *inode, struct iattr *attrs,\n\t\t   unsigned int xid, char *full_path)\n{\n\tint rc;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_io_parms io_parms;\n\n\t/*\n\t * To avoid spurious oplock breaks from server, in the case of\n\t * inodes that we already have open, avoid doing path based\n\t * setting of file size if we can do it by handle.\n\t * This keeps our caching token (oplock) and avoids timeouts\n\t * when the local oplock break takes longer to flush\n\t * writebehind data than the SMB timeout for the SetPathInfo\n\t * request would allow\n\t */\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->set_file_size)\n\t\t\trc = server->ops->set_file_size(xid, tcon, open_file,\n\t\t\t\t\t\t\tattrs->ia_size, false);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifsFileInfo_put(open_file);\n\t\tcifs_dbg(FYI, \"SetFSize for attrs rc = %d\\n\", rc);\n\t\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = open_file->fid.netfid;\n\t\t\tio_parms.pid = open_file->pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written,\n\t\t\t\t\t  NULL, NULL, 1);\n\t\t\tcifs_dbg(FYI, \"Wrt seteof rc %d\\n\", rc);\n\t\t}\n\t} else\n\t\trc = -EINVAL;\n\n\tif (!rc)\n\t\tgoto set_size_out;\n\n\tif (tcon == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t\tserver = tcon->ses->server;\n\t}\n\n\t/*\n\t * Set file size by pathname rather than by handle either because no\n\t * valid, writeable file handle for it was found or because there was\n\t * an error setting it by handle.\n\t */\n\tif (server->ops->set_path_size)\n\t\trc = server->ops->set_path_size(xid, tcon, full_path,\n\t\t\t\t\t\tattrs->ia_size, cifs_sb, false);\n\telse\n\t\trc = -ENOSYS;\n\tcifs_dbg(FYI, \"SetEOF by path (setattrs) rc = %d\\n\", rc);\n\tif ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t__u16 netfid;\n\t\tint oplock = 0;\n\n\t\trc = SMBLegacyOpen(xid, tcon, full_path, FILE_OPEN,\n\t\t\t\t   GENERIC_WRITE, CREATE_NOT_DIR, &netfid,\n\t\t\t\t   &oplock, NULL, cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\t\tif (rc == 0) {\n\t\t\tunsigned int bytes_written;\n\n\t\t\tio_parms.netfid = netfid;\n\t\t\tio_parms.pid = current->tgid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = 0;\n\t\t\tio_parms.length = attrs->ia_size;\n\t\t\trc = CIFSSMBWrite(xid, &io_parms, &bytes_written, NULL,\n\t\t\t\t\t  NULL,  1);\n\t\t\tcifs_dbg(FYI, \"wrt seteof rc %d\\n\", rc);\n\t\t\tCIFSSMBClose(xid, tcon, netfid);\n\t\t}\n\t}\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\nset_size_out:\n\tif (rc == 0) {\n\t\tcifsInode->server_eof = attrs->ia_size;\n\t\tcifs_setsize(inode, attrs->ia_size);\n\t\tcifs_truncate_page(inode->i_mapping, inode->i_size);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)\n{\n\tint rc;\n\tunsigned int xid;\n\tchar *full_path = NULL;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_unix_set_info_args *args = NULL;\n\tstruct cifsFileInfo *open_file;\n\n\tcifs_dbg(FYI, \"setattr_unix on file %pd attrs->ia_valid=0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\txid = get_xid();\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\targs = kmalloc(sizeof(*args), GFP_KERNEL);\n\tif (args == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* set up the struct */\n\tif (attrs->ia_valid & ATTR_MODE)\n\t\targs->mode = attrs->ia_mode;\n\telse\n\t\targs->mode = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\targs->uid = attrs->ia_uid;\n\telse\n\t\targs->uid = INVALID_UID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\targs->gid = attrs->ia_gid;\n\telse\n\t\targs->gid = INVALID_GID; /* no change */\n\n\tif (attrs->ia_valid & ATTR_ATIME)\n\t\targs->atime = cifs_UnixTimeToNT(attrs->ia_atime);\n\telse\n\t\targs->atime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_MTIME)\n\t\targs->mtime = cifs_UnixTimeToNT(attrs->ia_mtime);\n\telse\n\t\targs->mtime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_CTIME)\n\t\targs->ctime = cifs_UnixTimeToNT(attrs->ia_ctime);\n\telse\n\t\targs->ctime = NO_CHANGE_64;\n\n\targs->device = 0;\n\topen_file = find_writable_file(cifsInode, true);\n\tif (open_file) {\n\t\tu16 nfid = open_file->fid.netfid;\n\t\tu32 npid = open_file->pid;\n\t\tpTcon = tlink_tcon(open_file->tlink);\n\t\trc = CIFSSMBUnixSetFileInfo(xid, pTcon, args, nfid, npid);\n\t\tcifsFileInfo_put(open_file);\n\t} else {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink)) {\n\t\t\trc = PTR_ERR(tlink);\n\t\t\tgoto out;\n\t\t}\n\t\tpTcon = tlink_tcon(tlink);\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, args,\n\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tcifs_put_tlink(tlink);\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\n\t/* force revalidate when any of these times are set since some\n\t   of the fs types (eg ext3, fat) do not have fine enough\n\t   time granularity to match protocol, and we do not have a\n\t   a way (yet) to query the server fs's time granularity (and\n\t   whether it rounds times down).\n\t*/\n\tif (attrs->ia_valid & (ATTR_MTIME | ATTR_CTIME))\n\t\tcifsInode->time = 0;\nout:\n\tkfree(args);\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)\n{\n\tunsigned int xid;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tchar *full_path = NULL;\n\tint rc = -EACCES;\n\t__u32 dosattr = 0;\n\t__u64 mode = NO_CHANGE_64;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"setattr on file %pd attrs->iavalid 0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = inode_change_ok(inode, attrs);\n\tif (rc < 0) {\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Attempt to flush data before changing attributes. We need to do\n\t * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the\n\t * ownership or mode then we may also need to do this. Here, we take\n\t * the safe way out and just do the flush on all setattr requests. If\n\t * the flush returns error, store it to report later and continue.\n\t *\n\t * BB: This should be smarter. Why bother flushing pages that\n\t * will be truncated anyway? Also, should we error out here if\n\t * the flush returns error?\n\t */\n\trc = filemap_write_and_wait(inode->i_mapping);\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto cifs_setattr_exit;\n\t}\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\tuid = attrs->ia_uid;\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\tgid = attrs->ia_gid;\n\n#ifdef CONFIG_CIFS_ACL\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\tif (uid_valid(uid) || gid_valid(gid)) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, NO_CHANGE_64,\n\t\t\t\t\t\t\tuid, gid);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting id failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t}\n\t} else\n#endif /* CONFIG_CIFS_ACL */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID))\n\t\tattrs->ia_valid &= ~(ATTR_UID | ATTR_GID);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\tif (attrs->ia_valid & ATTR_MODE) {\n\t\tmode = attrs->ia_mode;\n\t\trc = 0;\n#ifdef CONFIG_CIFS_ACL\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, mode,\n\t\t\t\t\t\tINVALID_UID, INVALID_GID);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting ACL failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_CIFS_ACL */\n\t\tif (((mode & S_IWUGO) == 0) &&\n\t\t    (cifsInode->cifsAttrs & ATTR_READONLY) == 0) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs | ATTR_READONLY;\n\n\t\t\t/* fix up mode if we're not using dynperm */\n\t\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM) == 0)\n\t\t\t\tattrs->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\t} else if ((mode & S_IWUGO) &&\n\t\t\t   (cifsInode->cifsAttrs & ATTR_READONLY)) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs & ~ATTR_READONLY;\n\t\t\t/* Attributes of 0 are ignored */\n\t\t\tif (dosattr == 0)\n\t\t\t\tdosattr |= ATTR_NORMAL;\n\n\t\t\t/* reset local inode permissions to normal */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t\tattrs->ia_mode &= ~(S_IALLUGO);\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_dir_mode;\n\t\t\t\telse\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->mnt_file_mode;\n\t\t\t}\n\t\t} else if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t/* ignore mode change - ATTR_READONLY hasn't changed */\n\t\t\tattrs->ia_valid &= ~ATTR_MODE;\n\t\t}\n\t}\n\n\tif (attrs->ia_valid & (ATTR_MTIME|ATTR_ATIME|ATTR_CTIME) ||\n\t    ((attrs->ia_valid & ATTR_MODE) && dosattr)) {\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\t/* BB: check for rc = -EOPNOTSUPP and switch to legacy mode */\n\n\t\t/* Even if error on time set, no sense failing the call if\n\t\tthe server would set the time to a reasonable value anyway,\n\t\tand this check ensures that we are not being called from\n\t\tsys_utimes in which case we ought to fail the call back to\n\t\tthe user when the server rejects the call */\n\t\tif ((rc) && (attrs->ia_valid &\n\t\t\t\t(ATTR_MODE | ATTR_GID | ATTR_UID | ATTR_SIZE)))\n\t\t\trc = 0;\n\t}\n\n\t/* do not need local check to inode_check_ok since the server does\n\t   that */\n\tif (rc)\n\t\tgoto cifs_setattr_exit;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\n\tsetattr_copy(inode, attrs);\n\tmark_inode_dirty(inode);\n\ncifs_setattr_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint\ncifs_setattr(struct dentry *direntry, struct iattr *attrs)\n{\n\tstruct inode *inode = direntry->d_inode;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (pTcon->unix_ext)\n\t\treturn cifs_setattr_unix(direntry, attrs);\n\n\treturn cifs_setattr_nounix(direntry, attrs);\n\n\t/* BB: add cifs_setattr_legacy for really old servers */\n}\n\n#if 0\nvoid cifs_delete_inode(struct inode *inode)\n{\n\tcifs_dbg(FYI, \"In cifs_delete_inode, inode = 0x%p\\n\", inode);\n\t/* may have to add back in if and when safe distributed caching of\n\t   directories added e.g. via FindNotify */\n}\n#endif"
  }
]