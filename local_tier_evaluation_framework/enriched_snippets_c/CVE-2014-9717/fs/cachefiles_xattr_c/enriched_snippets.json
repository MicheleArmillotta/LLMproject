[
  {
    "function_name": "cachefiles_remove_object_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "306-324",
    "snippet": "int cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint ret;\n\n\tret = vfs_removexattr(dentry, cachefiles_xattr_cache);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT || ret == -ENODATA)\n\t\t\tret = 0;\n\t\telse if (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\",\n\t\t\t\t\t    dentry->d_inode->i_ino, -ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\"",
            "dentry->d_inode->i_ino",
            "-ret"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_removexattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "286-314",
          "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint ret;\n\n\tret = vfs_removexattr(dentry, cachefiles_xattr_cache);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT || ret == -ENODATA)\n\t\t\tret = 0;\n\t\telse if (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\",\n\t\t\t\t\t    dentry->d_inode->i_ino, -ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_check_object_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "197-301",
    "snippet": "int cachefiles_check_object_xattr(struct cachefiles_object *object,\n\t\t\t\t  struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, cachefiles_gfp);\n\tif (!auxbuf) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxbuf->type, 512 + 1);\n\tif (ret < 0) {\n\t\tif (ret == -ENODATA)\n\t\t\tgoto stale; /* no attribute - power went off\n\t\t\t\t     * mid-cull? */\n\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\"Can't read xattr on %lu (err %d)\",\n\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the on-disk object */\n\tif (ret < 1)\n\t\tgoto bad_type_length;\n\n\tif (auxbuf->type != auxdata->type)\n\t\tgoto stale;\n\n\tauxbuf->len = ret;\n\n\t/* consult the netfs */\n\tif (object->fscache.cookie->def->check_aux) {\n\t\tenum fscache_checkaux result;\n\t\tunsigned int dlen;\n\n\t\tdlen = auxbuf->len - 1;\n\n\t\t_debug(\"checkaux %s #%u\",\n\t\t       object->fscache.cookie->def->name, dlen);\n\n\t\tresult = fscache_check_aux(&object->fscache,\n\t\t\t\t\t   &auxbuf->data, dlen);\n\n\t\tswitch (result) {\n\t\t\t/* entry okay as is */\n\t\tcase FSCACHE_CHECKAUX_OKAY:\n\t\t\tgoto okay;\n\n\t\t\t/* entry requires update */\n\t\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\t\tbreak;\n\n\t\t\t/* entry requires deletion */\n\t\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\t\tgoto stale;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/* update the current label */\n\t\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t\t   XATTR_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\"Can't update xattr on %lu\"\n\t\t\t\t\t\t\" (error %d)\",\n\t\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nokay:\n\tret = 0;\n\nerror:\n\tkfree(auxbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nstale:\n\tret = -ESTALE;\n\tgoto error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cache object %lu xattr length incorrect\\n\"",
            "dentry->d_inode->i_ino"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "auxbuf"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Can't update xattr on %lu\"\n\t\t\t\t\t\t\" (error %d)\"",
            "dentry->d_inode->i_ino",
            "-ret"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "&auxdata->type",
            "auxdata->len",
            "XATTR_REPLACE"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_check_aux",
          "args": [
            "&object->fscache",
            "&auxbuf->data",
            "dlen"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_check_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "884-917",
          "snippet": "enum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nenum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"checkaux %s #%u\"",
            "object->fscache.cookie->def->name",
            "dlen"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Can't read xattr on %lu (err %d)\"",
            "dentry->d_inode->i_ino",
            "-ret"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "&auxbuf->type",
            "512 + 1"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry->d_inode"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,#%d\"",
            "object",
            "auxdata->len"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_check_object_xattr(struct cachefiles_object *object,\n\t\t\t\t  struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, cachefiles_gfp);\n\tif (!auxbuf) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxbuf->type, 512 + 1);\n\tif (ret < 0) {\n\t\tif (ret == -ENODATA)\n\t\t\tgoto stale; /* no attribute - power went off\n\t\t\t\t     * mid-cull? */\n\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\"Can't read xattr on %lu (err %d)\",\n\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the on-disk object */\n\tif (ret < 1)\n\t\tgoto bad_type_length;\n\n\tif (auxbuf->type != auxdata->type)\n\t\tgoto stale;\n\n\tauxbuf->len = ret;\n\n\t/* consult the netfs */\n\tif (object->fscache.cookie->def->check_aux) {\n\t\tenum fscache_checkaux result;\n\t\tunsigned int dlen;\n\n\t\tdlen = auxbuf->len - 1;\n\n\t\t_debug(\"checkaux %s #%u\",\n\t\t       object->fscache.cookie->def->name, dlen);\n\n\t\tresult = fscache_check_aux(&object->fscache,\n\t\t\t\t\t   &auxbuf->data, dlen);\n\n\t\tswitch (result) {\n\t\t\t/* entry okay as is */\n\t\tcase FSCACHE_CHECKAUX_OKAY:\n\t\t\tgoto okay;\n\n\t\t\t/* entry requires update */\n\t\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\t\tbreak;\n\n\t\t\t/* entry requires deletion */\n\t\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\t\tgoto stale;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/* update the current label */\n\t\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t\t   XATTR_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\"Can't update xattr on %lu\"\n\t\t\t\t\t\t\" (error %d)\",\n\t\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nokay:\n\tret = 0;\n\nerror:\n\tkfree(auxbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nstale:\n\tret = -ESTALE;\n\tgoto error;\n}"
  },
  {
    "function_name": "cachefiles_check_auxdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "159-191",
    "snippet": "int cachefiles_check_auxdata(struct cachefiles_object *object)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tenum fscache_checkaux validity;\n\tstruct dentry *dentry = object->dentry;\n\tssize_t xlen;\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\tASSERT(object->fscache.cookie->def->check_aux);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, GFP_KERNEL);\n\tif (!auxbuf)\n\t\treturn -ENOMEM;\n\n\txlen = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t    &auxbuf->type, 512 + 1);\n\tret = -ESTALE;\n\tif (xlen < 1 ||\n\t    auxbuf->type != object->fscache.cookie->def->type)\n\t\tgoto error;\n\n\txlen--;\n\tvalidity = fscache_check_aux(&object->fscache, &auxbuf->data, xlen);\n\tif (validity != FSCACHE_CHECKAUX_OKAY)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(auxbuf);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "auxbuf"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_check_aux",
          "args": [
            "&object->fscache",
            "&auxbuf->data",
            "xlen"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_check_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "884-917",
          "snippet": "enum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nenum fscache_checkaux fscache_check_aux(struct fscache_object *object,\n\t\t\t\t\tconst void *data, uint16_t datalen)\n{\n\tenum fscache_checkaux result;\n\n\tif (!object->cookie->def->check_aux) {\n\t\tfscache_stat(&fscache_n_checkaux_none);\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\tresult = object->cookie->def->check_aux(object->cookie->netfs_data,\n\t\t\t\t\t\tdata, datalen);\n\tswitch (result) {\n\t\t/* entry okay as is */\n\tcase FSCACHE_CHECKAUX_OKAY:\n\t\tfscache_stat(&fscache_n_checkaux_okay);\n\t\tbreak;\n\n\t\t/* entry requires update */\n\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\tfscache_stat(&fscache_n_checkaux_update);\n\t\tbreak;\n\n\t\t/* entry requires deletion */\n\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\tfscache_stat(&fscache_n_checkaux_obsolete);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "&auxbuf->type",
            "512 + 1"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct cachefiles_xattr) + 512",
            "GFP_KERNEL"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object->fscache.cookie->def->check_aux"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry->d_inode"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_check_auxdata(struct cachefiles_object *object)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tenum fscache_checkaux validity;\n\tstruct dentry *dentry = object->dentry;\n\tssize_t xlen;\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\tASSERT(object->fscache.cookie->def->check_aux);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, GFP_KERNEL);\n\tif (!auxbuf)\n\t\treturn -ENOMEM;\n\n\txlen = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t    &auxbuf->type, 512 + 1);\n\tret = -ESTALE;\n\tif (xlen < 1 ||\n\t    auxbuf->type != object->fscache.cookie->def->type)\n\t\tgoto error;\n\n\txlen--;\n\tvalidity = fscache_check_aux(&object->fscache, &auxbuf->data, xlen);\n\tif (validity != FSCACHE_CHECKAUX_OKAY)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(auxbuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_update_object_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "131-154",
    "snippet": "int cachefiles_update_object_xattr(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_REPLACE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to update xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Failed to update xattr with error %d\"",
            "ret"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "&auxdata->type",
            "auxdata->len",
            "XATTR_REPLACE"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"SET #%u\"",
            "auxdata->len"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,#%d\"",
            "object",
            "auxdata->len"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_update_object_xattr(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_REPLACE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to update xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_set_object_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "103-126",
    "snippet": "int cachefiles_set_object_xattr(struct cachefiles_object *object,\n\t\t\t\tstruct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_CREATE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to set xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Failed to set xattr with error %d\"",
            "ret"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "&auxdata->type",
            "auxdata->len",
            "XATTR_CREATE"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"SET #%u\"",
            "auxdata->len"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,#%d\"",
            "object",
            "auxdata->len"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_set_object_xattr(struct cachefiles_object *object,\n\t\t\t\tstruct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_CREATE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to set xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_check_object_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
    "lines": "29-98",
    "snippet": "int cachefiles_check_object_type(struct cachefiles_object *object)\n{\n\tstruct dentry *dentry = object->dentry;\n\tchar type[3], xtype[3];\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tif (!object->fscache.cookie)\n\t\tstrcpy(type, \"C3\");\n\telse\n\t\tsnprintf(type, 3, \"%02x\", object->fscache.cookie->def->type);\n\n\t_enter(\"%p{%s}\", object, type);\n\n\t/* attempt to install a type label directly */\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache, type, 2,\n\t\t\t   XATTR_CREATE);\n\tif (ret == 0) {\n\t\t_debug(\"SET\"); /* we succeeded */\n\t\tgoto error;\n\t}\n\n\tif (ret != -EEXIST) {\n\t\tpr_err(\"Can't set xattr on %pd [%lu] (err %d)\\n\",\n\t\t       dentry, dentry->d_inode->i_ino,\n\t\t       -ret);\n\t\tgoto error;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache, xtype, 3);\n\tif (ret < 0) {\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tpr_err(\"Can't read xattr on %pd [%lu] (err %d)\\n\",\n\t\t       dentry, dentry->d_inode->i_ino,\n\t\t       -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the type is what we're expecting */\n\tif (ret != 2)\n\t\tgoto bad_type_length;\n\n\tif (xtype[0] != type[0] || xtype[1] != type[1])\n\t\tgoto bad_type;\n\n\tret = 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu type xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nbad_type:\n\txtype[2] = 0;\n\tpr_err(\"Cache object %pd [%lu] type %s not %s\\n\",\n\t       dentry, dentry->d_inode->i_ino,\n\t       xtype, type);\n\tret = -EIO;\n\tgoto error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cache object %pd [%lu] type %s not %s\\n\"",
            "dentry",
            "dentry->d_inode->i_ino",
            "xtype",
            "type"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cache object %lu type xattr length incorrect\\n\"",
            "dentry->d_inode->i_ino"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't read xattr on %pd [%lu] (err %d)\\n\"",
            "dentry",
            "dentry->d_inode->i_ino",
            "-ret"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "xtype",
            "3"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't set xattr on %pd [%lu] (err %d)\\n\"",
            "dentry",
            "dentry->d_inode->i_ino",
            "-ret"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"SET\""
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "dentry",
            "cachefiles_xattr_cache",
            "type",
            "2",
            "XATTR_CREATE"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p{%s}\"",
            "object",
            "type"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "type",
            "3",
            "\"%02x\"",
            "object->fscache.cookie->def->type"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "type",
            "\"C3\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry->d_inode"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dentry"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_check_object_type(struct cachefiles_object *object)\n{\n\tstruct dentry *dentry = object->dentry;\n\tchar type[3], xtype[3];\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tif (!object->fscache.cookie)\n\t\tstrcpy(type, \"C3\");\n\telse\n\t\tsnprintf(type, 3, \"%02x\", object->fscache.cookie->def->type);\n\n\t_enter(\"%p{%s}\", object, type);\n\n\t/* attempt to install a type label directly */\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache, type, 2,\n\t\t\t   XATTR_CREATE);\n\tif (ret == 0) {\n\t\t_debug(\"SET\"); /* we succeeded */\n\t\tgoto error;\n\t}\n\n\tif (ret != -EEXIST) {\n\t\tpr_err(\"Can't set xattr on %pd [%lu] (err %d)\\n\",\n\t\t       dentry, dentry->d_inode->i_ino,\n\t\t       -ret);\n\t\tgoto error;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache, xtype, 3);\n\tif (ret < 0) {\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tpr_err(\"Can't read xattr on %pd [%lu] (err %d)\\n\",\n\t\t       dentry, dentry->d_inode->i_ino,\n\t\t       -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the type is what we're expecting */\n\tif (ret != 2)\n\t\tgoto bad_type_length;\n\n\tif (xtype[0] != type[0] || xtype[1] != type[1])\n\t\tgoto bad_type;\n\n\tret = 0;\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu type xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nbad_type:\n\txtype[2] = 0;\n\tpr_err(\"Cache object %pd [%lu] type %s not %s\\n\",\n\t       dentry, dentry->d_inode->i_ino,\n\t       xtype, type);\n\tret = -EIO;\n\tgoto error;\n}"
  }
]