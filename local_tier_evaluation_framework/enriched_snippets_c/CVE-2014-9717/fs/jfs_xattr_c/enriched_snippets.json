[
  {
    "function_name": "jfs_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "1100-1105",
    "snippet": "int jfs_init_security(tid_t tid, struct inode *inode, struct inode *dir,\n\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &jfs_initxattrs, &tid);\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&jfs_initxattrs",
            "&tid"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint jfs_init_security(tid_t tid, struct inode *inode, struct inode *dir,\n\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &jfs_initxattrs, &tid);\n}"
  },
  {
    "function_name": "jfs_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "1073-1098",
    "snippet": "static int jfs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t\t  void *fs_info)\n{\n\tconst struct xattr *xattr;\n\ttid_t *tid = fs_info;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\n\t\terr = __jfs_setxattr(*tid, inode, name,\n\t\t\t\t     xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jfs_setxattr",
          "args": [
            "*tid",
            "inode",
            "name",
            "xattr->value",
            "xattr->value_len",
            "0"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "697-847",
          "snippet": "int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "name + XATTR_SECURITY_PREFIX_LEN",
            "xattr->name"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1",
            "GFP_NOFS"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xattr->name"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int jfs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t\t  void *fs_info)\n{\n\tconst struct xattr *xattr;\n\ttid_t *tid = fs_info;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\n\t\terr = __jfs_setxattr(*tid, inode, name,\n\t\t\t\t     xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "jfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "1030-1057",
    "snippet": "int jfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tint rc;\n\ttid_t tid;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\tif ((rc = can_set_xattr(inode, name, NULL, 0)))\n\t\treturn rc;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&ji->commit_mutex);\n\trc = __jfs_setxattr(tid, dentry->d_inode, name, NULL, 0, XATTR_REPLACE);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&ji->commit_mutex);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ji->commit_mutex"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&inode",
            "0"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jfs_setxattr",
          "args": [
            "tid",
            "dentry->d_inode",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "697-847",
          "snippet": "int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ji->commit_mutex"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "inode->i_sb",
            "0"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_set_xattr",
          "args": [
            "inode",
            "name",
            "NULL",
            "0"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "can_set_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "672-695",
          "snippet": "static int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "generic_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "777-787",
          "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint jfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tint rc;\n\ttid_t tid;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\tif ((rc = can_set_xattr(inode, name, NULL, 0)))\n\t\treturn rc;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&ji->commit_mutex);\n\trc = __jfs_setxattr(tid, dentry->d_inode, name, NULL, 0, XATTR_REPLACE);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&ji->commit_mutex);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "977-1028",
    "snippet": "ssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *buffer;\n\tssize_t size = 0;\n\tint xattr_size;\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto release;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* compute required size of list */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea))\n\t\t\tsize += name_size(ea) + 1;\n\t}\n\n\tif (!data)\n\t\tgoto release;\n\n\tif (size > buf_size) {\n\t\tsize = -ERANGE;\n\t\tgoto release;\n\t}\n\n\t/* Copy attribute names to buffer */\n\tbuffer = data;\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea)) {\n\t\t\tint namelen = copy_name(buffer, ea);\n\t\t\tbuffer += namelen + 1;\n\t\t}\n\t}\n\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\treturn size;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_release",
          "args": [
            "inode",
            "&ea_buf"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ea_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "591-603",
          "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_name",
          "args": [
            "buffer",
            "ea"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "118-131",
          "snippet": "static inline int copy_name(char *buffer, struct jfs_ea *ea)\n{\n\tint len = ea->namelen;\n\n\tif (is_os2_xattr(ea)) {\n\t\tmemcpy(buffer, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN);\n\t\tbuffer += XATTR_OS2_PREFIX_LEN;\n\t\tlen += XATTR_OS2_PREFIX_LEN;\n\t}\n\tmemcpy(buffer, ea->name, ea->namelen);\n\tbuffer[ea->namelen] = 0;\n\n\treturn len;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int copy_name(char *buffer, struct jfs_ea *ea)\n{\n\tint len = ea->namelen;\n\n\tif (is_os2_xattr(ea)) {\n\t\tmemcpy(buffer, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN);\n\t\tbuffer += XATTR_OS2_PREFIX_LEN;\n\t\tlen += XATTR_OS2_PREFIX_LEN;\n\t}\n\tmemcpy(buffer, ea->name, ea->namelen);\n\tbuffer[ea->namelen] = 0;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_list",
          "args": [
            "ea"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "can_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "970-975",
          "snippet": "static inline int can_list(struct jfs_ea *ea)\n{\n\treturn (strncmp(ea->name, XATTR_TRUSTED_PREFIX,\n\t\t\t    XATTR_TRUSTED_PREFIX_LEN) ||\n\t\tcapable(CAP_SYS_ADMIN));\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int can_list(struct jfs_ea *ea)\n{\n\treturn (strncmp(ea->name, XATTR_TRUSTED_PREFIX,\n\t\t\t    XATTR_TRUSTED_PREFIX_LEN) ||\n\t\tcapable(CAP_SYS_ADMIN));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_EA",
          "args": [
            "ea"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END_EALIST",
          "args": [
            "ealist"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_EA",
          "args": [
            "ealist"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_size",
          "args": [
            "ea"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "name_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "110-116",
          "snippet": "static inline int name_size(struct jfs_ea *ea)\n{\n\tif (is_os2_xattr(ea))\n\t\treturn ea->namelen + XATTR_OS2_PREFIX_LEN;\n\telse\n\t\treturn ea->namelen;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int name_size(struct jfs_ea *ea)\n{\n\tif (is_os2_xattr(ea))\n\t\treturn ea->namelen + XATTR_OS2_PREFIX_LEN;\n\telse\n\t\treturn ea->namelen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_EA",
          "args": [
            "ea"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END_EALIST",
          "args": [
            "ealist"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_EA",
          "args": [
            "ealist"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_get",
          "args": [
            "inode",
            "&ea_buf",
            "0"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "ea_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "441-589",
          "snippet": "static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002",
            "#define EA_INLINE\t0x0001"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *buffer;\n\tssize_t size = 0;\n\tint xattr_size;\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto release;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* compute required size of list */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea))\n\t\t\tsize += name_size(ea) + 1;\n\t}\n\n\tif (!data)\n\t\tgoto release;\n\n\tif (size > buf_size) {\n\t\tsize = -ERANGE;\n\t\tgoto release;\n\t}\n\n\t/* Copy attribute names to buffer */\n\tbuffer = data;\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea)) {\n\t\t\tint namelen = copy_name(buffer, ea);\n\t\t\tbuffer += namelen + 1;\n\t\t}\n\t}\n\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\treturn size;\n}"
  },
  {
    "function_name": "can_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "970-975",
    "snippet": "static inline int can_list(struct jfs_ea *ea)\n{\n\treturn (strncmp(ea->name, XATTR_TRUSTED_PREFIX,\n\t\t\t    XATTR_TRUSTED_PREFIX_LEN) ||\n\t\tcapable(CAP_SYS_ADMIN));\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ea->name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int can_list(struct jfs_ea *ea)\n{\n\treturn (strncmp(ea->name, XATTR_TRUSTED_PREFIX,\n\t\t\t    XATTR_TRUSTED_PREFIX_LEN) ||\n\t\tcapable(CAP_SYS_ADMIN));\n}"
  },
  {
    "function_name": "jfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "936-965",
    "snippet": "ssize_t jfs_getxattr(struct dentry *dentry, const char *name, void *data,\n\t\t     size_t buf_size)\n{\n\tint err;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, data, buf_size);\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\t/*\n\t\t * skip past \"os2.\" prefix\n\t\t */\n\t\tname += XATTR_OS2_PREFIX_LEN;\n\t\t/*\n\t\t * Don't allow retrieving properly prefixed attributes\n\t\t * by prepending them with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = __jfs_getxattr(dentry->d_inode, name, data, buf_size);\n\n\treturn err;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jfs_getxattr",
          "args": [
            "dentry->d_inode",
            "name",
            "data",
            "buf_size"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "885-934",
          "snippet": "ssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "name"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "89-98",
          "snippet": "static int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_OS2_PREFIX",
            "XATTR_OS2_PREFIX_LEN"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_getxattr",
          "args": [
            "dentry",
            "name",
            "data",
            "buf_size"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "generic_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "715-724",
          "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nssize_t jfs_getxattr(struct dentry *dentry, const char *name, void *data,\n\t\t     size_t buf_size)\n{\n\tint err;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, data, buf_size);\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\t/*\n\t\t * skip past \"os2.\" prefix\n\t\t */\n\t\tname += XATTR_OS2_PREFIX_LEN;\n\t\t/*\n\t\t * Don't allow retrieving properly prefixed attributes\n\t\t * by prepending them with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = __jfs_getxattr(dentry->d_inode, name, data, buf_size);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__jfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "885-934",
    "snippet": "ssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_release",
          "args": [
            "inode",
            "&ea_buf"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ea_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "591-603",
          "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "value",
            "size"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ea->valuelen"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "ea->name",
            "namelen"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_EA",
          "args": [
            "ea"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END_EALIST",
          "args": [
            "ealist"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_EA",
          "args": [
            "ealist"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_get",
          "args": [
            "inode",
            "&ea_buf",
            "0"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ea_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "441-589",
          "snippet": "static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002",
            "#define EA_INLINE\t0x0001"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t/* Find the named attribute */\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t/* Found it */\n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}"
  },
  {
    "function_name": "jfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "849-883",
    "snippet": "int jfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t size_t value_len, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tint rc;\n\ttid_t tid;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, value_len, flags);\n\n\tif ((rc = can_set_xattr(inode, name, value, value_len)))\n\t\treturn rc;\n\n\tif (value == NULL) {\t/* empty EA, do not remove */\n\t\tvalue = \"\";\n\t\tvalue_len = 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&ji->commit_mutex);\n\trc = __jfs_setxattr(tid, dentry->d_inode, name, value, value_len,\n\t\t\t    flags);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&ji->commit_mutex);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ji->commit_mutex"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&inode",
            "0"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jfs_setxattr",
          "args": [
            "tid",
            "dentry->d_inode",
            "name",
            "value",
            "value_len",
            "flags"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "__jfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "697-847",
          "snippet": "int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ji->commit_mutex"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "inode->i_sb",
            "0"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_set_xattr",
          "args": [
            "inode",
            "name",
            "value",
            "value_len"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "can_set_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "672-695",
          "snippet": "static int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "value_len",
            "flags"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "760-771",
          "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint jfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t size_t value_len, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tint rc;\n\ttid_t tid;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, value_len, flags);\n\n\tif ((rc = can_set_xattr(inode, name, value, value_len)))\n\t\treturn rc;\n\n\tif (value == NULL) {\t/* empty EA, do not remove */\n\t\tvalue = \"\";\n\t\tvalue_len = 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&ji->commit_mutex);\n\trc = __jfs_setxattr(tid, dentry->d_inode, name, value, value_len,\n\t\t\t    flags);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&ji->commit_mutex);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__jfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "697-847",
    "snippet": "int __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "os2name"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_release",
          "args": [
            "inode",
            "&ea_buf"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ea_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "591-603",
          "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_put",
          "args": [
            "tid",
            "inode",
            "&ea_buf",
            "new_size"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "ea_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "605-666",
          "snippet": "static int ea_put(tid_t tid, struct inode *inode, struct ea_buffer *ea_buf,\n\t\t  int new_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tunsigned long old_blocks, new_blocks;\n\tint rc = 0;\n\n\tif (new_size == 0) {\n\t\tea_release(inode, ea_buf);\n\t\tea_buf = NULL;\n\t} else if (ea_buf->flag & EA_INLINE) {\n\t\tassert(new_size <= sizeof (ji->i_inline_ea));\n\t\tji->mode2 &= ~INLINEEA;\n\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\tDXDsize(&ea_buf->new_ea, new_size);\n\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\tDXDlength(&ea_buf->new_ea, 0);\n\t} else if (ea_buf->flag & EA_MALLOC) {\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tkfree(ea_buf->xattr);\n\t} else if (ea_buf->flag & EA_NEW) {\n\t\t/* We have already allocated a new dxd */\n\t\tflush_metapage(ea_buf->mp);\n\t} else {\n\t\t/* ->xattr must point to original ea's metapage */\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tdiscard_metapage(ea_buf->mp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\told_blocks = new_blocks = 0;\n\n\tif (ji->ea.flag & DXD_EXTENT) {\n\t\tinvalidate_dxd_metapages(inode, ji->ea);\n\t\told_blocks = lengthDXD(&ji->ea);\n\t}\n\n\tif (ea_buf) {\n\t\ttxEA(tid, inode, &ji->ea, &ea_buf->new_ea);\n\t\tif (ea_buf->new_ea.flag & DXD_EXTENT) {\n\t\t\tnew_blocks = lengthDXD(&ea_buf->new_ea);\n\t\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\t\tji->mode2 |= INLINEEA;\n\t\t}\n\t\tji->ea = ea_buf->new_ea;\n\t} else {\n\t\ttxEA(tid, inode, &ji->ea, NULL);\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t\tji->ea.flag = 0;\n\t\tji->ea.size = 0;\n\t}\n\n\t/* If old blocks exist, they must be removed from quota allocation. */\n\tif (old_blocks)\n\t\tdquot_free_block(inode, old_blocks);\n\n\tinode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_INLINE\t0x0001"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_put(tid_t tid, struct inode *inode, struct ea_buffer *ea_buf,\n\t\t  int new_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tunsigned long old_blocks, new_blocks;\n\tint rc = 0;\n\n\tif (new_size == 0) {\n\t\tea_release(inode, ea_buf);\n\t\tea_buf = NULL;\n\t} else if (ea_buf->flag & EA_INLINE) {\n\t\tassert(new_size <= sizeof (ji->i_inline_ea));\n\t\tji->mode2 &= ~INLINEEA;\n\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\tDXDsize(&ea_buf->new_ea, new_size);\n\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\tDXDlength(&ea_buf->new_ea, 0);\n\t} else if (ea_buf->flag & EA_MALLOC) {\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tkfree(ea_buf->xattr);\n\t} else if (ea_buf->flag & EA_NEW) {\n\t\t/* We have already allocated a new dxd */\n\t\tflush_metapage(ea_buf->mp);\n\t} else {\n\t\t/* ->xattr must point to original ea's metapage */\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tdiscard_metapage(ea_buf->mp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\told_blocks = new_blocks = 0;\n\n\tif (ji->ea.flag & DXD_EXTENT) {\n\t\tinvalidate_dxd_metapages(inode, ji->ea);\n\t\told_blocks = lengthDXD(&ji->ea);\n\t}\n\n\tif (ea_buf) {\n\t\ttxEA(tid, inode, &ji->ea, &ea_buf->new_ea);\n\t\tif (ea_buf->new_ea.flag & DXD_EXTENT) {\n\t\t\tnew_blocks = lengthDXD(&ea_buf->new_ea);\n\t\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\t\tji->mode2 |= INLINEEA;\n\t\t}\n\t\tji->ea = ea_buf->new_ea;\n\t} else {\n\t\ttxEA(tid, inode, &ji->ea, NULL);\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t\tji->ea.flag = 0;\n\t\tji->ea.size = 0;\n\t}\n\n\t/* If old blocks exist, they must be removed from quota allocation. */\n\tif (old_blocks)\n\t\tdquot_free_block(inode, old_blocks);\n\n\tinode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_size"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\"",
            "xattr_size",
            "new_size"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EA_SIZE",
          "args": [
            "ea"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ea->name[namelen + 1]",
            "value",
            "value_len"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ea->name",
            "name",
            "namelen"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "value_len"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "old_ea",
            "next_ea",
            "length"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END_EALIST",
          "args": [
            "ealist"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_get",
          "args": [
            "inode",
            "&ea_buf",
            "new_size"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "ea_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "441-589",
          "snippet": "static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002",
            "#define EA_INLINE\t0x0001"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EA_SIZE",
          "args": [
            "ea"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_EA",
          "args": [
            "ea"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EA_SIZE",
          "args": [
            "ea"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "ea->name",
            "namelen"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_EA",
          "args": [
            "ea"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END_EALIST",
          "args": [
            "ealist"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_EA",
          "args": [
            "ealist"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&JFS_IP(inode)->xattr_sem"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "os2name",
            "name + XATTR_OS2_PREFIX_LEN"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "namelen - XATTR_OS2_PREFIX_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_OS2_PREFIX",
            "XATTR_OS2_PREFIX_LEN"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tchar *os2name = NULL;\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!os2name)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n\t\tname = os2name;\n\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n\t}\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t/*\n\t\t * We need to allocate more space for merged ea list.\n\t\t * We should only have loop to again: once.\n\t\t */\n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t/* Remove old ea of the same name */\n\tif (found) {\n\t\t/* number of bytes following target EA */\n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t/* Add new entry to the end */\n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t/* Completely new ea list */\n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t/*\n\t\t * The size of EA value is limitted by on-disk format up to\n\t\t *  __le16, there would be an overflow if the size is equal\n\t\t * to XATTR_SIZE_MAX (65536).  In order to avoid this issue,\n\t\t * we can pre-checkup the value size against USHRT_MAX, and\n\t\t * return -E2BIG in this case, which is consistent with the\n\t\t * VFS setxattr interface.\n\t\t */\n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t/* DEBUG - If we did this right, these number match */\n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t/*\n\t * If we're left with an empty list, there's no ea\n\t */\n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\tkfree(os2name);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "can_set_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "672-695",
    "snippet": "static int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "name + XATTR_OS2_PREFIX_LEN"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "89-98",
          "snippet": "static int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_OS2_PREFIX",
            "XATTR_OS2_PREFIX_LEN"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int can_set_xattr(struct inode *inode, const char *name,\n\t\t\t const void *value, size_t value_len)\n{\n\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n\t\t/*\n\t\t * This makes sure that we aren't trying to set an\n\t\t * attribute in a different namespace by prefixing it\n\t\t * with \"os2.\"\n\t\t */\n\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Don't allow setting an attribute in an unknown namespace.\n\t */\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "605-666",
    "snippet": "static int ea_put(tid_t tid, struct inode *inode, struct ea_buffer *ea_buf,\n\t\t  int new_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tunsigned long old_blocks, new_blocks;\n\tint rc = 0;\n\n\tif (new_size == 0) {\n\t\tea_release(inode, ea_buf);\n\t\tea_buf = NULL;\n\t} else if (ea_buf->flag & EA_INLINE) {\n\t\tassert(new_size <= sizeof (ji->i_inline_ea));\n\t\tji->mode2 &= ~INLINEEA;\n\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\tDXDsize(&ea_buf->new_ea, new_size);\n\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\tDXDlength(&ea_buf->new_ea, 0);\n\t} else if (ea_buf->flag & EA_MALLOC) {\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tkfree(ea_buf->xattr);\n\t} else if (ea_buf->flag & EA_NEW) {\n\t\t/* We have already allocated a new dxd */\n\t\tflush_metapage(ea_buf->mp);\n\t} else {\n\t\t/* ->xattr must point to original ea's metapage */\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tdiscard_metapage(ea_buf->mp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\told_blocks = new_blocks = 0;\n\n\tif (ji->ea.flag & DXD_EXTENT) {\n\t\tinvalidate_dxd_metapages(inode, ji->ea);\n\t\told_blocks = lengthDXD(&ji->ea);\n\t}\n\n\tif (ea_buf) {\n\t\ttxEA(tid, inode, &ji->ea, &ea_buf->new_ea);\n\t\tif (ea_buf->new_ea.flag & DXD_EXTENT) {\n\t\t\tnew_blocks = lengthDXD(&ea_buf->new_ea);\n\t\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\t\tji->mode2 |= INLINEEA;\n\t\t}\n\t\tji->ea = ea_buf->new_ea;\n\t} else {\n\t\ttxEA(tid, inode, &ji->ea, NULL);\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t\tji->ea.flag = 0;\n\t\tji->ea.size = 0;\n\t}\n\n\t/* If old blocks exist, they must be removed from quota allocation. */\n\tif (old_blocks)\n\t\tdquot_free_block(inode, old_blocks);\n\n\tinode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define EA_MALLOC\t0x0008",
      "#define EA_NEW\t\t0x0004",
      "#define EA_INLINE\t0x0001"
    ],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "old_blocks"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEA",
          "args": [
            "tid",
            "inode",
            "&ji->ea",
            "NULL"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "txEA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2173-2217",
          "snippet": "void txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&ea_buf->new_ea"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_dxd_metapages",
          "args": [
            "inode",
            "ji->ea"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "ea_buf->mp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_write",
          "args": [
            "inode",
            "ea_buf->xattr",
            "new_size",
            "&ea_buf->new_ea"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "216-319",
          "snippet": "static int ea_write(struct inode *ip, struct jfs_ea_list *ealist, int size,\n\t\t       dxd_t * ea)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tint rc = 0, i;\n\tchar *cp;\n\ts32 nbytes, nb;\n\ts32 bytes_to_write;\n\tstruct metapage *mp;\n\n\t/*\n\t * Quick check to see if this is an in-linable EA.  Short EAs\n\t * and empty EAs are all in-linable, provided the space exists.\n\t */\n\tif (!ealist || size <= sizeof (ji->i_inline_ea)) {\n\t\tif (!ea_write_inline(ip, ealist, size, ea))\n\t\t\treturn 0;\n\t}\n\n\t/* figure out how many blocks we need */\n\tnblocks = (size + (sb->s_blocksize - 1)) >> sb->s_blocksize_bits;\n\n\t/* Allocate new blocks to quota. */\n\trc = dquot_alloc_block(ip, nblocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);\n\tif (rc) {\n\t\t/*Rollback quota allocation. */\n\t\tdquot_free_block(ip, nblocks);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Now have nblocks worth of storage to stuff into the FEALIST.\n\t * loop over the FEALIST copying data into the buffer one page at\n\t * a time.\n\t */\n\tcp = (char *) ealist;\n\tnbytes = size;\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_write =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = get_metapage(ip, blkno + i, bytes_to_write, 1))) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemcpy(mp->data, cp, nb);\n\n\t\t/*\n\t\t * We really need a way to propagate errors for\n\t\t * forced writes like this one.  --hch\n\t\t *\n\t\t * (__write_metapage => release_metapage => flush_metapage)\n\t\t */\n#ifdef _JFS_FIXME\n\t\tif ((rc = flush_metapage(mp))) {\n\t\t\t/*\n\t\t\t * the write failed -- this means that the buffer\n\t\t\t * is still assigned and the blocks are not being\n\t\t\t * used.  this seems like the best error recovery\n\t\t\t * we can get ...\n\t\t\t */\n\t\t\tgoto failed;\n\t\t}\n#else\n\t\tflush_metapage(mp);\n#endif\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\tea->flag = DXD_EXTENT;\n\tDXDsize(ea, le32_to_cpu(ealist->size));\n\tDXDlength(ea, nblocks);\n\tDXDaddress(ea, blkno);\n\n\t/* Free up INLINE area */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\tji->mode2 |= INLINEEA;\n\n\treturn 0;\n\n      failed:\n\t/* Rollback quota allocation. */\n\tdquot_free_block(ip, nblocks);\n\n\tdbFree(ip, blkno, nblocks);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_write(struct inode *ip, struct jfs_ea_list *ealist, int size,\n\t\t       dxd_t * ea)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tint rc = 0, i;\n\tchar *cp;\n\ts32 nbytes, nb;\n\ts32 bytes_to_write;\n\tstruct metapage *mp;\n\n\t/*\n\t * Quick check to see if this is an in-linable EA.  Short EAs\n\t * and empty EAs are all in-linable, provided the space exists.\n\t */\n\tif (!ealist || size <= sizeof (ji->i_inline_ea)) {\n\t\tif (!ea_write_inline(ip, ealist, size, ea))\n\t\t\treturn 0;\n\t}\n\n\t/* figure out how many blocks we need */\n\tnblocks = (size + (sb->s_blocksize - 1)) >> sb->s_blocksize_bits;\n\n\t/* Allocate new blocks to quota. */\n\trc = dquot_alloc_block(ip, nblocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);\n\tif (rc) {\n\t\t/*Rollback quota allocation. */\n\t\tdquot_free_block(ip, nblocks);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Now have nblocks worth of storage to stuff into the FEALIST.\n\t * loop over the FEALIST copying data into the buffer one page at\n\t * a time.\n\t */\n\tcp = (char *) ealist;\n\tnbytes = size;\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_write =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = get_metapage(ip, blkno + i, bytes_to_write, 1))) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemcpy(mp->data, cp, nb);\n\n\t\t/*\n\t\t * We really need a way to propagate errors for\n\t\t * forced writes like this one.  --hch\n\t\t *\n\t\t * (__write_metapage => release_metapage => flush_metapage)\n\t\t */\n#ifdef _JFS_FIXME\n\t\tif ((rc = flush_metapage(mp))) {\n\t\t\t/*\n\t\t\t * the write failed -- this means that the buffer\n\t\t\t * is still assigned and the blocks are not being\n\t\t\t * used.  this seems like the best error recovery\n\t\t\t * we can get ...\n\t\t\t */\n\t\t\tgoto failed;\n\t\t}\n#else\n\t\tflush_metapage(mp);\n#endif\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\tea->flag = DXD_EXTENT;\n\tDXDsize(ea, le32_to_cpu(ealist->size));\n\tDXDlength(ea, nblocks);\n\tDXDaddress(ea, blkno);\n\n\t/* Free up INLINE area */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\tji->mode2 |= INLINEEA;\n\n\treturn 0;\n\n      failed:\n\t/* Rollback quota allocation. */\n\tdquot_free_block(ip, nblocks);\n\n\tdbFree(ip, blkno, nblocks);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_metapage",
          "args": [
            "ea_buf->mp"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "flush_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "91-95",
          "snippet": "static inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_sync\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_sync\t3\n\nstatic inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea_buf->xattr"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "&ea_buf->new_ea",
            "0"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "&ea_buf->new_ea",
            "0"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "&ea_buf->new_ea",
            "new_size"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "new_size <= sizeof (ji->i_inline_ea)"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_release",
          "args": [
            "inode",
            "ea_buf"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ea_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "591-603",
          "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_put(tid_t tid, struct inode *inode, struct ea_buffer *ea_buf,\n\t\t  int new_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tunsigned long old_blocks, new_blocks;\n\tint rc = 0;\n\n\tif (new_size == 0) {\n\t\tea_release(inode, ea_buf);\n\t\tea_buf = NULL;\n\t} else if (ea_buf->flag & EA_INLINE) {\n\t\tassert(new_size <= sizeof (ji->i_inline_ea));\n\t\tji->mode2 &= ~INLINEEA;\n\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\tDXDsize(&ea_buf->new_ea, new_size);\n\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\tDXDlength(&ea_buf->new_ea, 0);\n\t} else if (ea_buf->flag & EA_MALLOC) {\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tkfree(ea_buf->xattr);\n\t} else if (ea_buf->flag & EA_NEW) {\n\t\t/* We have already allocated a new dxd */\n\t\tflush_metapage(ea_buf->mp);\n\t} else {\n\t\t/* ->xattr must point to original ea's metapage */\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tdiscard_metapage(ea_buf->mp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\told_blocks = new_blocks = 0;\n\n\tif (ji->ea.flag & DXD_EXTENT) {\n\t\tinvalidate_dxd_metapages(inode, ji->ea);\n\t\told_blocks = lengthDXD(&ji->ea);\n\t}\n\n\tif (ea_buf) {\n\t\ttxEA(tid, inode, &ji->ea, &ea_buf->new_ea);\n\t\tif (ea_buf->new_ea.flag & DXD_EXTENT) {\n\t\t\tnew_blocks = lengthDXD(&ea_buf->new_ea);\n\t\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\t\tji->mode2 |= INLINEEA;\n\t\t}\n\t\tji->ea = ea_buf->new_ea;\n\t} else {\n\t\ttxEA(tid, inode, &ji->ea, NULL);\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t\tji->ea.flag = 0;\n\t\tji->ea.size = 0;\n\t}\n\n\t/* If old blocks exist, they must be removed from quota allocation. */\n\tif (old_blocks)\n\t\tdquot_free_block(inode, old_blocks);\n\n\tinode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "591-603",
    "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define EA_MALLOC\t0x0008",
      "#define EA_NEW\t\t0x0004",
      "#define EA_EXTENT\t0x0002"
    ],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "inode",
            "addressDXD(&ea_buf->new_ea)",
            "lengthDXD(&ea_buf->new_ea)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&ea_buf->new_ea"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "&ea_buf->new_ea"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "ea_buf->mp"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ea_buf->mp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea_buf->xattr"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
  },
  {
    "function_name": "ea_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "441-589",
    "snippet": "static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define EA_MALLOC\t0x0008",
      "#define EA_NEW\t\t0x0004",
      "#define EA_EXTENT\t0x0002",
      "#define EA_INLINE\t0x0001"
    ],
    "globals_used": [
      "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "quota_allocation"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_release",
          "args": [
            "inode",
            "ea_buf"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ea_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "591-603",
          "snippet": "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define EA_MALLOC\t0x0008",
            "#define EA_NEW\t\t0x0004",
            "#define EA_EXTENT\t0x0002"
          ],
          "globals_used": [
            "static void ea_release(struct inode *inode, struct ea_buffer *ea_buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"\"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "1",
            "ea_buf->xattr",
            "ea_size",
            "1"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"ea_get: invalid extended attribute\\n\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EALIST_SIZE",
          "args": [
            "ea_buf->xattr"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "inode",
            "addressDXD(&ji->ea)",
            "lengthDXD(&ji->ea) << sb->s_blocksize_bits",
            "1"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "inode",
            "blkno",
            "(s64) blocks_needed"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "ea_buf->mp"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_read",
          "args": [
            "inode",
            "ea_buf->xattr"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "366-422",
          "snippet": "static int ea_read(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tchar *cp = (char *) ealist;\n\tint i;\n\tint nbytes, nb;\n\ts32 bytes_to_read;\n\tstruct metapage *mp;\n\n\t/* quick check for in-line EA */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\treturn ea_read_inline(ip, ealist);\n\n\tnbytes = sizeDXD(&ji->ea);\n\tif (!nbytes) {\n\t\tjfs_error(sb, \"nbytes is 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Figure out how many blocks were allocated when this EA list was\n\t * originally written to disk.\n\t */\n\tnblocks = lengthDXD(&ji->ea) << sbi->l2nbperpage;\n\tblkno = addressDXD(&ji->ea) << sbi->l2nbperpage;\n\n\t/*\n\t * I have found the disk blocks which were originally used to store\n\t * the FEALIST.  now i loop over each contiguous block copying the\n\t * data into the buffer.\n\t */\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_read =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = read_metapage(ip, blkno + i, bytes_to_read, 1)))\n\t\t\treturn -EIO;\n\n\t\tmemcpy(cp, mp->data, nb);\n\t\trelease_metapage(mp);\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_read(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tchar *cp = (char *) ealist;\n\tint i;\n\tint nbytes, nb;\n\ts32 bytes_to_read;\n\tstruct metapage *mp;\n\n\t/* quick check for in-line EA */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\treturn ea_read_inline(ip, ealist);\n\n\tnbytes = sizeDXD(&ji->ea);\n\tif (!nbytes) {\n\t\tjfs_error(sb, \"nbytes is 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Figure out how many blocks were allocated when this EA list was\n\t * originally written to disk.\n\t */\n\tnblocks = lengthDXD(&ji->ea) << sbi->l2nbperpage;\n\tblkno = addressDXD(&ji->ea) << sbi->l2nbperpage;\n\n\t/*\n\t * I have found the disk blocks which were originally used to store\n\t * the FEALIST.  now i loop over each contiguous block copying the\n\t * data into the buffer.\n\t */\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_read =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = read_metapage(ip, blkno + i, bytes_to_read, 1)))\n\t\t\treturn -EIO;\n\n\t\tmemcpy(cp, mp->data, nb);\n\t\trelease_metapage(mp);\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "inode",
            "blkno",
            "blocks_needed << sb->s_blocksize_bits",
            "1"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "&ea_buf->new_ea",
            "min_size"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "&ea_buf->new_ea",
            "blkno"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "&ea_buf->new_ea",
            "blocks_needed"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "inode",
            "INOHINT(inode)",
            "(s64) blocks_needed",
            "&blkno"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOHINT",
          "args": [
            "inode"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "blocks_needed"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea_buf->xattr"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "min_size",
            "ea_size"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"invalid ea.flag\\n\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "&ea_buf->new_ea",
            "min_size"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "&ea_buf->new_ea",
            "0"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "&ea_buf->new_ea",
            "0"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define EA_MALLOC\t0x0008\n#define EA_NEW\t\t0x0004\n#define EA_EXTENT\t0x0002\n#define EA_INLINE\t0x0001\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\nstatic int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t/* When fsck.jfs clears a bad ea, it doesn't clear the size */\n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t/*\n\t\t * To keep the rest of the code simple.  Allocate a\n\t\t * contiguous buffer to work with\n\t\t */\n\t\tea_buf->xattr = kmalloc(size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t/* Allocate new blocks to quota. */\n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t/* Rollback quota allocation */\n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "ea_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "366-422",
    "snippet": "static int ea_read(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tchar *cp = (char *) ealist;\n\tint i;\n\tint nbytes, nb;\n\ts32 bytes_to_read;\n\tstruct metapage *mp;\n\n\t/* quick check for in-line EA */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\treturn ea_read_inline(ip, ealist);\n\n\tnbytes = sizeDXD(&ji->ea);\n\tif (!nbytes) {\n\t\tjfs_error(sb, \"nbytes is 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Figure out how many blocks were allocated when this EA list was\n\t * originally written to disk.\n\t */\n\tnblocks = lengthDXD(&ji->ea) << sbi->l2nbperpage;\n\tblkno = addressDXD(&ji->ea) << sbi->l2nbperpage;\n\n\t/*\n\t * I have found the disk blocks which were originally used to store\n\t * the FEALIST.  now i loop over each contiguous block copying the\n\t * data into the buffer.\n\t */\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_read =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = read_metapage(ip, blkno + i, bytes_to_read, 1)))\n\t\t\treturn -EIO;\n\n\t\tmemcpy(cp, mp->data, nb);\n\t\trelease_metapage(mp);\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp",
            "mp->data",
            "nb"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ip",
            "blkno + i",
            "bytes_to_read",
            "1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "PSIZE",
            "nbytes"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"nbytes is 0\\n\""
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sizeDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_read_inline",
          "args": [
            "ip",
            "ealist"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ea_read_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "332-351",
          "snippet": "static int ea_read_inline(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tint ea_size = sizeDXD(&ji->ea);\n\n\tif (ea_size == 0) {\n\t\tealist->size = 0;\n\t\treturn 0;\n\t}\n\n\t/* Sanity Check */\n\tif ((sizeDXD(&ji->ea) > sizeof (ji->i_inline_ea)))\n\t\treturn -EIO;\n\tif (le32_to_cpu(((struct jfs_ea_list *) &ji->i_inline_ea)->size)\n\t    != ea_size)\n\t\treturn -EIO;\n\n\tmemcpy(ealist, ji->i_inline_ea, ea_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_read_inline(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tint ea_size = sizeDXD(&ji->ea);\n\n\tif (ea_size == 0) {\n\t\tealist->size = 0;\n\t\treturn 0;\n\t}\n\n\t/* Sanity Check */\n\tif ((sizeDXD(&ji->ea) > sizeof (ji->i_inline_ea)))\n\t\treturn -EIO;\n\tif (le32_to_cpu(((struct jfs_ea_list *) &ji->i_inline_ea)->size)\n\t    != ea_size)\n\t\treturn -EIO;\n\n\tmemcpy(ealist, ji->i_inline_ea, ea_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_read(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tchar *cp = (char *) ealist;\n\tint i;\n\tint nbytes, nb;\n\ts32 bytes_to_read;\n\tstruct metapage *mp;\n\n\t/* quick check for in-line EA */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\treturn ea_read_inline(ip, ealist);\n\n\tnbytes = sizeDXD(&ji->ea);\n\tif (!nbytes) {\n\t\tjfs_error(sb, \"nbytes is 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Figure out how many blocks were allocated when this EA list was\n\t * originally written to disk.\n\t */\n\tnblocks = lengthDXD(&ji->ea) << sbi->l2nbperpage;\n\tblkno = addressDXD(&ji->ea) << sbi->l2nbperpage;\n\n\t/*\n\t * I have found the disk blocks which were originally used to store\n\t * the FEALIST.  now i loop over each contiguous block copying the\n\t * data into the buffer.\n\t */\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_read =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = read_metapage(ip, blkno + i, bytes_to_read, 1)))\n\t\t\treturn -EIO;\n\n\t\tmemcpy(cp, mp->data, nb);\n\t\trelease_metapage(mp);\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_read_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "332-351",
    "snippet": "static int ea_read_inline(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tint ea_size = sizeDXD(&ji->ea);\n\n\tif (ea_size == 0) {\n\t\tealist->size = 0;\n\t\treturn 0;\n\t}\n\n\t/* Sanity Check */\n\tif ((sizeDXD(&ji->ea) > sizeof (ji->i_inline_ea)))\n\t\treturn -EIO;\n\tif (le32_to_cpu(((struct jfs_ea_list *) &ji->i_inline_ea)->size)\n\t    != ea_size)\n\t\treturn -EIO;\n\n\tmemcpy(ealist, ji->i_inline_ea, ea_size);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ealist",
            "ji->i_inline_ea",
            "ea_size"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct jfs_ea_list *) &ji->i_inline_ea)->size"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sizeDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeDXD",
          "args": [
            "&ji->ea"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_read_inline(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tint ea_size = sizeDXD(&ji->ea);\n\n\tif (ea_size == 0) {\n\t\tealist->size = 0;\n\t\treturn 0;\n\t}\n\n\t/* Sanity Check */\n\tif ((sizeDXD(&ji->ea) > sizeof (ji->i_inline_ea)))\n\t\treturn -EIO;\n\tif (le32_to_cpu(((struct jfs_ea_list *) &ji->i_inline_ea)->size)\n\t    != ea_size)\n\t\treturn -EIO;\n\n\tmemcpy(ealist, ji->i_inline_ea, ea_size);\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "216-319",
    "snippet": "static int ea_write(struct inode *ip, struct jfs_ea_list *ealist, int size,\n\t\t       dxd_t * ea)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tint rc = 0, i;\n\tchar *cp;\n\ts32 nbytes, nb;\n\ts32 bytes_to_write;\n\tstruct metapage *mp;\n\n\t/*\n\t * Quick check to see if this is an in-linable EA.  Short EAs\n\t * and empty EAs are all in-linable, provided the space exists.\n\t */\n\tif (!ealist || size <= sizeof (ji->i_inline_ea)) {\n\t\tif (!ea_write_inline(ip, ealist, size, ea))\n\t\t\treturn 0;\n\t}\n\n\t/* figure out how many blocks we need */\n\tnblocks = (size + (sb->s_blocksize - 1)) >> sb->s_blocksize_bits;\n\n\t/* Allocate new blocks to quota. */\n\trc = dquot_alloc_block(ip, nblocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);\n\tif (rc) {\n\t\t/*Rollback quota allocation. */\n\t\tdquot_free_block(ip, nblocks);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Now have nblocks worth of storage to stuff into the FEALIST.\n\t * loop over the FEALIST copying data into the buffer one page at\n\t * a time.\n\t */\n\tcp = (char *) ealist;\n\tnbytes = size;\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_write =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = get_metapage(ip, blkno + i, bytes_to_write, 1))) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemcpy(mp->data, cp, nb);\n\n\t\t/*\n\t\t * We really need a way to propagate errors for\n\t\t * forced writes like this one.  --hch\n\t\t *\n\t\t * (__write_metapage => release_metapage => flush_metapage)\n\t\t */\n#ifdef _JFS_FIXME\n\t\tif ((rc = flush_metapage(mp))) {\n\t\t\t/*\n\t\t\t * the write failed -- this means that the buffer\n\t\t\t * is still assigned and the blocks are not being\n\t\t\t * used.  this seems like the best error recovery\n\t\t\t * we can get ...\n\t\t\t */\n\t\t\tgoto failed;\n\t\t}\n#else\n\t\tflush_metapage(mp);\n#endif\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\tea->flag = DXD_EXTENT;\n\tDXDsize(ea, le32_to_cpu(ealist->size));\n\tDXDlength(ea, nblocks);\n\tDXDaddress(ea, blkno);\n\n\t/* Free up INLINE area */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\tji->mode2 |= INLINEEA;\n\n\treturn 0;\n\n      failed:\n\t/* Rollback quota allocation. */\n\tdquot_free_block(ip, nblocks);\n\n\tdbFree(ip, blkno, nblocks);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "blkno",
            "nblocks"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nblocks"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "ea",
            "blkno"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "ea",
            "nblocks"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "ea",
            "le32_to_cpu(ealist->size)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ealist->size"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_metapage",
          "args": [
            "mp"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "flush_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "91-95",
          "snippet": "static inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_sync\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_sync\t3\n\nstatic inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mp->data",
            "cp",
            "nb"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "blkno + i",
            "bytes_to_write",
            "1"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "PSIZE",
            "nbytes"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nblocks"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "INOHINT(ip)",
            "nblocks",
            "&blkno"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOHINT",
          "args": [
            "ip"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "nblocks"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_write_inline",
          "args": [
            "ip",
            "ealist",
            "size",
            "ea"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "158-195",
          "snippet": "static int ea_write_inline(struct inode *ip, struct jfs_ea_list *ealist,\n\t\t\t   int size, dxd_t * ea)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\n\t/*\n\t * Make sure we have an EA -- the NULL EA list is valid, but you\n\t * can't copy it!\n\t */\n\tif (ealist && size > sizeof (struct jfs_ea_list)) {\n\t\tassert(size <= sizeof (ji->i_inline_ea));\n\n\t\t/*\n\t\t * See if the space is available or if it is already being\n\t\t * used for an inline EA.\n\t\t */\n\t\tif (!(ji->mode2 & INLINEEA) && !(ji->ea.flag & DXD_INLINE))\n\t\t\treturn -EPERM;\n\n\t\tDXDsize(ea, size);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\t\tmemcpy(ji->i_inline_ea, ealist, size);\n\t\tea->flag = DXD_INLINE;\n\t\tji->mode2 &= ~INLINEEA;\n\t} else {\n\t\tea->flag = 0;\n\t\tDXDsize(ea, 0);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\n\t\t/* Free up INLINE area */\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_write_inline(struct inode *ip, struct jfs_ea_list *ealist,\n\t\t\t   int size, dxd_t * ea)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\n\t/*\n\t * Make sure we have an EA -- the NULL EA list is valid, but you\n\t * can't copy it!\n\t */\n\tif (ealist && size > sizeof (struct jfs_ea_list)) {\n\t\tassert(size <= sizeof (ji->i_inline_ea));\n\n\t\t/*\n\t\t * See if the space is available or if it is already being\n\t\t * used for an inline EA.\n\t\t */\n\t\tif (!(ji->mode2 & INLINEEA) && !(ji->ea.flag & DXD_INLINE))\n\t\t\treturn -EPERM;\n\n\t\tDXDsize(ea, size);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\t\tmemcpy(ji->i_inline_ea, ealist, size);\n\t\tea->flag = DXD_INLINE;\n\t\tji->mode2 &= ~INLINEEA;\n\t} else {\n\t\tea->flag = 0;\n\t\tDXDsize(ea, 0);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\n\t\t/* Free up INLINE area */\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_write(struct inode *ip, struct jfs_ea_list *ealist, int size,\n\t\t       dxd_t * ea)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tint rc = 0, i;\n\tchar *cp;\n\ts32 nbytes, nb;\n\ts32 bytes_to_write;\n\tstruct metapage *mp;\n\n\t/*\n\t * Quick check to see if this is an in-linable EA.  Short EAs\n\t * and empty EAs are all in-linable, provided the space exists.\n\t */\n\tif (!ealist || size <= sizeof (ji->i_inline_ea)) {\n\t\tif (!ea_write_inline(ip, ealist, size, ea))\n\t\t\treturn 0;\n\t}\n\n\t/* figure out how many blocks we need */\n\tnblocks = (size + (sb->s_blocksize - 1)) >> sb->s_blocksize_bits;\n\n\t/* Allocate new blocks to quota. */\n\trc = dquot_alloc_block(ip, nblocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);\n\tif (rc) {\n\t\t/*Rollback quota allocation. */\n\t\tdquot_free_block(ip, nblocks);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Now have nblocks worth of storage to stuff into the FEALIST.\n\t * loop over the FEALIST copying data into the buffer one page at\n\t * a time.\n\t */\n\tcp = (char *) ealist;\n\tnbytes = size;\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t/*\n\t\t * Determine how many bytes for this request, and round up to\n\t\t * the nearest aggregate block size\n\t\t */\n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_write =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = get_metapage(ip, blkno + i, bytes_to_write, 1))) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemcpy(mp->data, cp, nb);\n\n\t\t/*\n\t\t * We really need a way to propagate errors for\n\t\t * forced writes like this one.  --hch\n\t\t *\n\t\t * (__write_metapage => release_metapage => flush_metapage)\n\t\t */\n#ifdef _JFS_FIXME\n\t\tif ((rc = flush_metapage(mp))) {\n\t\t\t/*\n\t\t\t * the write failed -- this means that the buffer\n\t\t\t * is still assigned and the blocks are not being\n\t\t\t * used.  this seems like the best error recovery\n\t\t\t * we can get ...\n\t\t\t */\n\t\t\tgoto failed;\n\t\t}\n#else\n\t\tflush_metapage(mp);\n#endif\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\tea->flag = DXD_EXTENT;\n\tDXDsize(ea, le32_to_cpu(ealist->size));\n\tDXDlength(ea, nblocks);\n\tDXDaddress(ea, blkno);\n\n\t/* Free up INLINE area */\n\tif (ji->ea.flag & DXD_INLINE)\n\t\tji->mode2 |= INLINEEA;\n\n\treturn 0;\n\n      failed:\n\t/* Rollback quota allocation. */\n\tdquot_free_block(ip, nblocks);\n\n\tdbFree(ip, blkno, nblocks);\n\treturn rc;\n}"
  },
  {
    "function_name": "ea_write_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "158-195",
    "snippet": "static int ea_write_inline(struct inode *ip, struct jfs_ea_list *ealist,\n\t\t\t   int size, dxd_t * ea)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\n\t/*\n\t * Make sure we have an EA -- the NULL EA list is valid, but you\n\t * can't copy it!\n\t */\n\tif (ealist && size > sizeof (struct jfs_ea_list)) {\n\t\tassert(size <= sizeof (ji->i_inline_ea));\n\n\t\t/*\n\t\t * See if the space is available or if it is already being\n\t\t * used for an inline EA.\n\t\t */\n\t\tif (!(ji->mode2 & INLINEEA) && !(ji->ea.flag & DXD_INLINE))\n\t\t\treturn -EPERM;\n\n\t\tDXDsize(ea, size);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\t\tmemcpy(ji->i_inline_ea, ealist, size);\n\t\tea->flag = DXD_INLINE;\n\t\tji->mode2 &= ~INLINEEA;\n\t} else {\n\t\tea->flag = 0;\n\t\tDXDsize(ea, 0);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\n\t\t/* Free up INLINE area */\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "ea",
            "0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "ea",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "ea",
            "0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ji->i_inline_ea",
            "ealist",
            "size"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDaddress",
          "args": [
            "ea",
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDlength",
          "args": [
            "ea",
            "0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DXDsize",
          "args": [
            "ea",
            "size"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "size <= sizeof (ji->i_inline_ea)"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ea_write_inline(struct inode *ip, struct jfs_ea_list *ealist,\n\t\t\t   int size, dxd_t * ea)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\n\t/*\n\t * Make sure we have an EA -- the NULL EA list is valid, but you\n\t * can't copy it!\n\t */\n\tif (ealist && size > sizeof (struct jfs_ea_list)) {\n\t\tassert(size <= sizeof (ji->i_inline_ea));\n\n\t\t/*\n\t\t * See if the space is available or if it is already being\n\t\t * used for an inline EA.\n\t\t */\n\t\tif (!(ji->mode2 & INLINEEA) && !(ji->ea.flag & DXD_INLINE))\n\t\t\treturn -EPERM;\n\n\t\tDXDsize(ea, size);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\t\tmemcpy(ji->i_inline_ea, ealist, size);\n\t\tea->flag = DXD_INLINE;\n\t\tji->mode2 &= ~INLINEEA;\n\t} else {\n\t\tea->flag = 0;\n\t\tDXDsize(ea, 0);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\n\t\t/* Free up INLINE area */\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "118-131",
    "snippet": "static inline int copy_name(char *buffer, struct jfs_ea *ea)\n{\n\tint len = ea->namelen;\n\n\tif (is_os2_xattr(ea)) {\n\t\tmemcpy(buffer, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN);\n\t\tbuffer += XATTR_OS2_PREFIX_LEN;\n\t\tlen += XATTR_OS2_PREFIX_LEN;\n\t}\n\tmemcpy(buffer, ea->name, ea->namelen);\n\tbuffer[ea->namelen] = 0;\n\n\treturn len;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "ea->name",
            "ea->namelen"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "XATTR_OS2_PREFIX",
            "XATTR_OS2_PREFIX_LEN"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_os2_xattr",
          "args": [
            "ea"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "is_os2_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "105-108",
          "snippet": "static int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int copy_name(char *buffer, struct jfs_ea *ea)\n{\n\tint len = ea->namelen;\n\n\tif (is_os2_xattr(ea)) {\n\t\tmemcpy(buffer, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN);\n\t\tbuffer += XATTR_OS2_PREFIX_LEN;\n\t\tlen += XATTR_OS2_PREFIX_LEN;\n\t}\n\tmemcpy(buffer, ea->name, ea->namelen);\n\tbuffer[ea->namelen] = 0;\n\n\treturn len;\n}"
  },
  {
    "function_name": "name_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "110-116",
    "snippet": "static inline int name_size(struct jfs_ea *ea)\n{\n\tif (is_os2_xattr(ea))\n\t\treturn ea->namelen + XATTR_OS2_PREFIX_LEN;\n\telse\n\t\treturn ea->namelen;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_os2_xattr",
          "args": [
            "ea"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "is_os2_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "105-108",
          "snippet": "static int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline int name_size(struct jfs_ea *ea)\n{\n\tif (is_os2_xattr(ea))\n\t\treturn ea->namelen + XATTR_OS2_PREFIX_LEN;\n\telse\n\t\treturn ea->namelen;\n}"
  },
  {
    "function_name": "is_os2_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "105-108",
    "snippet": "static int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "ea->name"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
          "lines": "89-98",
          "snippet": "static int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_os2_xattr(struct jfs_ea *ea)\n{\n\treturn !is_known_namespace(ea->name);\n}"
  },
  {
    "function_name": "is_known_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/xattr.c",
    "lines": "89-98",
    "snippet": "static int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
  }
]