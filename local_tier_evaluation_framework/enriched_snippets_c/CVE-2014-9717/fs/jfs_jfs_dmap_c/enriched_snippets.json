[
  {
    "function_name": "dbMapFileSizeToMapSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "4052-4092",
    "snippet": "s64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)",
      "#define MAXL0PAGES\t(1 + LPERCTL)"
    ],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAPPGTOLEV",
          "args": [
            "npages"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)\n#define MAXL0PAGES\t(1 + LPERCTL)\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}"
  },
  {
    "function_name": "dbGetL2AGSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "4004-4026",
    "snippet": "static int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}"
  },
  {
    "function_name": "dbInitDmapCtl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3970-3991",
    "snippet": "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbMaxBud(u8 * cp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbInitTree",
          "args": [
            "(struct dmaptree *) dcp"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "dbInitTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3895-3962",
          "snippet": "static int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbMaxBud(u8 * cp);",
            "static int cntlz(u32 value);",
            "static int dbInitTree(struct dmaptree * dtp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cntlz(u32 value);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "5"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CTLLEAFIND"
          ],
          "line": 3976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "L2LPERCTL"
          ],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LPERCTL"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}"
  },
  {
    "function_name": "dbInitTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3895-3962",
    "snippet": "static int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbMaxBud(u8 * cp);",
      "static int cntlz(u32 value);",
      "static int dbInitTree(struct dmaptree * dtp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TREEMAX",
          "args": [
            "cp"
          ],
          "line": 3958
        },
        "resolved": true,
        "details": {
          "function_name": "TREEMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.h",
          "lines": "64-72",
          "snippet": "static inline signed char TREEMAX(signed char *cp)\n{\n\tsigned char tmp1, tmp2;\n\n\ttmp1 = max(*(cp+2), *(cp+3));\n\ttmp2 = max(*(cp), *(cp+1));\n\n\treturn max(tmp1, tmp2);\n}",
          "includes": [
            "#include \"jfs_txnmgr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_txnmgr.h\"\n\nstatic inline signed char TREEMAX(signed char *cp)\n{\n\tsigned char tmp1, tmp2;\n\n\ttmp1 = max(*(cp+2), *(cp+3));\n\ttmp2 = max(*(cp), *(cp+1));\n\n\treturn max(tmp1, tmp2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dtp->nleafs"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cntlz(u32 value);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}"
  },
  {
    "function_name": "dbInitDmapTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3849-3873",
    "snippet": "static int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbMaxBud(u8 * cp);",
      "static int cnttz(u32 word);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbInitTree",
          "args": [
            "tp"
          ],
          "line": 3872
        },
        "resolved": true,
        "details": {
          "function_name": "dbInitTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3895-3962",
          "snippet": "static int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbMaxBud(u8 * cp);",
            "static int cntlz(u32 value);",
            "static int dbInitTree(struct dmaptree * dtp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cntlz(u32 value);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbMaxBud",
          "args": [
            "(u8 *) & dp->wmap[i]"
          ],
          "line": 3869
        },
        "resolved": true,
        "details": {
          "function_name": "dbMaxBud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3073-3095",
          "snippet": "static int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbMaxBud(u8 * cp);",
            "static int cnttz(u32 word);",
            "static const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->leafidx"
          ],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "4"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LEAFIND"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "L2LPERDMAP"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LPERDMAP"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}"
  },
  {
    "function_name": "dbInitDmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3747-3832",
    "snippet": "static int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\n{\n\tint blkno, w, b, r, nw, nb, i;\n\n\t/* starting block number within the dmap */\n\tblkno = Blkno & (BPERDMAP - 1);\n\n\tif (blkno == 0) {\n\t\tdp->nblocks = dp->nfree = cpu_to_le32(nblocks);\n\t\tdp->start = cpu_to_le64(Blkno);\n\n\t\tif (nblocks == BPERDMAP) {\n\t\t\tmemset(&dp->wmap[0], 0, LPERDMAP * 4);\n\t\t\tmemset(&dp->pmap[0], 0, LPERDMAP * 4);\n\t\t\tgoto initTree;\n\t\t}\n\t} else {\n\t\tle32_add_cpu(&dp->nblocks, nblocks);\n\t\tle32_add_cpu(&dp->nfree, nblocks);\n\t}\n\n\t/* word number containing start block number */\n\tw = blkno >> L2DBWORD;\n\n\t/*\n\t * free the bits corresponding to the block range (ZEROS):\n\t * note: not all bits of the first and last words may be contained\n\t * within the block range.\n\t */\n\tfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\n\t\t/* number of bits preceding range to be freed in the word */\n\t\tb = blkno & (DBWORD - 1);\n\t\t/* number of bits to free in the word */\n\t\tnb = min(r, DBWORD - b);\n\n\t\t/* is partial word to be freed ? */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (set to 0) from the bitmap word */\n\t\t\tdp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\t\t\tdp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\n\t\t\t/* skip the word freed */\n\t\t\tw++;\n\t\t} else {\n\t\t\t/* free (set to 0) contiguous bitmap words */\n\t\t\tnw = r >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[w], 0, nw * 4);\n\t\t\tmemset(&dp->pmap[w], 0, nw * 4);\n\n\t\t\t/* skip the words freed */\n\t\t\tnb = nw << L2DBWORD;\n\t\t\tw += nw;\n\t\t}\n\t}\n\n\t/*\n\t * mark bits following the range to be freed (non-existing\n\t * blocks) as allocated (ONES)\n\t */\n\n\tif (blkno == BPERDMAP)\n\t\tgoto initTree;\n\n\t/* the first word beyond the end of existing blocks */\n\tw = blkno >> L2DBWORD;\n\n\t/* does nblocks fall on a 32-bit boundary ? */\n\tb = blkno & (DBWORD - 1);\n\tif (b) {\n\t\t/* mark a partial word allocated */\n\t\tdp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\n\t\tw++;\n\t}\n\n\t/* set the rest of the words in the page to allocated (ONES) */\n\tfor (i = w; i < LPERDMAP; i++)\n\t\tdp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\n\n\t/*\n\t * init tree\n\t */\n      initTree:\n\treturn (dbInitDmapTree(dp));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbInitDmapTree",
          "args": [
            "dp"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "dbInitDmapTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3849-3873",
          "snippet": "static int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbMaxBud(u8 * cp);",
            "static int cnttz(u32 word);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES >> b"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->pmap[w]",
            "0",
            "nw * 4"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->wmap[w]",
            "0",
            "nw * 4"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b)"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b)"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "r",
            "DBWORD - b"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dp->nfree",
            "nblocks"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dp->nblocks",
            "nblocks"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->pmap[0]",
            "0",
            "LPERDMAP * 4"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->wmap[0]",
            "0",
            "LPERDMAP * 4"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "Blkno"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nblocks"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\n{\n\tint blkno, w, b, r, nw, nb, i;\n\n\t/* starting block number within the dmap */\n\tblkno = Blkno & (BPERDMAP - 1);\n\n\tif (blkno == 0) {\n\t\tdp->nblocks = dp->nfree = cpu_to_le32(nblocks);\n\t\tdp->start = cpu_to_le64(Blkno);\n\n\t\tif (nblocks == BPERDMAP) {\n\t\t\tmemset(&dp->wmap[0], 0, LPERDMAP * 4);\n\t\t\tmemset(&dp->pmap[0], 0, LPERDMAP * 4);\n\t\t\tgoto initTree;\n\t\t}\n\t} else {\n\t\tle32_add_cpu(&dp->nblocks, nblocks);\n\t\tle32_add_cpu(&dp->nfree, nblocks);\n\t}\n\n\t/* word number containing start block number */\n\tw = blkno >> L2DBWORD;\n\n\t/*\n\t * free the bits corresponding to the block range (ZEROS):\n\t * note: not all bits of the first and last words may be contained\n\t * within the block range.\n\t */\n\tfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\n\t\t/* number of bits preceding range to be freed in the word */\n\t\tb = blkno & (DBWORD - 1);\n\t\t/* number of bits to free in the word */\n\t\tnb = min(r, DBWORD - b);\n\n\t\t/* is partial word to be freed ? */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (set to 0) from the bitmap word */\n\t\t\tdp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\t\t\tdp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\n\t\t\t/* skip the word freed */\n\t\t\tw++;\n\t\t} else {\n\t\t\t/* free (set to 0) contiguous bitmap words */\n\t\t\tnw = r >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[w], 0, nw * 4);\n\t\t\tmemset(&dp->pmap[w], 0, nw * 4);\n\n\t\t\t/* skip the words freed */\n\t\t\tnb = nw << L2DBWORD;\n\t\t\tw += nw;\n\t\t}\n\t}\n\n\t/*\n\t * mark bits following the range to be freed (non-existing\n\t * blocks) as allocated (ONES)\n\t */\n\n\tif (blkno == BPERDMAP)\n\t\tgoto initTree;\n\n\t/* the first word beyond the end of existing blocks */\n\tw = blkno >> L2DBWORD;\n\n\t/* does nblocks fall on a 32-bit boundary ? */\n\tb = blkno & (DBWORD - 1);\n\tif (b) {\n\t\t/* mark a partial word allocated */\n\t\tdp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\n\t\tw++;\n\t}\n\n\t/* set the rest of the words in the page to allocated (ONES) */\n\tfor (i = w; i < LPERDMAP; i++)\n\t\tdp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\n\n\t/*\n\t * init tree\n\t */\n      initTree:\n\treturn (dbInitDmapTree(dp));\n}"
  },
  {
    "function_name": "dbFinalizeBmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3656-3727",
    "snippet": "void dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inacitve ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAPSZTOLEV",
          "args": [
            "bmp->db_agsize"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ipbmap->i_sb",
            "\"cannot find ag with average freespace\\n\""
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nvoid dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inacitve ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}"
  },
  {
    "function_name": "dbExtendFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3384-3650",
    "snippet": "int dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "l2mp"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ipbmap->i_sb",
            "\"function has not returned as expected\\n\""
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "l1mp"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbInitDmapCtl",
          "args": [
            "l1dcp",
            "1",
            "++j"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "dbInitDmapCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3970-3991",
          "snippet": "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbMaxBud(u8 * cp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dp->start"
          ],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "s64",
            "nblocks",
            "BPERDMAP"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nblocks",
            "(s64)BPERDMAP - n"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "sbi->l2nbperpage"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOL0",
          "args": [
            "blkno",
            "sbi->l2nbperpage"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOL1",
          "args": [
            "blkno",
            "sbi->l2nbperpage"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "p",
            "PSIZE",
            "0"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbGetL2AGSize",
          "args": [
            "newsize"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "dbGetL2AGSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "4004-4026",
          "snippet": "static int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BMAPSZTOLEV",
          "args": [
            "bmp->db_mapsize"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\"",
            "(long long) blkno",
            "(long long) nblocks",
            "(long long) newsize"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbAllocDmapBU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3263-3364",
    "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbFreeBits",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "dbFreeBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2324-2463",
          "snippet": "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAdjCtl",
          "args": [
            "bmp",
            "blkno",
            "tp->stree[ROOT]",
            "1",
            "0"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2507-2639",
          "snippet": "static int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int cntlz(u32 value);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int cntlz(u32 value);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BMAP_UNLOCK",
          "args": [
            "bmp"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BMAP_LOCK",
          "args": [
            "bmp"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbInitDmapTree",
          "args": [
            "dp"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "dbInitDmapTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3849-3873",
          "snippet": "static int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbMaxBud(u8 * cp);",
            "static int cnttz(u32 word);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dp->nfree",
            "-nblocks"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->wmap[word]",
            "(int) ONES",
            "nwords * 4"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rembits",
            "DBWORD - wbitno"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dbitno + nblocks <= BPERDMAP"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAllocBottomUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3208-3260",
    "snippet": "int dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 3248
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAllocDmapBU",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nb"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rem",
            "BPERDMAP - (blkno & (BPERDMAP - 1))"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nblocks <= bmp->db_mapsize - blkno"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "blkstol2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3160-3187",
    "snippet": "static int blkstol2(s64 nb)\n{\n\tint l2nb;\n\ts64 mask;\t\t/* meant to be signed */\n\n\tmask = (s64) 1 << (64 - 1);\n\n\t/* count the leading bits.\n\t */\n\tfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\n\t\t/* leading bit found.\n\t\t */\n\t\tif (nb & mask) {\n\t\t\t/* determine the l2 value.\n\t\t\t */\n\t\t\tl2nb = (64 - 1) - l2nb;\n\n\t\t\t/* check if we need to round up.\n\t\t\t */\n\t\t\tif (~mask & nb)\n\t\t\t\tl2nb++;\n\n\t\t\treturn (l2nb);\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\t\t/* fix compiler warning */\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbFindBits(u32 word, int l2nb);",
      "static int blkstol2(s64 nb);",
      "static int cntlz(u32 value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\n\nstatic int blkstol2(s64 nb)\n{\n\tint l2nb;\n\ts64 mask;\t\t/* meant to be signed */\n\n\tmask = (s64) 1 << (64 - 1);\n\n\t/* count the leading bits.\n\t */\n\tfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\n\t\t/* leading bit found.\n\t\t */\n\t\tif (nb & mask) {\n\t\t\t/* determine the l2 value.\n\t\t\t */\n\t\t\tl2nb = (64 - 1) - l2nb;\n\n\t\t\t/* check if we need to round up.\n\t\t\t */\n\t\t\tif (~mask & nb)\n\t\t\t\tl2nb++;\n\n\t\t\treturn (l2nb);\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\t\t/* fix compiler warning */\n}"
  },
  {
    "function_name": "cntlz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3135-3144",
    "snippet": "static int cntlz(u32 value)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, value <<= 1) {\n\t\tif (value & HIGHORDER)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cntlz(u32 value);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int cntlz(u32 value);\n\nstatic int cntlz(u32 value)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, value <<= 1) {\n\t\tif (value & HIGHORDER)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}"
  },
  {
    "function_name": "cnttz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3110-3120",
    "snippet": "static int cnttz(u32 word)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, word >>= 1) {\n\t\tif (word & 0x01)\n\t\t\tbreak;\n\t}\n\n\treturn (n);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cnttz(u32 word);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int cnttz(u32 word);\n\nstatic int cnttz(u32 word)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, word >>= 1) {\n\t\tif (word & 0x01)\n\t\t\tbreak;\n\t}\n\n\treturn (n);\n}"
  },
  {
    "function_name": "dbMaxBud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3073-3095",
    "snippet": "static int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbMaxBud(u8 * cp);",
      "static int cnttz(u32 word);",
      "static const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "tmp1",
            "tmp2"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}"
  },
  {
    "function_name": "dbFindBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "3030-3058",
    "snippet": "static int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbFindBits(u32 word, int l2nb);",
      "static int blkstol2(s64 nb);",
      "static int cnttz(u32 word);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bitno < 32"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nb <= DBWORD"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}"
  },
  {
    "function_name": "dbFindLeaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2972-3011",
    "snippet": "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->dmt_leafidx"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n < 4"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbAdjTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2898-2947",
    "snippet": "static void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
      "static int dbBackSplit(dmtree_t * tp, int leafno);",
      "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
      "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
      "static int cntlz(u32 value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TREEMAX",
          "args": [
            "&tp->dmt_stree[lp]"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "TREEMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.h",
          "lines": "64-72",
          "snippet": "static inline signed char TREEMAX(signed char *cp)\n{\n\tsigned char tmp1, tmp2;\n\n\ttmp1 = max(*(cp+2), *(cp+3));\n\ttmp2 = max(*(cp), *(cp+1));\n\n\treturn max(tmp1, tmp2);\n}",
          "includes": [
            "#include \"jfs_txnmgr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_txnmgr.h\"\n\nstatic inline signed char TREEMAX(signed char *cp)\n{\n\tsigned char tmp1, tmp2;\n\n\ttmp1 = max(*(cp+2), *(cp+3));\n\ttmp2 = max(*(cp), *(cp+1));\n\n\treturn max(tmp1, tmp2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->dmt_height"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}"
  },
  {
    "function_name": "dbJoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2804-2880",
    "snippet": "static int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
      "static int dbBackSplit(dmtree_t * tp, int leafno);",
      "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
      "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int cntlz(u32 value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAdjTree",
          "args": [
            "tp",
            "leafno",
            "newval"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2898-2947",
          "snippet": "static void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->dmt_nleafs"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "newval",
            "tp->dmt_budmin"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int cntlz(u32 value);\n\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbBackSplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2725-2787",
    "snippet": "static int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbBackSplit(dmtree_t * tp, int leafno);",
      "static int cntlz(u32 value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"JFS: wrong leaf value in dbBackSplit\""
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbSplit",
          "args": [
            "tp",
            "bud",
            "cursz",
            "cursz"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "dbSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2660-2695",
          "snippet": "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"JFS: block map error in dbBackSplit\""
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->dmt_nleafs"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "size",
            "tp->dmt_budmin"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LITOL2BSZ",
          "args": [
            "leafno",
            "le32_to_cpu(tp->dmt_l2nleafs)",
            "tp->dmt_budmin"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "leaf[leafno] == NOFREE"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int cntlz(u32 value);\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dbSplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2660-2695",
    "snippet": "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
      "static int dbBackSplit(dmtree_t * tp, int leafno);",
      "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
      "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
      "static int cntlz(u32 value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAdjTree",
          "args": [
            "tp",
            "leafno",
            "newval"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2898-2947",
          "snippet": "static void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "cursz",
            "tp->dmt_budmin"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tp->dmt_leafidx"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}"
  },
  {
    "function_name": "dbAdjCtl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2507-2639",
    "snippet": "static int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
      "static int dbBackSplit(dmtree_t * tp, int leafno);",
      "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
      "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int cntlz(u32 value);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"the maximum free buddy is not the old root\\n\""
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level == bmp->db_maxlevel"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbSplit",
          "args": [
            "(dmtree_t *) dcp",
            "leafno",
            "dcp->budmin",
            "oldval"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "dbSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2660-2695",
          "snippet": "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbBackSplit",
          "args": [
            "(dmtree_t *)\n\t\t\t\t\t\t\t    dcp",
            "leafno"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "dbBackSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2725-2787",
          "snippet": "static int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int cntlz(u32 value);\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbJoin",
          "args": [
            "(dmtree_t *) dcp",
            "leafno",
            "oldval"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "dbJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2804-2880",
          "snippet": "static int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int cntlz(u32 value);\n\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAdjCtl",
          "args": [
            "bmp",
            "blkno",
            "dcp->stree[ROOT]",
            "alloc",
            "level + 1"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2507-2639",
          "snippet": "static int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dcp->leafidx"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKTOCTLLEAF",
          "args": [
            "blkno",
            "dcp->budmin"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CTLLEAFIND"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOCTL",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage",
            "level"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int cntlz(u32 value);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbFreeBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2324-2463",
    "snippet": "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAP_UNLOCK",
          "args": [
            "bmp"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BMAP_LOCK",
          "args": [
            "bmp"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dp->nfree",
            "nblocks"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "size",
            "BUDMIN"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbJoin",
          "args": [
            "tp",
            "word",
            "size"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "dbJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2804-2880",
          "snippet": "static int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int cntlz(u32 value);\n\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN)",
            "NLSTOL2BSZ(nwords)"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLSTOL2BSZ",
          "args": [
            "nwords"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LITOL2BSZ",
          "args": [
            "word",
            "L2LPERDMAP",
            "BUDMIN"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->wmap[word]",
            "0",
            "nwords * 4"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbMaxBud",
          "args": [
            "(u8 *) & dp->wmap[word]"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "dbMaxBud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3073-3095",
          "snippet": "static int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbMaxBud(u8 * cp);",
            "static int cnttz(u32 word);",
            "static const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dbitno + nblocks <= BPERDMAP"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbAllocBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2177-2299",
    "snippet": "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAP_UNLOCK",
          "args": [
            "bmp"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BMAP_LOCK",
          "args": [
            "bmp"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dp->nfree",
            "-nblocks"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "size",
            "BUDMIN"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbSplit",
          "args": [
            "tp",
            "word",
            "size",
            "NOFREE"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "dbSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2660-2695",
          "snippet": "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int cntlz(u32 value);\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "leaf[word]",
            "NLSTOL2BSZ(nwords)"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLSTOL2BSZ",
          "args": [
            "nwords"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"leaf page corrupt\\n\""
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->wmap[word]",
            "(int) ONES",
            "nwords * 4"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbMaxBud",
          "args": [
            "(u8 *) & dp->wmap[word]"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "dbMaxBud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3073-3095",
          "snippet": "static int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbMaxBud(u8 * cp);",
            "static int cnttz(u32 word);",
            "static const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbMaxBud(u8 * cp);\nstatic int cnttz(u32 word);\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rembits",
            "DBWORD - wbitno"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dbitno + nblocks <= BPERDMAP"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}"
  },
  {
    "function_name": "dbFreeDmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2115-2152",
    "snippet": "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAllocBits",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2177-2299",
          "snippet": "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbBackSplit",
          "args": [
            "(dmtree_t *) & dp->tree",
            "word"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "dbBackSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2725-2787",
          "snippet": "static int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int cntlz(u32 value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int cntlz(u32 value);\n\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAdjCtl",
          "args": [
            "bmp",
            "blkno",
            "dp->tree.stree[ROOT]",
            "0",
            "0"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2507-2639",
          "snippet": "static int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int cntlz(u32 value);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int cntlz(u32 value);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFreeBits",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "dbFreeBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2324-2463",
          "snippet": "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAllocDmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "2060-2086",
    "snippet": "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\ts8 oldroot;\n\tint rc;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* allocate the specified (blocks) bits */\n\tdbAllocBits(bmp, dp, blkno, nblocks);\n\n\t/* if the root has not changed, done. */\n\tif (dp->tree.stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int cntlz(u32 value);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbFreeBits",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "dbFreeBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2324-2463",
          "snippet": "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAdjCtl",
          "args": [
            "bmp",
            "blkno",
            "dp->tree.stree[ROOT]",
            "1",
            "0"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "dbAdjCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2507-2639",
          "snippet": "static int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);",
            "static int dbBackSplit(dmtree_t * tp, int leafno);",
            "static int dbJoin(dmtree_t * tp, int leafno, int newval);",
            "static void dbAdjTree(dmtree_t * tp, int leafno, int newval);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int cntlz(u32 value);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int cntlz(u32 value);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAllocBits",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2177-2299",
          "snippet": "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\ts8 oldroot;\n\tint rc;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* allocate the specified (blocks) bits */\n\tdbAllocBits(bmp, dp, blkno, nblocks);\n\n\t/* if the root has not changed, done. */\n\tif (dp->tree.stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAllocDmapLev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1996-2030",
    "snippet": "static int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAllocDmap",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindBits",
          "args": [
            "le32_to_cpu(dp->wmap[leafidx])",
            "l2nb"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3030-3058",
          "snippet": "static int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbFindBits(u32 word, int l2nb);",
            "static int blkstol2(s64 nb);",
            "static int cnttz(u32 word);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dp->wmap[leafidx]"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dp->start"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindLeaf",
          "args": [
            "(dmtree_t *) & dp->tree",
            "l2nb",
            "&leafidx"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2972-3011",
          "snippet": "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "l2nb <= L2BPERDMAP"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAllocCtl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1845-1967",
    "snippet": "static int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"Block Leakage\\n\""
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFreeDmap",
          "args": [
            "bmp",
            "dp",
            "b",
            "BPERDMAP"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "dbFreeDmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2115-2152",
          "snippet": "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "b",
            "bmp->db_l2nbperpage"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocDmap",
          "args": [
            "bmp",
            "dp",
            "b",
            "nb"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "s64",
            "n",
            "BPERDMAP"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "b",
            "bmp->db_l2nbperpage"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(blkno & (BPERDMAP - 1)) == 0"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocDmapLev",
          "args": [
            "bmp",
            "dp",
            "(int) nblocks",
            "l2nb",
            "results"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapLev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1996-2030",
          "snippet": "static int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbFindCtl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1727-1797",
    "snippet": "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"dmap inconsistent\\n\""
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindLeaf",
          "args": [
            "(dmtree_t *) dcp",
            "l2nb",
            "&leafidx"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2972-3011",
          "snippet": "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\n\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CTLLEAFIND"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOCTL",
          "args": [
            "b",
            "bmp->db_l2nbperpage",
            "lev"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}"
  },
  {
    "function_name": "dbDiscardAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1619-1697",
    "snippet": "s64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc(sizeof(struct range2trim) * range_cnt, GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1 << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "totrim"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "tt->blkno",
            "tt->nblocks"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_issue_discard",
          "args": [
            "ip",
            "tt->blkno",
            "tt->nblocks"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_discard.c",
          "lines": "45-64",
          "snippet": "void jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_discard.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "count >= range_cnt - 1"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"-EIO\\n\""
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKSTOL2",
          "args": [
            "nblocks"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocAG",
          "args": [
            "bmp",
            "agno",
            "nblocks",
            "l2nb",
            "&blkno"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1365-1535",
          "snippet": "static int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKSTOL2",
          "args": [
            "nblocks"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct range2trim) * range_cnt",
            "GFP_NOFS"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "max_ranges + 1",
            "32 * 1024"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "max_ranges",
            "minlen"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc(sizeof(struct range2trim) * range_cnt, GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1 << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}"
  },
  {
    "function_name": "dbAllocAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1564-1586",
    "snippet": "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"unable to allocate blocks\\n\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAllocCtl",
          "args": [
            "bmp",
            "nblocks",
            "l2nb",
            "blkno",
            "results"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1845-1967",
          "snippet": "static int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindCtl",
          "args": [
            "bmp",
            "l2nb",
            "bmp->db_maxlevel",
            "&blkno"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1727-1797",
          "snippet": "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAllocAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1365-1535",
    "snippet": "static int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"unable to allocate blocks\\n\""
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAllocCtl",
          "args": [
            "bmp",
            "nblocks",
            "l2nb",
            "blkno",
            "results"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1845-1967",
          "snippet": "static int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindCtl",
          "args": [
            "bmp",
            "l2nb",
            "bmp->db_aglevel - 1",
            "&blkno"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindCtl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1727-1797",
          "snippet": "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ti - le32_to_cpu(dcp->leafidx)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dcp->leafidx"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CTLLEAFIND"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOCTL",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage",
            "bmp->db_aglevel"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\"",
            "(unsigned long long) blkno",
            "(unsigned long long) nblocks"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "dbAllocNear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1256-1308",
    "snippet": "static int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int cntlz(u32 value);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAllocDmap",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFindBits",
          "args": [
            "le32_to_cpu(dp->wmap[word])",
            "l2nb"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "dbFindBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3030-3058",
          "snippet": "static int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbFindBits(u32 word, int l2nb);",
            "static int blkstol2(s64 nb);",
            "static int cnttz(u32 word);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dp->wmap[word]"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dp->start"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "word + 4",
            "LPERDMAP"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"Corrupt dmap page\\n\""
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LEAFIND"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "dbAllocNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1125-1226",
    "snippet": "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAllocDmap",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUDSIZE",
          "args": [
            "l2size",
            "BUDMIN"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "leaf[word]",
            "NLSTOL2BSZ(nwords)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLSTOL2BSZ",
          "args": [
            "nwords"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dp->wmap[word]"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rembits",
            "DBWORD - wbitno"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "bmp->db_ipbmap->i_sb",
            "\"Corrupt dmap page\\n\""
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LEAFIND"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}"
  },
  {
    "function_name": "dbExtend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "1026-1103",
    "snippet": "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocNext",
          "args": [
            "bmp",
            "dp",
            "extblkno",
            "(int) addnblocks"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1125-1226",
          "snippet": "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "extblkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"the block is outside the filesystem\\n\""
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbReAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "977-1000",
    "snippet": "int\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "blkno + nblocks - 1",
            "addnblocks + nblocks",
            "results"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbExtend",
          "args": [
            "ip",
            "blkno",
            "nblocks",
            "addnblocks"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "dbExtend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1026-1103",
          "snippet": "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}"
  },
  {
    "function_name": "dbAllocExact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "893-942",
    "snippet": "int dbAllocExact(struct inode *ip, s64 blkno, int nblocks)\n{\n\tint rc;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct dmap *dp;\n\ts64 lblkno;\n\tstruct metapage *mp;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/*\n\t * validate extent request:\n\t *\n\t * note: defragfs policy:\n\t *  max 64 blocks will be moved.\n\t *  allocation request size must be satisfied from a single dmap.\n\t */\n\tif (nblocks <= 0 || nblocks > BPERDMAP || blkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nblocks > ((s64) 1 << bmp->db_maxfreebud)) {\n\t\t/* the free space is no longer available */\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* read in the dmap covering the extent */\n\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the requested extent */\n\trc = dbAllocNext(bmp, dp, blkno, nblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\tif (rc == 0)\n\t\tmark_metapage_dirty(mp);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocNext",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nblocks"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1125-1226",
          "snippet": "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbAllocExact(struct inode *ip, s64 blkno, int nblocks)\n{\n\tint rc;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct dmap *dp;\n\ts64 lblkno;\n\tstruct metapage *mp;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/*\n\t * validate extent request:\n\t *\n\t * note: defragfs policy:\n\t *  max 64 blocks will be moved.\n\t *  allocation request size must be satisfied from a single dmap.\n\t */\n\tif (nblocks <= 0 || nblocks > BPERDMAP || blkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nblocks > ((s64) 1 << bmp->db_maxfreebud)) {\n\t\t/* the free space is no longer available */\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* read in the dmap covering the extent */\n\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the requested extent */\n\trc = dbAllocNext(bmp, dp, blkno, nblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\tif (rc == 0)\n\t\tmark_metapage_dirty(mp);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "700-875",
    "snippet": "int dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\n{\n\tint rc, agno;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp;\n\tstruct metapage *mp;\n\ts64 lblkno, blkno;\n\tstruct dmap *dp;\n\tint l2nb;\n\ts64 mapSize;\n\tint writers;\n\n\t/* assert that nblocks is valid */\n\tassert(nblocks > 0);\n\n\t/* get the log2 number of blocks to be allocated.\n\t * if the number of blocks is not a log2 multiple,\n\t * it will be rounded up to the next log2 multiple.\n\t */\n\tl2nb = BLKSTOL2(nblocks);\n\n\tbmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tmapSize = bmp->db_mapsize;\n\n\t/* the hint should be within the map */\n\tif (hint >= mapSize) {\n\t\tjfs_error(ip->i_sb, \"the hint is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* if the number of blocks to be allocated is greater than the\n\t * allocation group size, try to allocate anywhere.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n\t\tgoto write_unlock;\n\t}\n\n\t/*\n\t * If no hint, let dbNextAG recommend an allocation group\n\t */\n\tif (hint == 0)\n\t\tgoto pref_ag;\n\n\t/* we would like to allocate close to the hint.  adjust the\n\t * hint to the block following the hint since the allocators\n\t * will start looking for free space starting at this point.\n\t */\n\tblkno = hint + 1;\n\n\tif (blkno >= bmp->db_mapsize)\n\t\tgoto pref_ag;\n\n\tagno = blkno >> bmp->db_agl2size;\n\n\t/* check if blkno crosses over into a new allocation group.\n\t * if so, check if we should allow allocations within this\n\t * allocation group.\n\t */\n\tif ((blkno & (bmp->db_agsize - 1)) == 0)\n\t\t/* check if the AG is currently being written to.\n\t\t * if so, call dbNextAG() to find a non-busy\n\t\t * AG with sufficient free space.\n\t\t */\n\t\tif (atomic_read(&bmp->db_active[agno]))\n\t\t\tgoto pref_ag;\n\n\t/* check if the allocation request size can be satisfied from a\n\t * single dmap.  if so, try to allocate from the dmap containing\n\t * the hint using a tiered strategy.\n\t */\n\tif (nblocks <= BPERDMAP) {\n\t\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\t/* get the buffer for the dmap containing the hint.\n\t\t */\n\t\trc = -EIO;\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\tgoto read_unlock;\n\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* first, try to satisfy the allocation request with the\n\t\t * blocks beginning at the hint.\n\t\t */\n\t\tif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0) {\n\t\t\t\t*results = blkno;\n\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t}\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\twriters = atomic_read(&bmp->db_active[agno]);\n\t\tif ((writers > 1) ||\n\t\t    ((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\n\t\t\t/*\n\t\t\t * Someone else is writing in this allocation\n\t\t\t * group.  To avoid fragmenting, try another ag\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\tgoto pref_ag;\n\t\t}\n\n\t\t/* next, try to satisfy the allocation request with blocks\n\t\t * near the hint.\n\t\t */\n\t\tif ((rc =\n\t\t     dbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\t/* try to satisfy the allocation request with blocks within\n\t\t * the same dmap as the hint.\n\t\t */\n\t\tif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipbmap);\n\t}\n\n\t/* try to satisfy the allocation request with blocks within\n\t * the same allocation group as the hint.\n\t */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\n\t\tgoto write_unlock;\n\n\tIWRITE_UNLOCK(ipbmap);\n\n\n      pref_ag:\n\t/*\n\t * Let dbNextAG recommend a preferred allocation group\n\t */\n\tagno = dbNextAG(ipbmap);\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* Try to allocate within this allocation group.  if that fails, try to\n\t * allocate anywhere in the map.\n\t */\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n      write_unlock:\n\tIWRITE_UNLOCK(ipbmap);\n\n\treturn (rc);\n\n      read_unlock:\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
      "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
      "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
      "static int dbFindBits(u32 word, int l2nb);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocAny",
          "args": [
            "bmp",
            "nblocks",
            "l2nb",
            "results"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1564-1586",
          "snippet": "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAllocAG",
          "args": [
            "bmp",
            "agno",
            "nblocks",
            "l2nb",
            "results"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1365-1535",
          "snippet": "static int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbNextAG",
          "args": [
            "ipbmap"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "dbNextAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "603-660",
          "snippet": "int dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocDmapLev",
          "args": [
            "bmp",
            "dp",
            "(int) nblocks",
            "l2nb",
            "results"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapLev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1996-2030",
          "snippet": "static int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocNear",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "(int) nblocks",
            "l2nb",
            "results"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocNear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1256-1308",
          "snippet": "static int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bmp->db_active[agno]"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocNext",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "(int) nblocks"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1125-1226",
          "snippet": "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bmp->db_active[agno]"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"the hint is outside the map\\n\""
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKSTOL2",
          "args": [
            "nblocks"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nblocks > 0"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\n{\n\tint rc, agno;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp;\n\tstruct metapage *mp;\n\ts64 lblkno, blkno;\n\tstruct dmap *dp;\n\tint l2nb;\n\ts64 mapSize;\n\tint writers;\n\n\t/* assert that nblocks is valid */\n\tassert(nblocks > 0);\n\n\t/* get the log2 number of blocks to be allocated.\n\t * if the number of blocks is not a log2 multiple,\n\t * it will be rounded up to the next log2 multiple.\n\t */\n\tl2nb = BLKSTOL2(nblocks);\n\n\tbmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tmapSize = bmp->db_mapsize;\n\n\t/* the hint should be within the map */\n\tif (hint >= mapSize) {\n\t\tjfs_error(ip->i_sb, \"the hint is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* if the number of blocks to be allocated is greater than the\n\t * allocation group size, try to allocate anywhere.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n\t\tgoto write_unlock;\n\t}\n\n\t/*\n\t * If no hint, let dbNextAG recommend an allocation group\n\t */\n\tif (hint == 0)\n\t\tgoto pref_ag;\n\n\t/* we would like to allocate close to the hint.  adjust the\n\t * hint to the block following the hint since the allocators\n\t * will start looking for free space starting at this point.\n\t */\n\tblkno = hint + 1;\n\n\tif (blkno >= bmp->db_mapsize)\n\t\tgoto pref_ag;\n\n\tagno = blkno >> bmp->db_agl2size;\n\n\t/* check if blkno crosses over into a new allocation group.\n\t * if so, check if we should allow allocations within this\n\t * allocation group.\n\t */\n\tif ((blkno & (bmp->db_agsize - 1)) == 0)\n\t\t/* check if the AG is currently being written to.\n\t\t * if so, call dbNextAG() to find a non-busy\n\t\t * AG with sufficient free space.\n\t\t */\n\t\tif (atomic_read(&bmp->db_active[agno]))\n\t\t\tgoto pref_ag;\n\n\t/* check if the allocation request size can be satisfied from a\n\t * single dmap.  if so, try to allocate from the dmap containing\n\t * the hint using a tiered strategy.\n\t */\n\tif (nblocks <= BPERDMAP) {\n\t\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\t/* get the buffer for the dmap containing the hint.\n\t\t */\n\t\trc = -EIO;\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\tgoto read_unlock;\n\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* first, try to satisfy the allocation request with the\n\t\t * blocks beginning at the hint.\n\t\t */\n\t\tif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0) {\n\t\t\t\t*results = blkno;\n\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t}\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\twriters = atomic_read(&bmp->db_active[agno]);\n\t\tif ((writers > 1) ||\n\t\t    ((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\n\t\t\t/*\n\t\t\t * Someone else is writing in this allocation\n\t\t\t * group.  To avoid fragmenting, try another ag\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\tgoto pref_ag;\n\t\t}\n\n\t\t/* next, try to satisfy the allocation request with blocks\n\t\t * near the hint.\n\t\t */\n\t\tif ((rc =\n\t\t     dbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\t/* try to satisfy the allocation request with blocks within\n\t\t * the same dmap as the hint.\n\t\t */\n\t\tif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipbmap);\n\t}\n\n\t/* try to satisfy the allocation request with blocks within\n\t * the same allocation group as the hint.\n\t */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\n\t\tgoto write_unlock;\n\n\tIWRITE_UNLOCK(ipbmap);\n\n\n      pref_ag:\n\t/*\n\t * Let dbNextAG recommend a preferred allocation group\n\t */\n\tagno = dbNextAG(ipbmap);\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* Try to allocate within this allocation group.  if that fails, try to\n\t * allocate anywhere in the map.\n\t */\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n      write_unlock:\n\tIWRITE_UNLOCK(ipbmap);\n\n\treturn (rc);\n\n      read_unlock:\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "dbNextAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "603-660",
    "snippet": "int dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAP_UNLOCK",
          "args": [
            "bmp"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bmp->db_active[agpref]"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bmp->db_active[agpref]"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BMAP_LOCK",
          "args": [
            "bmp"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}"
  },
  {
    "function_name": "dbUpdatePMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "423-576",
    "snippet": "int\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int cnttz(u32 word);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mp->synclist",
            "&tblk->synclist"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->clsn",
            "log"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "tblk->clsn",
            "log"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mp->synclist",
            "&tblk->synclist"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->lsn",
            "log"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->pmap[word]",
            "(int) ONES",
            "nwords * 4"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dp->pmap[word]",
            "0",
            "nwords * 4"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~mask"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rbits",
            "DBWORD - wbitno"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapage_wait_for_io",
          "args": [
            "mp"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_wait_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "120-124",
          "snippet": "static inline void metapage_wait_for_io(struct metapage *mp)\n{\n\tif (test_bit(META_io, &mp->flag))\n\t\twait_on_page_writeback(mp->page);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_io\t\t6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_io\t\t6\n\nstatic inline void metapage_wait_for_io(struct metapage *mp)\n{\n\tif (test_bit(META_io, &mp->flag))\n\t\twait_on_page_writeback(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "bmp->db_ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "lsn",
            "log"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ipbmap->i_sb",
            "\"blocks are outside the map\\n\""
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\"",
            "(unsigned long long) blkno",
            "(unsigned long long) nblocks"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "331-399",
    "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
      "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
      "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
      "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
      "static int blkstol2(s64 nb);",
      "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
      "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
      "static int dbInitDmapTree(struct dmap * dp);",
      "static int dbGetL2AGSize(s64 nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"error in block map\\n\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFreeDmap",
          "args": [
            "bmp",
            "dp",
            "blkno",
            "nb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "dbFreeDmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "2115-2152",
          "snippet": "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rem",
            "BPERDMAP - (blkno & (BPERDMAP - 1))"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "lblkno",
            "PSIZE",
            "0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTODMAP",
          "args": [
            "blkno",
            "bmp->db_l2nbperpage"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_issue_discard",
          "args": [
            "ipbmap",
            "blkno",
            "nblocks"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_discard.c",
          "lines": "45-64",
          "snippet": "void jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_discard.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\"",
            "(unsigned long long) blkno",
            "(unsigned long long) nblocks"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipbmap"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(blkno == 0) || (blkno + nblocks > bmp->db_mapsize)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipbmap",
            "RDWRLOCK_DMAP"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "263-311",
    "snippet": "int dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "diWriteSpecial",
          "args": [
            "ipbmap",
            "0"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "diWriteSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "517-555",
          "snippet": "void diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "ipbmap->i_mapping"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bmp->db_agsize"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bmp->db_agfree[i]"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agl2size"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agstart"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agwidth"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agheight"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_aglevel"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_agpref"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_maxag"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_maxlevel"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_numag"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bmp->db_l2nbperpage"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bmp->db_nfree"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bmp->db_mapsize"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"dbSync: read_metapage failed!\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage",
            "PSIZE",
            "0"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbUnmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "242-258",
    "snippet": "int dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bmp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "ipbmap->i_mapping",
            "0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbSync",
          "args": [
            "ipbmap"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "dbSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "263-311",
          "snippet": "int dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "ipbmap"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dbMount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
    "lines": "165-223",
    "snippet": "int dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_discard.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_lock.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BMAP_LOCK_INIT",
          "args": [
            "bmp"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bmp->db_active",
            "0",
            "sizeof(bmp->db_active)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dbmp_le->dn_agsize"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dbmp_le->dn_agl2size"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bmp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipbmap",
            "BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage",
            "PSIZE",
            "0"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct bmap)",
            "GFP_KERNEL"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}"
  }
]