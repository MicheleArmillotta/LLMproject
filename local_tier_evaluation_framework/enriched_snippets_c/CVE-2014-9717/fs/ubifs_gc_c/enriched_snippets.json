[
  {
    "function_name": "_gc_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "971-984",
    "snippet": "_idx_gc_leb(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tint lnum;\n\n\tif (list_empty(&c->idx_gc))\n\t\treturn -ENOSPC;\n\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb, list);\n\tlnum = idx_gc->lnum;\n\t/* c->idx_gc_cnt is updated by the caller when lprops are updated */\n\tlist_del(&idx_gc->list);\n\tkfree(idx_gc);\n\treturn lnum;\n}",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ";\n\tre",
          "args": [
            "urn ln"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc->lis",
          "args": [
            ");\n\tkfree(idx"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">idx_gc.ne",
          "args": [
            "t, struct ubif",
            "gced_ix_leb, list);\n\tlnu",
            "= id"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->idx_gc))",
          "args": [
            "return -"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\n_idx_gc_leb(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tint lnum;\n\n\tif (list_empty(&c->idx_gc))\n\t\treturn -ENOSPC;\n\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb, list);\n\tlnum = idx_gc->lnum;\n\t/* c->idx_gc_cnt is updated by the caller when lprops are updated */\n\tlist_del(&idx_gc->list);\n\tkfree(idx_gc);\n\treturn lnum;\n}"
  },
  {
    "function_name": "_idx_gc(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "952-963",
    "snippet": "stroy_idx_gc(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->idx_gc)) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb,\n\t\t\t\t    list);\n\t\tc->idx_gc_cnt -= 1;\n\t\tlist_del(&idx_gc->list);\n\t\tkfree(idx_gc);\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ";\n\t}",
          "args": [
            "/**"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc->lis",
          "args": [
            ");\n\t\tkfree(id"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">idx_gc.ne",
          "args": [
            "t, struct ubif",
            "gced_ix_leb,\n\t\t\t\t    lis",
            "dx_g"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->idx_gc))",
          "args": [
            "{\n\t\tstruct"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nstroy_idx_gc(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->idx_gc)) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb,\n\t\t\t\t    list);\n\t\tc->idx_gc_cnt -= 1;\n\t\tlist_del(&idx_gc->list);\n\t\tkfree(idx_gc);\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "918-942",
    "snippet": "end_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc, *tmp;\n\tstruct ubifs_wbuf *wbuf;\n\tint err = 0;\n\n\twbuf = &c->jheads[GCHD].wbuf;\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\n\t\tif (idx_gc->unmap) {\n\t\t\tdbg_gc(\"LEB %d\", idx_gc->lnum);\n\t\t\terr = ubifs_leb_unmap(c, idx_gc->lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\n\t\t\t\t\t  LPROPS_NC, 0, LPROPS_TAKEN, -1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlist_del(&idx_gc->list);\n\t\t\tkfree(idx_gc);\n\t\t}\nout:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\treturn er"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t}",
          "args": [
            "out:"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc->lis",
          "args": [
            ");\n\t\t\tkfree(i"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, idx_gc->l",
          "args": [
            "u",
            "LPROPS_NC,",
            "LPRO",
            "LPROPS_T",
            "E",
            "-1);\n\t\t\tif",
            "rr"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, idx_gc->l",
          "args": [
            "u",
            ";\n\t\t\tif (err"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d\", id",
          "args": [
            "_gc->lnu",
            ";\n\t\t\terr = u"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry_safe(idx_gc, tmp,",
          "args": [
            "&c->id",
            "gc,",
            "ist)\n\t\tif",
            "dx_g"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "list_for_"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nend_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc, *tmp;\n\tstruct ubifs_wbuf *wbuf;\n\tint err = 0;\n\n\twbuf = &c->jheads[GCHD].wbuf;\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\n\t\tif (idx_gc->unmap) {\n\t\t\tdbg_gc(\"LEB %d\", idx_gc->lnum);\n\t\t\terr = ubifs_leb_unmap(c, idx_gc->lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\n\t\t\t\t\t  LPROPS_NC, 0, LPROPS_TAKEN, -1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlist_del(&idx_gc->list);\n\t\t\tkfree(idx_gc);\n\t\t}\nout:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "t_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "839-910",
    "snippet": "start_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, flags;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * Unmap (non-index) freeable LEBs. Note that recovery requires that all\n\t * wbufs are sync'd before this, which is done in 'do_commit()'.\n\t */\n\twhile (1) {\n\t\tlp = ubifs_fast_find_freeable(c);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, lp->flags, 0);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t}\n\n\t/* Mark GC'd index LEBs OK to unmap after this commit finishes */\n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tidx_gc->unmap = 1;\n\n\t/* Record index freeable LEBs for unmapping after commit */\n\twhile (1) {\n\t\tlp = ubifs_fast_find_frdi_idx(c);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(lp->flags & LPROPS_INDEX);\n\t\t/* Don't release the LEB until after the next commit */\n\t\tflags = (lp->flags | LPROPS_TAKEN) ^ LPROPS_INDEX;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, flags, 1);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tkfree(idx_gc);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(lp->flags & LPROPS_TAKEN);\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t\tidx_gc->lnum = lp->lnum;\n\t\tidx_gc->unmap = 1;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\t}\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc->lis",
          "args": [
            ", &c->idx_gc)",
            "}\nout:\n\tu"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_INDEX));\n\t\tidx_gc->"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp->flags &",
          "args": [
            "PROPS_TAKEN);\n\t\tubifs_as"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "oto ou"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfre",
          "args": [
            "(i"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er",
          "args": [
            "="
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "build_gc_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "743-746",
          "snippet": "void build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};\n\nvoid build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, c->le",
          "args": [
            "_",
            "ze",
            "0, flags, 1",
            "if (I",
            "E"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp->flags &",
          "args": [
            "PROPS_INDEX);\n\t\t/* Don't"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_TAKEN));\n\t\tubifs_as"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_gced_idx_leb), GFP_NOFS);",
            "if (!idx"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ou"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_frdi_idx(c);\n\t\tif (IS",
          "args": [
            "E"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(idx_gc, &c->",
          "args": [
            "dx_gc,",
            "ist)\n\t\tidx",
            "c->u"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_INDEX));\n\t}\n\n\t/* Ma"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_TAKEN));\n\t\tubifs_as"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ou"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lp, c->le",
          "args": [
            "_",
            "ze",
            "0, lp->flag",
            ";\n\t\tif (I",
            "E"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lp->lnum)",
          "args": [
            "if (err)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_INDEX));\n\t\terr = ub"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_TAKEN));\n\t\tubifs_as"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ou"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_freeable(c);\n\t\tif (IS",
          "args": [
            "E"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\t/*\n\t *",
          "args": [
            "U"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nstart_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, flags;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * Unmap (non-index) freeable LEBs. Note that recovery requires that all\n\t * wbufs are sync'd before this, which is done in 'do_commit()'.\n\t */\n\twhile (1) {\n\t\tlp = ubifs_fast_find_freeable(c);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, lp->flags, 0);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t}\n\n\t/* Mark GC'd index LEBs OK to unmap after this commit finishes */\n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tidx_gc->unmap = 1;\n\n\t/* Record index freeable LEBs for unmapping after commit */\n\twhile (1) {\n\t\tlp = ubifs_fast_find_frdi_idx(c);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(!(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(lp->flags & LPROPS_INDEX);\n\t\t/* Don't release the LEB until after the next commit */\n\t\tflags = (lp->flags | LPROPS_TAKEN) ^ LPROPS_INDEX;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, flags, 1);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tkfree(idx_gc);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(lp->flags & LPROPS_TAKEN);\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\t\tidx_gc->lnum = lp->lnum;\n\t\tidx_gc->unmap = 1;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\t}\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_collect(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "648-826",
    "snippet": "bage_collect(struct ubifs_info *c, int anyway)\n{\n\tint i, err, ret, min_space = c->dead_wm;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert_cmt_locked(c);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (ubifs_gc_should_commit(c))\n\t\treturn -EAGAIN;\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\tret = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\t/* We expect the write-buffer to be empty on entry */\n\tubifs_assert(!wbuf->used);\n\n\tfor (i = 0; ; i++) {\n\t\tint space_before, space_after;\n\n\t\tcond_resched();\n\n\t\t/* Give the commit an opportunity to run */\n\t\tif (ubifs_gc_should_commit(c)) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > SOFT_LEBS_LIMIT && !list_empty(&c->idx_gc)) {\n\t\t\t/*\n\t\t\t * We've done enough iterations. Indexing LEBs were\n\t\t\t * moved and will be available after the commit.\n\t\t\t */\n\t\t\tdbg_gc(\"soft limit, some index LEBs GC'ed, -EAGAIN\");\n\t\t\tubifs_commit_required(c);\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > HARD_LEBS_LIMIT) {\n\t\t\t/*\n\t\t\t * We've moved too many LEBs and have not made\n\t\t\t * progress, give up.\n\t\t\t */\n\t\t\tdbg_gc(\"hard limit, -ENOSPC\");\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Empty and freeable LEBs can turn up while we waited for\n\t\t * the wbuf lock, or while we have been running GC. In that\n\t\t * case, we should just return one of those instead of\n\t\t * continuing to GC dirty LEBs. Hence we request\n\t\t * 'ubifs_find_dirty_leb()' to return an empty LEB if it can.\n\t\t */\n\t\tret = ubifs_find_dirty_leb(c, &lp, min_space, anyway ? 0 : 1);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tdbg_gc(\"no more dirty LEBs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdbg_gc(\"found LEB %d: free %d, dirty %d, sum %d (min. space %d)\",\n\t\t       lp.lnum, lp.free, lp.dirty, lp.free + lp.dirty,\n\t\t       min_space);\n\n\t\tspace_before = c->leb_size - wbuf->offs - wbuf->used;\n\t\tif (wbuf->lnum == -1)\n\t\t\tspace_before = 0;\n\n\t\tret = ubifs_garbage_collect_leb(c, &lp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\t/*\n\t\t\t\t * This is not error, so we have to return the\n\t\t\t\t * LEB to lprops. But if 'ubifs_return_leb()'\n\t\t\t\t * fails, its failure code is propagated to the\n\t\t\t\t * caller instead of the original '-EAGAIN'.\n\t\t\t\t */\n\t\t\t\terr = ubifs_return_leb(c, lp.lnum);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret == LEB_FREED) {\n\t\t\t/* An LEB has been freed and is ready for use */\n\t\t\tdbg_gc(\"LEB %d freed, return\", lp.lnum);\n\t\t\tret = lp.lnum;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == LEB_FREED_IDX) {\n\t\t\t/*\n\t\t\t * This was an indexing LEB and it cannot be\n\t\t\t * immediately used. And instead of requesting the\n\t\t\t * commit straight away, we try to garbage collect some\n\t\t\t * more.\n\t\t\t */\n\t\t\tdbg_gc(\"indexing LEB %d freed, continue\", lp.lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(ret == LEB_RETAINED);\n\t\tspace_after = c->leb_size - wbuf->offs - wbuf->used;\n\t\tdbg_gc(\"LEB %d retained, freed %d bytes\", lp.lnum,\n\t\t       space_after - space_before);\n\n\t\tif (space_after > space_before) {\n\t\t\t/* GC makes progress, keep working */\n\t\t\tmin_space >>= 1;\n\t\t\tif (min_space < c->dead_wm)\n\t\t\t\tmin_space = c->dead_wm;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg_gc(\"did not make progress\");\n\n\t\t/*\n\t\t * GC moved an LEB bud have not done any progress. This means\n\t\t * that the previous GC head LEB contained too few free space\n\t\t * and the LEB which was GC'ed contained only large nodes which\n\t\t * did not fit that space.\n\t\t *\n\t\t * We can do 2 things:\n\t\t * 1. pick another LEB in a hope it'll contain a small node\n\t\t *    which will fit the space we have at the end of current GC\n\t\t *    head LEB, but there is no guarantee, so we try this out\n\t\t *    unless we have already been working for too long;\n\t\t * 2. request an LEB with more dirty space, which will force\n\t\t *    'ubifs_find_dirty_leb()' to start scanning the lprops\n\t\t *    table, instead of just picking one from the heap\n\t\t *    (previously it already picked the dirtiest LEB).\n\t\t */\n\t\tif (i < SOFT_LEBS_LIMIT) {\n\t\t\tdbg_gc(\"try again\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmin_space <<= 1;\n\t\tif (min_space > c->dark_wm)\n\t\t\tmin_space = c->dark_wm;\n\t\tdbg_gc(\"set min. space to %d\", min_space);\n\t}\n\n\tif (ret == -ENOSPC && !list_empty(&c->idx_gc)) {\n\t\tdbg_gc(\"no space, some index LEBs GC'ed, -EAGAIN\");\n\t\tubifs_commit_required(c);\n\t\tret = -EAGAIN;\n\t}\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (!err)\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err) {\n\t\tret = err;\n\t\tgoto out;\n\t}\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn ret;\n\nout:\n\tubifs_assert(ret < 0);\n\tubifs_assert(ret != -ENOSPC && ret != -EAGAIN);\n\tubifs_wbuf_sync_nolock(wbuf);\n\tubifs_ro_mode(c, ret);\n\tmutex_unlock(&wbuf->io_mutex);\n\tubifs_return_leb(c, lp.lnum);\n\treturn ret;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leb(c, lp.lnum);",
          "args": [
            "turn re"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\tubifs_ret"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, ret);\n\tmu",
          "args": [
            "e",
            "unl"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tubif",
          "args": [
            "_ro_"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret != -ENOS",
          "args": [
            "C && ret != -EAGAIN);\n\tubifs_wbu"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret < 0);\n\tu",
          "args": [
            "ifs_ass"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\treturn re"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, c->gc_lnu",
          "args": [
            ")",
            "if (err)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tif (",
          "args": [
            "err)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "required(c);\n\t\tret =",
          "args": [
            "E"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ace, s",
          "args": [
            "me index LEBs GC'ed, -EAGAIN\");\n\t\tubifs_co"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->idx_gc))",
          "args": [
            "{\n\t\tdbg_gc"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in. sp",
          "args": [
            "ce to %d\", min_space);",
            "}\n\n\tif (r"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gain\")",
          "args": [
            "continu"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ot mak",
          "args": [
            "progress\");\n\n\t\t/*\n\t\t *"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d reta",
          "args": [
            "ned, freed %d bytes\", lp.lnum,",
            "sp",
            "space_before);\n\n\t\tif (spa"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret == LEB_R",
          "args": [
            "TAINED);\n\t\tspace_af"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing LE",
          "args": [
            "%d freed, continue\", lp.lnum);",
            "continu"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d free",
          "args": [
            ", return\", lp.lnum);",
            "ret = l"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb(c, lp.lnum);",
          "args": [
            "if (er"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_collect_leb(c, &lp);\n\t\ti",
          "args": [
            "et"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %",
          "args": [
            ": free %d, dirty %d, sum %d (min. space %d)\",\n\t\t       lp",
            "ree, lp",
            "irty, l",
            "free + l",
            "dirty,\n\t\t       mi",
            "space_b"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re dir",
          "args": [
            "y LEBs\");\n\t\t\tbreak;"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_leb(c, &lp, min_",
          "args": [
            "p",
            "e,",
            "yway ? 0",
            "1);\n\t\tif (ret)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "limit,",
          "args": [
            "-ENOSPC\");\n\t\t\tret = -"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "required(c);\n\t\t\tret =",
          "args": [
            "-"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "limit,",
          "args": [
            "some index LEBs GC'ed, -EAGAIN\");\n\t\t\tubifs_c"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->idx_gc))",
          "args": [
            "{\n\t\t\t/*"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_commit(c)) {\n\t\t\tret",
          "args": [
            "="
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\t/* Giv",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!wbuf->used)",
          "args": [
            "for (i ="
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "if (c->r"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_commit(c))\n\t\treturn",
          "args": [
            "-"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\n\tif (ubif"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmt_locked(c);\n\tubifs_a",
          "args": [
            "s"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nbage_collect(struct ubifs_info *c, int anyway)\n{\n\tint i, err, ret, min_space = c->dead_wm;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert_cmt_locked(c);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (ubifs_gc_should_commit(c))\n\t\treturn -EAGAIN;\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\tret = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\t/* We expect the write-buffer to be empty on entry */\n\tubifs_assert(!wbuf->used);\n\n\tfor (i = 0; ; i++) {\n\t\tint space_before, space_after;\n\n\t\tcond_resched();\n\n\t\t/* Give the commit an opportunity to run */\n\t\tif (ubifs_gc_should_commit(c)) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > SOFT_LEBS_LIMIT && !list_empty(&c->idx_gc)) {\n\t\t\t/*\n\t\t\t * We've done enough iterations. Indexing LEBs were\n\t\t\t * moved and will be available after the commit.\n\t\t\t */\n\t\t\tdbg_gc(\"soft limit, some index LEBs GC'ed, -EAGAIN\");\n\t\t\tubifs_commit_required(c);\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > HARD_LEBS_LIMIT) {\n\t\t\t/*\n\t\t\t * We've moved too many LEBs and have not made\n\t\t\t * progress, give up.\n\t\t\t */\n\t\t\tdbg_gc(\"hard limit, -ENOSPC\");\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Empty and freeable LEBs can turn up while we waited for\n\t\t * the wbuf lock, or while we have been running GC. In that\n\t\t * case, we should just return one of those instead of\n\t\t * continuing to GC dirty LEBs. Hence we request\n\t\t * 'ubifs_find_dirty_leb()' to return an empty LEB if it can.\n\t\t */\n\t\tret = ubifs_find_dirty_leb(c, &lp, min_space, anyway ? 0 : 1);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tdbg_gc(\"no more dirty LEBs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdbg_gc(\"found LEB %d: free %d, dirty %d, sum %d (min. space %d)\",\n\t\t       lp.lnum, lp.free, lp.dirty, lp.free + lp.dirty,\n\t\t       min_space);\n\n\t\tspace_before = c->leb_size - wbuf->offs - wbuf->used;\n\t\tif (wbuf->lnum == -1)\n\t\t\tspace_before = 0;\n\n\t\tret = ubifs_garbage_collect_leb(c, &lp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\t/*\n\t\t\t\t * This is not error, so we have to return the\n\t\t\t\t * LEB to lprops. But if 'ubifs_return_leb()'\n\t\t\t\t * fails, its failure code is propagated to the\n\t\t\t\t * caller instead of the original '-EAGAIN'.\n\t\t\t\t */\n\t\t\t\terr = ubifs_return_leb(c, lp.lnum);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret == LEB_FREED) {\n\t\t\t/* An LEB has been freed and is ready for use */\n\t\t\tdbg_gc(\"LEB %d freed, return\", lp.lnum);\n\t\t\tret = lp.lnum;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == LEB_FREED_IDX) {\n\t\t\t/*\n\t\t\t * This was an indexing LEB and it cannot be\n\t\t\t * immediately used. And instead of requesting the\n\t\t\t * commit straight away, we try to garbage collect some\n\t\t\t * more.\n\t\t\t */\n\t\t\tdbg_gc(\"indexing LEB %d freed, continue\", lp.lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(ret == LEB_RETAINED);\n\t\tspace_after = c->leb_size - wbuf->offs - wbuf->used;\n\t\tdbg_gc(\"LEB %d retained, freed %d bytes\", lp.lnum,\n\t\t       space_after - space_before);\n\n\t\tif (space_after > space_before) {\n\t\t\t/* GC makes progress, keep working */\n\t\t\tmin_space >>= 1;\n\t\t\tif (min_space < c->dead_wm)\n\t\t\t\tmin_space = c->dead_wm;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg_gc(\"did not make progress\");\n\n\t\t/*\n\t\t * GC moved an LEB bud have not done any progress. This means\n\t\t * that the previous GC head LEB contained too few free space\n\t\t * and the LEB which was GC'ed contained only large nodes which\n\t\t * did not fit that space.\n\t\t *\n\t\t * We can do 2 things:\n\t\t * 1. pick another LEB in a hope it'll contain a small node\n\t\t *    which will fit the space we have at the end of current GC\n\t\t *    head LEB, but there is no guarantee, so we try this out\n\t\t *    unless we have already been working for too long;\n\t\t * 2. request an LEB with more dirty space, which will force\n\t\t *    'ubifs_find_dirty_leb()' to start scanning the lprops\n\t\t *    table, instead of just picking one from the heap\n\t\t *    (previously it already picked the dirtiest LEB).\n\t\t */\n\t\tif (i < SOFT_LEBS_LIMIT) {\n\t\t\tdbg_gc(\"try again\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmin_space <<= 1;\n\t\tif (min_space > c->dark_wm)\n\t\t\tmin_space = c->dark_wm;\n\t\tdbg_gc(\"set min. space to %d\", min_space);\n\t}\n\n\tif (ret == -ENOSPC && !list_empty(&c->idx_gc)) {\n\t\tdbg_gc(\"no space, some index LEBs GC'ed, -EAGAIN\");\n\t\tubifs_commit_required(c);\n\t\tret = -EAGAIN;\n\t}\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (!err)\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err) {\n\t\tret = err;\n\t\tgoto out;\n\t}\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn ret;\n\nout:\n\tubifs_assert(ret < 0);\n\tubifs_assert(ret != -ENOSPC && ret != -EAGAIN);\n\tubifs_wbuf_sync_nolock(wbuf);\n\tubifs_ro_mode(c, ret);\n\tmutex_unlock(&wbuf->io_mutex);\n\tubifs_return_leb(c, lp.lnum);\n\treturn ret;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_collect_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "469-610",
    "snippet": "bage_collect_leb(struct ubifs_info *c, struct ubifs_lprops *lp)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tint err = 0, lnum = lp->lnum;\n\n\tubifs_assert(c->gc_lnum != -1 || wbuf->offs + wbuf->used == 0 ||\n\t\t     c->need_recovery);\n\tubifs_assert(c->gc_lnum != lnum);\n\tubifs_assert(wbuf->lnum != lnum);\n\n\tif (lp->free + lp->dirty == c->leb_size) {\n\t\t/* Special case - a free LEB  */\n\t\tdbg_gc(\"LEB %d is free, return it\", lp->lnum);\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\n\t\tif (lp->free != c->leb_size) {\n\t\t\t/*\n\t\t\t * Write buffers must be sync'd before unmapping\n\t\t\t * freeable LEBs, because one of them may contain data\n\t\t\t * which obsoletes something in 'lp->pnum'.\n\t\t\t */\n\t\t\terr = gc_sync_wbufs(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = ubifs_change_one_lp(c, lp->lnum, c->leb_size,\n\t\t\t\t\t\t  0, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\treturn LEB_RETAINED;\n\t\t}\n\n\t\treturn LEB_FREED;\n\t}\n\n\t/*\n\t * We scan the entire LEB even though we only really need to scan up to\n\t * (c->leb_size - lp->free).\n\t */\n\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\tubifs_assert(!list_empty(&sleb->nodes));\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\n\tif (snod->type == UBIFS_IDX_NODE) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tdbg_gc(\"indexing LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\t\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\t\t\tint level = le16_to_cpu(idx->level);\n\n\t\t\tubifs_assert(snod->type == UBIFS_IDX_NODE);\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\terr = ubifs_dirty_idx_node(c, &snod->key, level, lnum,\n\t\t\t\t\t\t   snod->offs);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc->lnum = lnum;\n\t\tidx_gc->unmap = 0;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\n\t\t/*\n\t\t * Don't release the LEB until after the next commit, because\n\t\t * it may contain data which is needed for recovery. So\n\t\t * although we freed this LEB, it will become usable only after\n\t\t * the commit.\n\t\t */\n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0,\n\t\t\t\t\t  LPROPS_INDEX, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = LEB_FREED_IDX;\n\t} else {\n\t\tdbg_gc(\"data LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\n\t\terr = move_nodes(c, sleb);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = gc_sync_wbufs(c);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0, 0, 0);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\t/* Allow for races with TNC */\n\t\tc->gced_lnum = lnum;\n\t\tsmp_wmb();\n\t\tc->gc_seq += 1;\n\t\tsmp_wmb();\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\terr = LEB_RETAINED;\n\t\t} else {\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = LEB_FREED;\n\t\t}\n\t}\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_inc_seq:\n\t/* We may have moved at least some nodes so allow for races with TNC */\n\tc->gced_lnum = lnum;\n\tsmp_wmb();\n\tc->gc_seq += 1;\n\tsmp_wmb();\n\tgoto out;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oto out",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->gc_se",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "i",
            "(err"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\t\t\tif",
          "args": [
            "(err"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (c-",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->gc_s",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, c->",
          "args": [
            "e",
            "size",
            "0, 0, 0, 0)",
            "f",
            "e",
            ")"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb);",
          "args": [
            "f",
            "err)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %d",
          "args": [
            "(free %d, dirty %d)\",\n\t\t       ln",
            "e, l",
            ">dirty);",
            "err = m"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, c->",
          "args": [
            "e",
            "size",
            "0, 0,",
            "L",
            "O",
            "1);\n\t\tif (e",
            ")"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc->lis",
          "args": [
            ", &c->idx_gc)",
            "/*\n\t\t *"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_gced_idx_leb), GFP_NOFS);",
            "if (!idx"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "dx_node(c, &snod->ke",
          "args": [
            ",",
            "evel, lnum",
            "sn",
            "if (err"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_idx",
          "args": [
            "k",
            "(c, idx), &snod->key)",
            "err = u"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, idx), &sn",
          "args": [
            "d",
            "key"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->type =",
          "args": [
            "UBIFS_IDX_NODE);\n\t\t\tkey_rea"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "ubifs_"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {",
            "ruct"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing LE",
          "args": [
            "%d (free %d, dirty %d)\",\n\t\t       ln",
            "e, l",
            ">dirty);",
            "list_for"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "ext, struct ubif",
            "scan_nde, list);\n\n\tif",
            "snod"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!list_empty(",
          "args": [
            "sleb->nodes));\n\tsnod = li"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb->nodes",
          "args": [
            ");\n\tsnod = l"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tubi",
          "args": [
            "s_as"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn P"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnum, 0,",
          "args": [
            "-",
            "buf,",
            ")",
            "if (IS",
            "R"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lp->lnum)",
          "args": [
            "if (err)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lp->lnum,",
          "args": [
            "c",
            "leb_size",
            "0,",
            "i",
            "(",
            "r"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp->flags",
          "args": [
            "LPROPS_INDEX));\n\n\t\tif (lp-"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d is f",
          "args": [
            "ee, return it\", lp->lnum);",
            "ubifs_as"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lnum !",
          "args": [
            "lnum);\n\n\tif (lp->"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->gc_lnum !",
          "args": [
            "lnum);\n\tubifs_ass"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->gc_lnum !",
          "args": [
            "-1 || wbuf->offs + wbuf->used == 0 ||\n\t\t     c->need_recovery);\n\tubifs_ass"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nbage_collect_leb(struct ubifs_info *c, struct ubifs_lprops *lp)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tint err = 0, lnum = lp->lnum;\n\n\tubifs_assert(c->gc_lnum != -1 || wbuf->offs + wbuf->used == 0 ||\n\t\t     c->need_recovery);\n\tubifs_assert(c->gc_lnum != lnum);\n\tubifs_assert(wbuf->lnum != lnum);\n\n\tif (lp->free + lp->dirty == c->leb_size) {\n\t\t/* Special case - a free LEB  */\n\t\tdbg_gc(\"LEB %d is free, return it\", lp->lnum);\n\t\tubifs_assert(!(lp->flags & LPROPS_INDEX));\n\n\t\tif (lp->free != c->leb_size) {\n\t\t\t/*\n\t\t\t * Write buffers must be sync'd before unmapping\n\t\t\t * freeable LEBs, because one of them may contain data\n\t\t\t * which obsoletes something in 'lp->pnum'.\n\t\t\t */\n\t\t\terr = gc_sync_wbufs(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = ubifs_change_one_lp(c, lp->lnum, c->leb_size,\n\t\t\t\t\t\t  0, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\treturn LEB_RETAINED;\n\t\t}\n\n\t\treturn LEB_FREED;\n\t}\n\n\t/*\n\t * We scan the entire LEB even though we only really need to scan up to\n\t * (c->leb_size - lp->free).\n\t */\n\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\tubifs_assert(!list_empty(&sleb->nodes));\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\n\tif (snod->type == UBIFS_IDX_NODE) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tdbg_gc(\"indexing LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\t\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\t\t\tint level = le16_to_cpu(idx->level);\n\n\t\t\tubifs_assert(snod->type == UBIFS_IDX_NODE);\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\terr = ubifs_dirty_idx_node(c, &snod->key, level, lnum,\n\t\t\t\t\t\t   snod->offs);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc->lnum = lnum;\n\t\tidx_gc->unmap = 0;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\n\t\t/*\n\t\t * Don't release the LEB until after the next commit, because\n\t\t * it may contain data which is needed for recovery. So\n\t\t * although we freed this LEB, it will become usable only after\n\t\t * the commit.\n\t\t */\n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0,\n\t\t\t\t\t  LPROPS_INDEX, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = LEB_FREED_IDX;\n\t} else {\n\t\tdbg_gc(\"data LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\n\t\terr = move_nodes(c, sleb);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = gc_sync_wbufs(c);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0, 0, 0);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\t/* Allow for races with TNC */\n\t\tc->gced_lnum = lnum;\n\t\tsmp_wmb();\n\t\tc->gc_seq += 1;\n\t\tsmp_wmb();\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\terr = LEB_RETAINED;\n\t\t} else {\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = LEB_FREED;\n\t\t}\n\t}\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_inc_seq:\n\t/* We may have moved at least some nodes so allow for races with TNC */\n\tc->gced_lnum = lnum;\n\tsmp_wmb();\n\tc->gc_seq += 1;\n\tsmp_wmb();\n\tgoto out;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "446-458",
    "snippet": "_sync_wbufs(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tif (i == GCHD)\n\t\t\tcontinue;\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\t\tif (err)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\n_sync_wbufs(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tif (i == GCHD)\n\t\t\tcontinue;\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "349-431",
    "snippet": "ve_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb)\n{\n\tint err, min;\n\tLIST_HEAD(nondata);\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tif (wbuf->lnum == -1) {\n\t\t/*\n\t\t * The GC journal head is not set, because it is the first GC\n\t\t * invocation since mount.\n\t\t */\n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = sort_nodes(c, sleb, &nondata, &min);\n\tif (err)\n\t\tgoto out;\n\n\t/* Write nodes to their new location. Use the first-fit strategy */\n\twhile (1) {\n\t\tint avail;\n\t\tstruct ubifs_scan_node *snod, *tmp;\n\n\t\t/* Move data nodes */\n\t\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\t\t\tif  (snod->len > avail)\n\t\t\t\t/*\n\t\t\t\t * Do not skip data nodes in order to optimize\n\t\t\t\t * bulk-read.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Move non-data nodes */\n\t\tlist_for_each_entry_safe(snod, tmp, &nondata, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\t\t\tif (avail < min)\n\t\t\t\tbreak;\n\n\t\t\tif  (snod->len > avail) {\n\t\t\t\t/*\n\t\t\t\t * Keep going only if this is an inode with\n\t\t\t\t * some data. Otherwise stop and switch the GC\n\t\t\t\t * head. IOW, we assume that data-less inode\n\t\t\t\t * nodes and direntry nodes are roughly of the\n\t\t\t\t * same size.\n\t\t\t\t */\n\t\t\t\tif (key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t\t    snod->len == UBIFS_INO_NODE_SZ)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (list_empty(&sleb->nodes) && list_empty(&nondata))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Waste the rest of the space in the LEB and switch to the\n\t\t * next LEB.\n\t\t */\n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tlist_splice_tail(&nondata, &sleb->nodes);\n\treturn err;\n}\n\n/**\n * gc_s",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ail(&nondata, &s",
          "args": [
            "eb->node",
            ";\n\treturn er"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ondata))",
          "args": [
            "break;"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb->nodes",
          "args": [
            "&& list_emp"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb, sno",
          "args": [
            ",",
            "buf)",
            "i",
            "(err"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_DE"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry_safe(snod, tmp, &",
          "args": [
            "onda",
            ", l",
            "t) {",
            "ail"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb, sno",
          "args": [
            ",",
            "buf)",
            "i",
            "(err"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry_safe(snod, tmp, &",
          "args": [
            "leb-",
            "ode",
            "list) {",
            "ail"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb, &no",
          "args": [
            "d",
            "a, &",
            "n);\n\tif",
            "rr)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data);\n\ts",
          "args": [
            "ruct ub"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nve_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb)\n{\n\tint err, min;\n\tLIST_HEAD(nondata);\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tif (wbuf->lnum == -1) {\n\t\t/*\n\t\t * The GC journal head is not set, because it is the first GC\n\t\t * invocation since mount.\n\t\t */\n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = sort_nodes(c, sleb, &nondata, &min);\n\tif (err)\n\t\tgoto out;\n\n\t/* Write nodes to their new location. Use the first-fit strategy */\n\twhile (1) {\n\t\tint avail;\n\t\tstruct ubifs_scan_node *snod, *tmp;\n\n\t\t/* Move data nodes */\n\t\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\t\t\tif  (snod->len > avail)\n\t\t\t\t/*\n\t\t\t\t * Do not skip data nodes in order to optimize\n\t\t\t\t * bulk-read.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Move non-data nodes */\n\t\tlist_for_each_entry_safe(snod, tmp, &nondata, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\t\t\tif (avail < min)\n\t\t\t\tbreak;\n\n\t\t\tif  (snod->len > avail) {\n\t\t\t\t/*\n\t\t\t\t * Keep going only if this is an inode with\n\t\t\t\t * some data. Otherwise stop and switch the GC\n\t\t\t\t * head. IOW, we assume that data-less inode\n\t\t\t\t * nodes and direntry nodes are roughly of the\n\t\t\t\t * same size.\n\t\t\t\t */\n\t\t\t\tif (key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t\t    snod->len == UBIFS_INO_NODE_SZ)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (list_empty(&sleb->nodes) && list_empty(&nondata))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Waste the rest of the space in the LEB and switch to the\n\t\t * next LEB.\n\t\t */\n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tlist_splice_tail(&nondata, &sleb->nodes);\n\treturn err;\n}\n\n/**\n * gc_s"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "321-337",
    "snippet": "ve_node(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t     struct ubifs_scan_node *snod, struct ubifs_wbuf *wbuf)\n{\n\tint err, new_lnum = wbuf->lnum, new_offs = wbuf->offs + wbuf->used;\n\n\tcond_resched();\n\terr = ubifs_wbuf_write_nolock(wbuf, snod->node, snod->len);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_tnc_replace(c, &snod->key, sleb->lnum,\n\t\t\t\tsnod->offs, new_lnum, new_offs,\n\t\t\t\tsnod->len);\n\tlist_del(&snod->list);\n\tkfree(snod);\n\treturn err;\n}\n\n/**\n * move",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->list)",
          "args": [
            "kfree(sno"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lace(c, &snod->ke",
          "args": [
            ",",
            "leb->lnum,",
            "snod->o",
            "ew_lnum, n",
            "_offs,",
            "snod->l",
            "list_del("
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ite_nolock(wbuf, snod->",
          "args": [
            "ode,",
            "nod->len);",
            "if (err)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\terr = ub",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nve_node(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t     struct ubifs_scan_node *snod, struct ubifs_wbuf *wbuf)\n{\n\tint err, new_lnum = wbuf->lnum, new_offs = wbuf->offs + wbuf->used;\n\n\tcond_resched();\n\terr = ubifs_wbuf_write_nolock(wbuf, snod->node, snod->len);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_tnc_replace(c, &snod->key, sleb->lnum,\n\t\t\t\tsnod->offs, new_lnum, new_offs,\n\t\t\t\tsnod->len);\n\tlist_del(&snod->list);\n\tkfree(snod);\n\treturn err;\n}\n\n/**\n * move"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "247-308",
    "snippet": "rt_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t      struct list_head *nondata, int *min)\n{\n\tint err;\n\tstruct ubifs_scan_node *snod, *tmp;\n\n\t*min = INT_MAX;\n\n\t/* Separate data nodes and non-data nodes */\n\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\tubifs_assert(snod->type == UBIFS_INO_NODE  ||\n\t\t\t     snod->type == UBIFS_DATA_NODE ||\n\t\t\t     snod->type == UBIFS_DENT_NODE ||\n\t\t\t     snod->type == UBIFS_XENT_NODE ||\n\t\t\t     snod->type == UBIFS_TRUN_NODE);\n\n\t\tif (snod->type != UBIFS_INO_NODE  &&\n\t\t    snod->type != UBIFS_DATA_NODE &&\n\t\t    snod->type != UBIFS_DENT_NODE &&\n\t\t    snod->type != UBIFS_XENT_NODE) {\n\t\t\t/* Probably truncation node, zap it */\n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(key_type(c, &snod->key) == UBIFS_DATA_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_INO_KEY  ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_XENT_KEY);\n\n\t\terr = ubifs_tnc_has_node(c, &snod->key, 0, sleb->lnum,\n\t\t\t\t\t snod->offs, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!err) {\n\t\t\t/* The node is obsolete, remove it from the list */\n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (snod->len < *min)\n\t\t\t*min = snod->len;\n\n\t\tif (key_type(c, &snod->key) != UBIFS_DATA_KEY)\n\t\t\tlist_move_tail(&snod->list, nondata);\n\t}\n\n\t/* Sort data and non-data nodes */\n\tlist_sort(c, &sleb->nodes, &data_nodes_cmp);\n\tlist_sort(c, nondata, &nondata_nodes_cmp);\n\n\terr = dbg_check_data_nodes_order(c, &sleb->nodes);\n\tif (err)\n\t\treturn err;\n\terr = dbg_check_nondata_nodes_order(c, nondata);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n/**\n * move",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data_nodes_order(c, nondata);",
          "args": [
            "(err)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_nodes_order(c, &sleb->no",
          "args": [
            "e",
            ";\n\tif (err)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nondata,",
          "args": [
            "n",
            "data_no",
            "s_cmp);\n\n\terr = db"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sleb->no",
          "args": [
            "e",
            "&data_nodes",
            "mp);\n\tlist_sort"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(&snod->list,",
          "args": [
            "nondata);",
            "/* So"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_DA"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "co",
          "args": [
            "tinu"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "commit(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
          "lines": "918-942",
          "snippet": "end_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc, *tmp;\n\tstruct ubifs_wbuf *wbuf;\n\tint err = 0;\n\n\twbuf = &c->jheads[GCHD].wbuf;\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\n\t\tif (idx_gc->unmap) {\n\t\t\tdbg_gc(\"LEB %d\", idx_gc->lnum);\n\t\t\terr = ubifs_leb_unmap(c, idx_gc->lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\n\t\t\t\t\t  LPROPS_NC, 0, LPROPS_TAKEN, -1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlist_del(&idx_gc->list);\n\t\t\tkfree(idx_gc);\n\t\t}\nout:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/*\n * GC may",
            "ux/list_sort.h>\n#include \"ubi",
            "ux/pagemap.h>\n#include <lin",
            "ux/slab.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nend_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc, *tmp;\n\tstruct ubifs_wbuf *wbuf;\n\tint err = 0;\n\n\twbuf = &c->jheads[GCHD].wbuf;\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\n\t\tif (idx_gc->unmap) {\n\t\t\tdbg_gc(\"LEB %d\", idx_gc->lnum);\n\t\t\terr = ubifs_leb_unmap(c, idx_gc->lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\n\t\t\t\t\t  LPROPS_NC, 0, LPROPS_TAKEN, -1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlist_del(&idx_gc->list);\n\t\t\tkfree(idx_gc);\n\t\t}\nout:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "d->list)",
          "args": [
            "kfree(s"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, &snod->ke",
          "args": [
            ",",
            ", sleb->ln",
            ",",
            "snod-",
            ");\n\t\tif (e"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "snod->key) == UBIFS_DATA_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_INO_KEY  ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_XENT_KEY);\n\n\t\terr = u"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_XE"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_DE"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_IN"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->ke",
          "args": [
            ")",
            "= UBIFS_DA"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->list)",
          "args": [
            "kfree(s"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->type =",
          "args": [
            "UBIFS_INO_NODE  ||\n\t\t\t     snod->type == UBIFS_DATA_NODE ||\n\t\t\t     snod->type == UBIFS_DENT_NODE ||\n\t\t\t     snod->type == UBIFS_XENT_NODE ||\n\t\t\t     snod->type == UBIFS_TRUN_NODE);\n\n\t\tif (sno"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry_safe(snod, tmp, &",
          "args": [
            "leb-",
            "ode",
            "list) {\n\t\tu",
            "fs_a"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nrt_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t      struct list_head *nondata, int *min)\n{\n\tint err;\n\tstruct ubifs_scan_node *snod, *tmp;\n\n\t*min = INT_MAX;\n\n\t/* Separate data nodes and non-data nodes */\n\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\tubifs_assert(snod->type == UBIFS_INO_NODE  ||\n\t\t\t     snod->type == UBIFS_DATA_NODE ||\n\t\t\t     snod->type == UBIFS_DENT_NODE ||\n\t\t\t     snod->type == UBIFS_XENT_NODE ||\n\t\t\t     snod->type == UBIFS_TRUN_NODE);\n\n\t\tif (snod->type != UBIFS_INO_NODE  &&\n\t\t    snod->type != UBIFS_DATA_NODE &&\n\t\t    snod->type != UBIFS_DENT_NODE &&\n\t\t    snod->type != UBIFS_XENT_NODE) {\n\t\t\t/* Probably truncation node, zap it */\n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(key_type(c, &snod->key) == UBIFS_DATA_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_INO_KEY  ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_XENT_KEY);\n\n\t\terr = ubifs_tnc_has_node(c, &snod->key, 0, sleb->lnum,\n\t\t\t\t\t snod->offs, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!err) {\n\t\t\t/* The node is obsolete, remove it from the list */\n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (snod->len < *min)\n\t\t\t*min = snod->len;\n\n\t\tif (key_type(c, &snod->key) != UBIFS_DATA_KEY)\n\t\t\tlist_move_tail(&snod->list, nondata);\n\t}\n\n\t/* Sort data and non-data nodes */\n\tlist_sort(c, &sleb->nodes, &data_nodes_cmp);\n\tlist_sort(c, nondata, &nondata_nodes_cmp);\n\n\terr = dbg_check_data_nodes_order(c, &sleb->nodes);\n\tif (err)\n\t\treturn err;\n\terr = dbg_check_nondata_nodes_order(c, nondata);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n/**\n * move"
  },
  {
    "function_name": "_cmp(void *priv,",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "168-218",
    "snippet": "ndata_nodes_cmp(void *priv, struct list_head *a,\n\t\t\t     struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(key_type(c, &sa->key) != UBIFS_DATA_KEY &&\n\t\t     key_type(c, &sb->key) != UBIFS_DATA_KEY);\n\tubifs_assert(sa->type != UBIFS_DATA_NODE &&\n\t\t     sb->type != UBIFS_DATA_NODE);\n\n\t/* Inodes go before directory entries */\n\tif (sa->type == UBIFS_INO_NODE) {\n\t\tif (sb->type == UBIFS_INO_NODE)\n\t\t\treturn sb->len - sa->len;\n\t\treturn -1;\n\t}\n\tif (sb->type == UBIFS_INO_NODE)\n\t\treturn 1;\n\n\tubifs_assert(key_type(c, &sa->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sa->key) == UBIFS_XENT_KEY);\n\tubifs_assert(key_type(c, &sb->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sb->key) == UBIFS_XENT_KEY);\n\tubifs_assert(sa->type == UBIFS_DENT_NODE ||\n\t\t     sa->type == UBIFS_XENT_NODE);\n\tubifs_assert(sb->type == UBIFS_DENT_NODE ||\n\t\t     sb->type == UBIFS_XENT_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tuint32_t hasha = key_hash(c, &sa->key);\n\t\tuint32_t hashb = key_hash(c, &sb->key);\n\n\t\tif (hasha <= hashb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n/**\n * sort",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "if (has"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "uint32_t"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "if (inum"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "numb = k"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->type ==",
          "args": [
            "BIFS_DENT_NODE ||\n\t\t     sb->type == UBIFS_XENT_NODE);\n\n\tinuma ="
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->type ==",
          "args": [
            "BIFS_DENT_NODE ||\n\t\t     sa->type == UBIFS_XENT_NODE);\n\tubifs_ass"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "sb->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sb->key) == UBIFS_XENT_KEY);\n\tubifs_ass"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "=",
            "UBIFS_XE"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "=",
            "UBIFS_DE"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "sa->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sa->key) == UBIFS_XENT_KEY);\n\tubifs_ass"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "=",
            "UBIFS_XE"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "=",
            "UBIFS_DE"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->type !=",
          "args": [
            "BIFS_DATA_NODE &&\n\t\t     sb->type != UBIFS_DATA_NODE);\n\n\t/* Inode"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "sa->key) != UBIFS_DATA_KEY &&\n\t\t     key_type(c, &sb->key) != UBIFS_DATA_KEY);\n\tubifs_ass"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "!",
            "UBIFS_DA"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "!",
            "UBIFS_DA"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct ub",
          "args": [
            "f",
            "scan_nde, list);\n\n\tub",
            "s_as"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\n\tif (a ==",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nndata_nodes_cmp(void *priv, struct list_head *a,\n\t\t\t     struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(key_type(c, &sa->key) != UBIFS_DATA_KEY &&\n\t\t     key_type(c, &sb->key) != UBIFS_DATA_KEY);\n\tubifs_assert(sa->type != UBIFS_DATA_NODE &&\n\t\t     sb->type != UBIFS_DATA_NODE);\n\n\t/* Inodes go before directory entries */\n\tif (sa->type == UBIFS_INO_NODE) {\n\t\tif (sb->type == UBIFS_INO_NODE)\n\t\t\treturn sb->len - sa->len;\n\t\treturn -1;\n\t}\n\tif (sb->type == UBIFS_INO_NODE)\n\t\treturn 1;\n\n\tubifs_assert(key_type(c, &sa->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sa->key) == UBIFS_XENT_KEY);\n\tubifs_assert(key_type(c, &sb->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sb->key) == UBIFS_XENT_KEY);\n\tubifs_assert(sa->type == UBIFS_DENT_NODE ||\n\t\t     sa->type == UBIFS_XENT_NODE);\n\tubifs_assert(sb->type == UBIFS_DENT_NODE ||\n\t\t     sb->type == UBIFS_XENT_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tuint32_t hasha = key_hash(c, &sa->key);\n\t\tuint32_t hashb = key_hash(c, &sb->key);\n\n\t\tif (hasha <= hashb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n/**\n * sort"
  },
  {
    "function_name": "p(void *priv,",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "125-156",
    "snippet": "ta_nodes_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(key_type(c, &sa->key) == UBIFS_DATA_KEY);\n\tubifs_assert(key_type(c, &sb->key) == UBIFS_DATA_KEY);\n\tubifs_assert(sa->type == UBIFS_DATA_NODE);\n\tubifs_assert(sb->type == UBIFS_DATA_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tunsigned int blka = key_block(c, &sa->key);\n\t\tunsigned int blkb = key_block(c, &sb->key);\n\n\t\tif (blka <= blkb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n/*\n * nonda",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&sb->key)",
          "args": [
            "if (blk"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sa->key)",
          "args": [
            "unsigned"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "if (inum"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "numb = k"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->type ==",
          "args": [
            "BIFS_DATA_NODE);\n\n\tinuma ="
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->type ==",
          "args": [
            "BIFS_DATA_NODE);\n\tubifs_ass"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "sb->key) == UBIFS_DATA_KEY);\n\tubifs_ass"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "=",
            "UBIFS_DA"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type(c,",
          "args": [
            "sa->key) == UBIFS_DATA_KEY);\n\tubifs_ass"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "=",
            "UBIFS_DA"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct ub",
          "args": [
            "f",
            "scan_nde, list);\n\n\tub",
            "s_as"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\n\tif (a ==",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nta_nodes_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(key_type(c, &sa->key) == UBIFS_DATA_KEY);\n\tubifs_assert(key_type(c, &sb->key) == UBIFS_DATA_KEY);\n\tubifs_assert(sa->type == UBIFS_DATA_NODE);\n\tubifs_assert(sb->type == UBIFS_DATA_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tunsigned int blka = key_block(c, &sa->key);\n\t\tunsigned int blkb = key_block(c, &sb->key);\n\n\t\tif (blka <= blkb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n/*\n * nonda"
  },
  {
    "function_name": "d(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/gc.c",
    "lines": "81-114",
    "snippet": "itch_gc_head(struct ubifs_info *c)\n{\n\tint err, gc_lnum = c->gc_lnum;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert(gc_lnum != -1);\n\tdbg_gc(\"switch GC head from LEB %d:%d to LEB %d (waste %d bytes)\",\n\t       wbuf->lnum, wbuf->offs + wbuf->used, gc_lnum,\n\t       c->leb_size - wbuf->offs - wbuf->used);\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The GC write-buffer was synchronized, we may safely unmap\n\t * 'c->gc_lnum'.\n\t */\n\terr = ubifs_leb_unmap(c, gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_add_bud_to_log(c, GCHD, gc_lnum, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = -1;\n\terr = ubifs_wbuf_seek_nolock(wbuf, gc_lnum, 0);\n\treturn err;\n}\n\n/**\n * data",
    "includes": [
      "fs.h\"\n\n/*\n * GC may",
      "ux/list_sort.h>\n#include \"ubi",
      "ux/pagemap.h>\n#include <lin",
      "ux/slab.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ek_nolock(wbuf, gc_lnu",
          "args": [
            ", 0)",
            "return",
            "r"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_log(c, GCHD, gc_",
          "args": [
            "n",
            ", 0)",
            "if (er"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tif (",
          "args": [
            "rr)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, gc_lnum);",
          "args": [
            "(err)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tif (",
          "args": [
            "rr)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h GC h",
          "args": [
            "ad from LEB %d:%d to LEB %d (waste %d bytes)\",\n\t       wbu",
            "buf->offs",
            "wbuf->used, gc_lnum,",
            "c->",
            "wbuf->offs - wbuf->used);\n\n\terr = ub"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gc_lnum != -",
          "args": [
            ");\n\tdbg_gc(\"s"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * GC may\nux/list_sort.h>\n#include \"ubi\nux/pagemap.h>\n#include <lin\nux/slab.h>\n#include <lin\n\nitch_gc_head(struct ubifs_info *c)\n{\n\tint err, gc_lnum = c->gc_lnum;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert(gc_lnum != -1);\n\tdbg_gc(\"switch GC head from LEB %d:%d to LEB %d (waste %d bytes)\",\n\t       wbuf->lnum, wbuf->offs + wbuf->used, gc_lnum,\n\t       c->leb_size - wbuf->offs - wbuf->used);\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The GC write-buffer was synchronized, we may safely unmap\n\t * 'c->gc_lnum'.\n\t */\n\terr = ubifs_leb_unmap(c, gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_add_bud_to_log(c, GCHD, gc_lnum, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = -1;\n\terr = ubifs_wbuf_seek_nolock(wbuf, gc_lnum, 0);\n\treturn err;\n}\n\n/**\n * data"
  }
]